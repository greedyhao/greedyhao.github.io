<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhuhao&#39;s Blog</title>
  
  <subtitle>I am the captain of my ship and the master of my fate.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://greedyhao.cc/"/>
  <updated>2019-05-26T15:20:03.432Z</updated>
  <id>http://greedyhao.cc/</id>
  
  <author>
    <name>Greedyhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>uboot启动阶段分析二</title>
    <link href="http://greedyhao.cc/2019/05/26/%E5%B7%A5%E4%BD%9C-x210-2019-05-26-uboot%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E5%88%86%E6%9E%90%E4%BA%8C/"/>
    <id>http://greedyhao.cc/2019/05/26/工作-x210-2019-05-26-uboot启动阶段分析二/</id>
    <published>2019-05-26T15:17:53.000Z</published>
    <updated>2019-05-26T15:20:03.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物理基址定义">物理基址定义</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_TEXT_PHY_BASE:</span><br><span class="line">.wordCFG_PHY_UBOOT_BASE</span><br></pre></td></tr></table></figure><p><code>start.s</code> 中使用 <code>_TEXT_PHY_BASE</code> 存放物理基址。这个变量很重要，因为我们在 u-boot 中使用 MMU ，在 MMU 没有开启之前，需要这个变量来保证程序能在正确的地址运行</p><p>通过在 u-boot 源码中全局搜索可以发现， <code>CFG_PHY_UBOOT_BASE</code> 定义在 <code>uboot/include/configs/x210_sd.h</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMORY_BASE_ADDRESS0x30000000</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFG_PHY_UBOOT_BASEMEMORY_BASE_ADDRESS + 0x3e00000</span></span><br></pre></td></tr></table></figure><p><code>CFG_PHY_UBOOT_BASE</code> 这个宏是在 <code>MEMORY_BASE_ADDRESS</code> 的位置上偏移了 0x3e00000 的空间</p><h1 id="链接脚本需要的变量">链接脚本需要的变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.globl _bss_start</span><br><span class="line">_bss_start:</span><br><span class="line">.word __bss_start</span><br><span class="line"></span><br><span class="line">.globl _bss_end</span><br><span class="line">_bss_end:</span><br><span class="line">.word _end</span><br></pre></td></tr></table></figure><p><code>_bss_start</code> <code>_bss_end</code> 这两个变量之前也在链接脚本中见过</p><p>BSS 段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域</p><p>BSS 段使用前需要清0，通过在这里提供 BSS 段的地址，方便链接时清0</p><h1 id="复位">复位</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reset:</span><br><span class="line">/*</span><br><span class="line"> * set the cpu to SVC32 mode and IRQ &amp; FIQ disable</span><br><span class="line"> */</span><br><span class="line">@;mrsr0,cpsr</span><br><span class="line">@;bicr0,r0,#0x1f</span><br><span class="line">@;orrr0,r0,#0xd3</span><br><span class="line">@;msrcpsr,r0</span><br><span class="line">msrcpsr_c, #0xd3@ I &amp; F disable, Mode: 0x13 - SVC</span><br></pre></td></tr></table></figure><p>到这里就是 u-boot 真正的复位代码了</p><p><strong>MSR</strong> 指令用亍将操作数的内容传送到程序状态寄存器的特定域中</p><p><strong>cpsr</strong> 是 ARM 架构的当前程序状态寄存器，而 <strong>cpsr_c</strong> 是程序状态寄存器的后8位，也就是控制位</p><p>cpsr 寄存器的描述如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/bl0_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>I 和 F 位对应的是 IRQ 和 FIQ 中断的标志位，置1为关闭</p><p>因为模式位是前5位控制的，所以 0xd3 相当于 0x13，对应的就是 SVC(管理)模式</p><p>再加上代码中的注释，我们就可以知道这段代码的作用就是让处理器进入 SVC 模式并关闭中断</p><h1 id="cpu_init_crit">cpu_init_crit</h1><p>这里是为了初始化一些重要的寄存器和内存的时钟</p><p>cpu_init_crit 只会在重启的时候运行，当 u-boot 在 ram 中的时候不会运行</p><p>这部分做了这些事 1. 重新初始化开启 L2 cache 2. 刷新 L1 的数据和指令 cache 3. 关闭 MMU 4. 读取启动介质选择</p><p>##　读取启动信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldrr0, =PRO_ID_BASE        @ PRO_ID_BASE=E000 0000</span><br><span class="line">ldrr1, [r0,#OMR_OFFSET]    @ OMR_OFFSET=0000 0004</span><br><span class="line">bicr2, r1, #0xffffffc1</span><br></pre></td></tr></table></figure><p>这段代码目的是从 E000 0004 这个寄存器读取电平信息，这个寄存器是 OM 引脚的地址。通过设置　OM 引脚的电平，就可以设置　ｕ-boot 的启动介质</p><p>bic 的作用是为了清除无关的位，方便后面进行启动介质的判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* NAND BOOT */</span><br><span class="line">cmpr2, #0x0@ 512B 4-cycle</span><br><span class="line">moveqr3, #BOOT_NAND</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* SD/MMC BOOT */</span><br><span class="line">cmp     r2, #0xc</span><br><span class="line">moveq   r3, #BOOT_MMCSD</span><br><span class="line"></span><br><span class="line">/* NOR BOOT */</span><br><span class="line">cmp     r2, #0x14</span><br><span class="line">moveq   r3, #BOOT_NOR</span><br></pre></td></tr></table></figure><p>通过判断前面存入 r2 的值，得到不同的启动介质的信息</p><h2 id="lowlevel_init">lowlevel_init</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldrsp, =0xd0036000 /* end of sram dedicated to u-boot */</span><br><span class="line">subsp, sp, #12/* set stack */</span><br><span class="line">movfp, #0</span><br><span class="line"></span><br><span class="line">bllowlevel_init/* go setup pll,mux,memory */</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/bl0_２.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看出 0xd0036000 是 sram 的地址空间，此时　ddr 还没有初始化完成，只能使用不需要初始化的　sram</p><p>通过 sub 创建了一个 stack，再让 fp(栈帧指针)指向 stack 的开头(fp 用作栈的开头，sp 作为栈的当前位置，fp 和 sp 一起组成了一个栈帧)</p><p>设置 stack 是为了用来存储 LR 的值，因为当前是被调用的子函数中， LR 中存储着当前子函数的范围地址，如果直接使用 bl 调用子函数，就会丢失当前子函数的返回地址</p><p>所以在子函数中调用子函数时，需要先将当前的 LR 压栈</p><h1 id="后记">后记</h1><p>关于 SP FP PC LR 寄存器有空会说说的，我也是在学习汇编才接触到这些寄存器，也是在看了些资料才稍微了解了些</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;物理基址定义&quot;&gt;物理基址定义&lt;/h1&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>uboot启动阶段分析一</title>
    <link href="http://greedyhao.cc/2019/05/25/%E5%B7%A5%E4%BD%9C-x210-2019-05-25-uboot%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E5%88%86%E6%9E%90%E4%B8%80/"/>
    <id>http://greedyhao.cc/2019/05/25/工作-x210-2019-05-25-uboot启动阶段分析一/</id>
    <published>2019-05-25T12:53:02.000Z</published>
    <updated>2019-05-26T15:17:28.345Z</updated>
    
    <content type="html"><![CDATA[<p>从上一章的链接脚本分析中，我们知道了uboot的程序是从*ENTRY(_start)*开始的</p><p>在整个uboot工程下搜索**_start<strong>，可以找到一个</strong>start.S**文件包含了这个label，因此uboot启动的分析从这个文件开始</p><h1 id="头文件分析">头文件分析</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_ENABLE_MMU)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/proc/domain.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regs.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>start.S</strong>一开始include的<strong>config.h</strong>这个头文件是由<em>$(TOPDIR)/mkconfig</em>自动生成的，具体生成的脚本如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Create board specific header file</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">if [ <span class="string">"$APPEND"</span> = <span class="string">"yes"</span> ]<span class="comment"># Append to existing config file</span></span><br><span class="line">then</span><br><span class="line">echo &gt;&gt; config.h</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&gt; config.h<span class="comment"># Create new config file</span></span><br><span class="line">fi</span><br><span class="line">echo <span class="string">"/* Automatically generated - do not edit */"</span> &gt;&gt;config.h</span><br><span class="line">echo <span class="string">"#include &lt;configs/$1.h&gt;"</span> &gt;&gt;config.h</span><br></pre></td></tr></table></figure><p><em>config.h</em>这个头文件中的内容如下，<em>configs/x210_sd.h</em>中包含的是与x210特性相关的用于适配的宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Automatically generated - do not edit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;configs/x210_sd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>通过搜索这个头文件，我们可以发现<strong>CONFIG_ENABLE_MMU</strong>被定义，所以会包含<em>asm/proc/domain.h</em>这个头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ cat include/configs/x210_sd.h | grep CONFIG_ENABLE_MMU</span><br><span class="line">#define CONFIG_ENABLE_MMU</span><br><span class="line">#ifdef CONFIG_ENABLE_MMU</span><br><span class="line">#ifdef CONFIG_ENABLE_MMU</span><br></pre></td></tr></table></figure><p>通过<em>ls -l</em>可以发现这个头文件是<strong>proc-armv</strong>文件夹的一个软连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ ls -il include/asm/ | grep proc</span><br><span class="line">6430221 lrwxrwxrwx 1 greedyhao greedyhao      9 3月  15 09:31 proc -&gt; proc-armv</span><br></pre></td></tr></table></figure><p>之所以使用<strong>proc</strong>而不是<strong>proc-armv</strong>，是为了可移植性。</p><p>试想一下，在移植时需要去把<strong>proc-xxx</strong>一个个修改是件多么痛苦的事，而且这种启动代码应该可重用的部分很多，使用软连接的方式可以减少很多不必要的工作</p><h1 id="启动文件的校验头">启动文件的校验头</h1><p>uboot 选择 SD/NAND 启动方式，需要启动文件提供一个16字节的校验头，<code>start.S</code> 就在开头填充了16字节的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#if defined(CONFIG_EVT1) &amp;&amp; !defined(CONFIG_FUSED)</span><br><span class="line">.word 0x2000</span><br><span class="line">.word 0x0</span><br><span class="line">.word 0x0</span><br><span class="line">.word 0x0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>在 uboot 编译完，得到可执行文件后，还需要补充这16字节的校验和，uboot才能启动</p><p>三星有提供程序用来计算这个校验和，下面简单看看</p><h2 id="计算校验和">计算校验和</h2><p>程序的用法如下</p><p><code>Usage: mkbl1 &lt;source file&gt; &lt;destination file&gt; &lt;size&gt;</code></p><p>在使用这个程序的时候，会向程序的 main 函数中传递一个参数数组 *argv[] ，而且 argv[0] = mkbl1，argv[1] = source file，argv[2] = destination file，argv[3] = size，这些都是基本常识，就不多说了</p><p>mkbl1 在得到文件的大小后，先会分配一个缓冲区，准备用来存放需要处理的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufLen = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">Buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(BufLen);</span><br><span class="line"><span class="built_in">memset</span>(Buf, <span class="number">0x00</span>, BufLen);</span><br></pre></td></tr></table></figure><p>准备好缓冲区后，就把需要处理的文件读入，使用 fseek 计算文件长度，再使用 fread 将文件读入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已删除错误处理</span></span><br><span class="line">fp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>);</span><br><span class="line"></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">fileLen = ftell(fp);</span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">nbytes = fread(Buf, <span class="number">1</span>, BufLen, fp);</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><p>计算校验和的时候需要跳过前16个字节，然后从第9个字节开始写入计算出来的校验和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = Buf + <span class="number">16</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, checksum = <span class="number">0</span>; i &lt; BufLen - <span class="number">16</span>; i++)</span><br><span class="line">checksum += (<span class="number">0x000000FF</span>) &amp; *a++;</span><br><span class="line"></span><br><span class="line">a = Buf + <span class="number">8</span>;</span><br><span class="line">*( (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)a ) = checksum;</span><br></pre></td></tr></table></figure><p>写入也和读取类似，先 fopen 再使用 fwrite 写入，最后释放掉缓存区的空间</p><h1 id="异常向量表">异常向量表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start: breset</span><br><span class="line">ldrpc, _undefined_instruction</span><br><span class="line">ldrpc, _software_interrupt</span><br><span class="line">ldrpc, _prefetch_abort</span><br><span class="line">...</span><br><span class="line">.global _end_vect</span><br><span class="line">_end_vect:</span><br><span class="line">.balignl 16,0xdeadbeef</span><br></pre></td></tr></table></figure><p>异常向量表是当程序发生异常时的处理方式，在向量表制作完后，使用 balignl 伪指令，让内存16字节对齐，加速硬件访问；至于 0xdeadbeef 代表用来补位垃圾数据</p><h1 id="复位向量设置">复位向量设置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_TEXT_BASE:</span><br><span class="line">.wordTEXT_BASE</span><br></pre></td></tr></table></figure><p>定义了一个 _TEXT_BASE 标签用来存放复位向量，主要是用在处理器初始化和 stack 的设置</p><p>至于 TEXT_BASE 之前介绍过，由 makefile 文件导入</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x210_sd_config :unconfig</span><br><span class="line">@<span class="variable">$(MKCONFIG)</span> $(@:_config=) arm s5pc11x x210 samsung s5pc110</span><br><span class="line">@echo <span class="string">"TEXT_BASE = 0xc3e00000"</span> &gt; <span class="variable">$(obj)</span>board/samsung/x210/config.mk</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从上一章的链接脚本分析中，我们知道了uboot的程序是从*ENTRY(_start)*开始的&lt;/p&gt;
&lt;p&gt;在整个uboot工程下搜索**_start&lt;strong&gt;，可以找到一个&lt;/strong&gt;start.S**文件包含了这个label，因此uboot启动的分析从这个文
      
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>使用机智云平台远程控制esp8266</title>
    <link href="http://greedyhao.cc/2019/05/13/%E5%B7%A5%E4%BD%9C-mcu-esp8266-2019-05-13-%E4%BD%BF%E7%94%A8%E6%9C%BA%E6%99%BA%E4%BA%91%E5%B9%B3%E5%8F%B0%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6esp8266/"/>
    <id>http://greedyhao.cc/2019/05/13/工作-mcu-esp8266-2019-05-13-使用机智云平台远程控制esp8266/</id>
    <published>2019-05-13T12:41:41.000Z</published>
    <updated>2019-05-13T12:54:18.718Z</updated>
    
    <content type="html"><![CDATA[<p>机智云平台是一个物联网平台，使用机智云平台可以简化设备联网的步骤。</p><a id="more"></a><p>从零开始的基于机智云平台的Demo实现，估计也就2个多小时，下面开始</p><h1 id="机智云平台相关">机智云平台相关</h1><h2 id="注册开发者账号">注册开发者账号</h2><p>机智云开发者账号，用于产品接入、设备管理、OTA服务、MCU开发等的功能使用。 注册链接：http://dev.gizwits.com/zh-cn/developer/</p><h2 id="创建新设备">创建新设备</h2><p>如下图，点击右上角创建新产品</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图，选择Wi-Fi/移动网络方案</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="创建数据点">创建数据点</h2><p>如图，电机新建数据点</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>弹出窗口中输入标识名，可读写，数据类型按需要选择</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>相关参考:http://docs.gizwits.com/zh-cn/deviceDev/UseSOC.html#2-%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91</p></blockquote><h1 id="准备上云端了">准备上云端了</h1><h2 id="云端生成代码">云端生成代码</h2><p>如图，左边菜单栏选择MCU开发，需要填写的<strong>Product Secret</strong>看下面</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图，左边菜单栏选择基本信息，点击显示完整密钥就行了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图，最后下载代码</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="修改代码">修改代码</h2><p>如图，修改 app/Gizwits/gizwits_product.c 的 gizwitsEventProcess</p><p>在之前设置的数据点(EVENT_)对应的case下添加自己的代码</p><p>需要初始化的外设可以在 app/user/user_main.c 的 user_init 下初始化</p><h2 id="编译源码">编译源码</h2><p>编译源码需要搭建交叉编译环境</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这部分参考这个链接，我懒得写了：http://docs.gizwits.com/zh-cn/deviceDev/WiFiSOC/GoKit3S%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91.html#GoKit3-S-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91</p><h2 id="烧写固件">烧写固件</h2><p>下载烧写软件</p><p>https://www.espressif.com/sites/default/files/tools/flash_download_tools_v3.6.4.rar</p><p>第一次需要烧写的 bin 文件有四个</p><p>bin/blank.bin bin/boot_v1.6.bin bin/esp_init_data_default.bin bin/upgrade/user1.4096.new.6.bin</p><h3 id="开发板进入烧录方式">开发板进入烧录方式</h3><p>如图，开关拨到下载位置，开发板关闭</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>点击烧录软件的开始按钮后，给开发板上电</p><p>烧录完毕后记得将开关拨回运行</p><p>bin 文件的烧录地址看下面</p><h3 id="烧录地址">烧录地址</h3><p>esp_init_data_default.bin 0x3fc000 blank.bin 0x3fe000 boot_v1.6.bin 0x00000 user1.4096.new.6.bin 0x01000</p><p>选项：CrystalFreq=26M SPI_SPEED=40MHz SPI_MODE=QIO FLASH_SIZE=32Mbit-C1, 其他默认，串口115200 进入uart烧录模式后，点击start下载即可！</p><p>官方的图的配置有点问题，我直接在图上改了，懒得重新弄</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/10.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="设备开始连接云">设备开始连接云</h1><h2 id="下载配网app">下载配网APP</h2><p>到这个网址去下载app用来给esp8266配网，ios还是安卓看个人手机</p><p>https://download.gizwits.com/zh-cn/p/98/99</p><h2 id="登陆开发者账号">登陆开发者账号</h2><p>软件需要登陆的，就先前创建的账号</p><h2 id="设备配网">设备配网</h2><p>如下面几个图操作就好</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/11.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/12.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/13.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/14.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/15.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如果前面没问题的话，这里应该设备就配网成功了，可以远程操作了</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266//img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机智云平台是一个物联网平台，使用机智云平台可以简化设备联网的步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="esp8266" scheme="http://greedyhao.cc/tags/esp8266/"/>
    
  </entry>
  
  <entry>
    <title>pid算法的基础应用</title>
    <link href="http://greedyhao.cc/2019/05/04/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-05-04-pid%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    <id>http://greedyhao.cc/2019/05/04/自动控制-PID-2019-05-04-pid算法的基础应用/</id>
    <published>2019-05-04T15:06:07.000Z</published>
    <updated>2019-05-04T15:53:39.299Z</updated>
    
    <content type="html"><![CDATA[<p>五一放假终于有空，先验证一下之前了解的pid算法。</p><p>本次实验是应用pid算法，保持舵机与平面的角度保持在一定的数值。</p><a id="more"></a><p>感觉表述有点不清楚，从视频中看看吧。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/servo_pid/servo_pid_test.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="说说我做了的尝试">说说我做了的尝试</h1><h2 id="系统辨识建立模型">系统辨识建立模型</h2><p>本来之前以为可以通过matlab工具箱的系统辨识建立模型，然后通过工具箱自动调参</p><p>但是！自动调参更新完pid参数后，阶跃响应为负值</p><p>没办法，只能放弃这个操作了</p><h2 id="瞎调参数">瞎调参数</h2><p>之后就随便乱调参数，发现要不抖的厉害，要不就迟滞时间太长</p><p>随便调了几下后就放弃这个方法了</p><h2 id="arduino中的自整定算法">Arduino中的自整定算法</h2><p>就是<a href="https://github.com/br3ttb/Arduino-PID-Library/blob/master/examples/PID_AdaptiveTunings/PID_AdaptiveTunings.ino" target="_blank" rel="noopener">Arduino-PID-Library</a>的自整定例子</p><p>在疯狂调节相关参数后，还是抖的厉害，没法用</p><h1 id="系统整体框架">系统整体框架</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/servo_pid/design_of_sys.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="模糊pid">模糊PID</h1><p>最后还是选择了模糊PID的方法</p><p>随便在网上找到了一个用于Arduino的开源算法，<a href="https://github.com/afakharany93/Fuzzy-like-PI-controller" target="_blank" rel="noopener">Fuzzy-like-PI-controller</a></p><p>整合了mpu6050和舵机的相关代码后，得到了这个项目</p><p>这是这个项目的简单流程描述</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/servo_pid/fussy_pid_design.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="存在问题">存在问题</h2><p>为了验证pid的算法，今天一整天就没得了，心态有点爆炸了，所以最后这代码写的很随意了</p><p>就存在了那么些问题，对代码有兴趣的可以自行去github下载，目录下的README有问题的描述</p><p>代码地址</p><p>https://github.com/greedyhao/servo_mpu6050_pid/tree/master/Arduino</p><h1 id="后记">后记</h1><p>总算又完成一个任务，舒服</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;五一放假终于有空，先验证一下之前了解的pid算法。&lt;/p&gt;
&lt;p&gt;本次实验是应用pid算法，保持舵机与平面的角度保持在一定的数值。&lt;/p&gt;
    
    </summary>
    
      <category term="自动控制" scheme="http://greedyhao.cc/categories/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="PID" scheme="http://greedyhao.cc/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>移植MotionDriver到RTT</title>
    <link href="http://greedyhao.cc/2019/05/03/%E5%B7%A5%E4%BD%9C-rt-thread-2019-05-03-%E7%A7%BB%E6%A4%8DMotionDriver%E5%88%B0RTT/"/>
    <id>http://greedyhao.cc/2019/05/03/工作-rt-thread-2019-05-03-移植MotionDriver到RTT/</id>
    <published>2019-05-03T09:50:07.000Z</published>
    <updated>2019-05-03T09:51:21.690Z</updated>
    
    <content type="html"><![CDATA[<p>这个移植花费了我好多时间...</p><a id="more"></a><p>本来是想使用<a href="http://packages.rt-thread.org/itemDetail.html?package=mpu6xxx" target="_blank" rel="noopener">mpu6xxx的软件包</a>的，但是得到的数据抖动太厉害了</p><p>在网上找到了两种得到稳定的数据的方法 + DMP + Kalman滤波</p><p>看到DMP的效果更好，就选择DMP的方案</p><p>了解到 InvenSense 公司提供的 MotionDriver 可以用DMP的方式读取mpu，就开始移植 MotionDriver 这个库</p><p>本项目的地址 https://github.com/greedyhao/MotionDriver2RTT</p><h1 id="移植步骤">移植步骤</h1><p>简单的说，就是把 core/driver/eMPL/inv_mpu.c 这个文件中需要使用到的函数实现就行了</p><p>这个文件中也有相关说明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The following functions must be defined for this platform:</span></span><br><span class="line"><span class="comment"> * i2c_write(unsigned char slave_addr, unsigned char reg_addr,</span></span><br><span class="line"><span class="comment"> *      unsigned char length, unsigned char const *data)</span></span><br><span class="line"><span class="comment"> * i2c_read(unsigned char slave_addr, unsigned char reg_addr,</span></span><br><span class="line"><span class="comment"> *      unsigned char length, unsigned char *data)</span></span><br><span class="line"><span class="comment"> * delay_ms(unsigned long num_ms)</span></span><br><span class="line"><span class="comment"> * get_ms(unsigned long *count)</span></span><br><span class="line"><span class="comment"> * reg_int_cb(void (*cb)(void), unsigned char port, unsigned char pin)</span></span><br><span class="line"><span class="comment"> * labs(long x)</span></span><br><span class="line"><span class="comment"> * fabsf(float x)</span></span><br><span class="line"><span class="comment"> * min(int a, int b)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>不过实际需要实现的只有 i2c_write i2c_read delay_ms get_ms，以及 core/driver/stm32L/log_stm32.c 下的 log_i 与 log_e 的底层函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> i2c_write   imu_i2c_write_regs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> i2c_read    imu_i2c_read_regs </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> delay_ms    thread_mdelay</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_ms      get_tick_count</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log_i       MPL_LOGI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log_e       MPL_LOGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b)    ((a&lt;b)?a:b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> labs(n)     (((n) &lt; 0) ? (-(n)) : (n))</span></span><br></pre></td></tr></table></figure><h2 id="i2c的实现">i2c的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mpu_device</span> *<span class="title">mpu_dev</span>;</span></span><br></pre></td></tr></table></figure><p>通过 mpu_dev 这个全局指针来保存mpu设备的相关信息</p><p>不过全局指针的方式进行i2c通信不知道会不会不太好，暂时没有其他方式实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> imu_i2c_write_regs(<span class="keyword">unsigned</span> <span class="keyword">char</span> slave_addr, <span class="keyword">unsigned</span> <span class="keyword">char</span> reg_addr, <span class="keyword">unsigned</span> <span class="keyword">short</span> length, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *data_ptr)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!rt_mpu_write_reg(mpu_dev, reg_addr, length, data_ptr))</span><br><span class="line">    &#123;</span><br><span class="line">        res = RT_EOK;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_err_t</span> imu_i2c_read_regs(<span class="keyword">unsigned</span> <span class="keyword">char</span> slave_addr, <span class="keyword">unsigned</span> <span class="keyword">char</span> reg_addr, <span class="keyword">unsigned</span> <span class="keyword">char</span> length, <span class="keyword">unsigned</span> <span class="keyword">char</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">if</span> (!rt_mpu_read_regs(mpu_dev, reg_addr, length, data))</span><br><span class="line">    &#123;</span><br><span class="line">        res = RT_EOK;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 rt-thread 的i2c接口和 MotionDriver 中需要的i2c接口不一致，就写了个中间层适配，从 MotionDriver 的i2c接口传入的 slave_addr 直接使用 mpu_dev 中的地址，这样就可以使用 rt-thread 的 i2c设备框架了</p><p>i2c驱动的实现很重要，不然这个库没办法用的，遇到问题先检查i2c驱动的实现</p><h2 id="其他函数">其他函数</h2><p>其他的函数都可以使用 rt-thread 系统中自带函数</p><h1 id="遇到问题">遇到问题</h1><h2 id="fifo-overflow">fifo overflow</h2><p>卡在这个问题好久，偶然间从网上了解到，DMP程序要考虑到DMP数据的输出速率</p><p>本项目中设置的是100Hz，读取的速度也要相对应，不然就会overflow</p><p>为了防止溢出，我直接加大了fifo的大小，并加快了读取速度</p><h1 id="效果图">效果图</h1><p>现在数据稳得一批</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/motion_driver_test.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个移植花费了我好多时间...&lt;/p&gt;
    
    </summary>
    
    
      <category term="MPU" scheme="http://greedyhao.cc/tags/MPU/"/>
    
  </entry>
  
  <entry>
    <title>pid调节的方法</title>
    <link href="http://greedyhao.cc/2019/04/12/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-04-12-pid%E8%B0%83%E8%8A%82%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://greedyhao.cc/2019/04/12/自动控制-PID-2019-04-12-pid调节的方法/</id>
    <published>2019-04-12T15:09:05.000Z</published>
    <updated>2019-04-12T15:09:14.418Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了建立系统模型的三种方法，这一篇介绍如何调节pid，并用MATLAB仿真</p><a id="more"></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>调节pid的目标就是使得从模型中得到的增益能够使物理系统正常工作</p><h1 id="调节pid的理论分析">调节pid的理论分析</h1><p>pid的一般形式如下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>经过移动化简可以得到</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在我们的问题就简化成了在哪里放置这两个极点，和设置多大的增益？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在给微分器加上滤波器，相当于系统多了一个极点，滤波器的相关内容之后介绍</p><h2 id="matlab仿真">MATLAB仿真</h2><p>仿真使用的模型还是我们上一篇使用的电机模型</p><p>随便取一个之前的模型进行pid控制仿真</p><p>先初始化电机模型的变量，再加上pid的必要模型，开始仿真</p><p>随便调了几下pid参数，得到下图的效果</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="调节零点位置和增益的方法">调节零点位置和增益的方法</h1><h2 id="新名词介绍">新名词介绍</h2><p>根轨迹图(root locus)是控制理论及稳定性理论中，绘图分析的方式，可以看到在特定参数（一般会是反馈系统的环路增益）变化时，系统极点的变化。</p><p>说实话，这东西以前我听都没听过，在经过线上线下查找资料才算知道了这么个东西。</p><p>简单的说，这个图可以用来判断非时变系统系统的稳定性，以及计算系统增益并实现它的控制器</p><p>手画这个图是有许多规则的，不过我没有去了解，毕竟我时间也不多，只知道可以用MATLAB画</p><h2 id="进入主题">进入主题</h2><p>有两种方法用于调节：Pole placement 和 Loop shaping</p><p><strong>Pole placement</strong></p><p>一个简单的开环系统，他的根轨迹图是这样的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在加入PID后，会引入新的零点和极点，就会变成这样</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这种调节方法就是通过调节增益，从而得到希望的系统性能</p><p><strong>Loop shaping</strong></p><p>这个方法和上面的类似，换了种形式的图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>据<a href="http://folk.ntnu.no/skoge/prost/proceedings/ecc03/pdfs/148.pdf" target="_blank" rel="noopener">论文</a>介绍，这两种方法的性能都是差不多的，loop-shaping多了两个优点，(i)不需要在FRF上拟合LTI模型来设计控制器，并且(ii)随着控制器系数的平滑变化，增益调度的实现更加缓慢。</p><p>对于我来说，暂时只管怎么用，好不好用，就没有深入学习了</p><h2 id="matlab仿真-1">MATLAB仿真</h2><p>下图是我用之前的模型随意调的pid的阶跃响应，可以看出是不符合我们的期望的，下面我们就使用MATLAB进行pid调节</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我们首先需要做的是打开<em>analysis-&gt;control design-&gt;control system designer</em>，然后按照下面三张图所示，添加需要调节的pid模块，添加需要的信号</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在control system designer的菜单栏中点击tuning methods，在下拉框中选择root locus editor，就可以得到下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在new plot下选择new step，在弹出窗口按下图配置</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>最终效果如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>手动pid调节</strong></p><p>手动调节说实话我是不太懂，我这里只是随便乱调一下表示可以手动修整而已</p><p>这里使用的是pole placement的方法，loop shaping也是类似的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_8.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>自整定pid</strong></p><p>这里主要还是介绍自整定pid，毕竟方便，不需要懂太多相关知识</p><p>在tuning methods下选择pid tuning</p><p>可以在弹出窗口中选择pid控制器的类型、性能等等，最后附上调节效果图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>最后弄完后要在菜单栏选择update blocks</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_10.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="结尾">结尾</h1><p>调节好的模型已上传github的<a href="https://github.com/greedyhao/trembling-ball-pid/tree/master/software/matlab/motor_model_pid.slx" target="_blank" rel="noopener">项目库</a></p><h1 id="参考资料">参考资料</h1><ul><li><a href="https://ww2.mathworks.cn/help/slcontrol/ug/design-compensator-in-simulink-using-automated-pid-tuning.html" target="_blank" rel="noopener">Design Compensator Using Automated PID Tuning and Graphical Bode Design</a></li><li><a href="https://ww2.mathworks.cn/help/control/getstart/designing-pid-controllers-with-the-pid-tuner-gui.html" target="_blank" rel="noopener">Designing PID Controllers with PID Tuner</a></li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了建立系统模型的三种方法，这一篇介绍如何调节pid，并用MATLAB仿真&lt;/p&gt;
    
    </summary>
    
      <category term="自动控制" scheme="http://greedyhao.cc/categories/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="Matlab" scheme="http://greedyhao.cc/tags/Matlab/"/>
    
      <category term="PID" scheme="http://greedyhao.cc/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>pid建立模型</title>
    <link href="http://greedyhao.cc/2019/04/06/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-04-06-pid%E5%BB%BA%E7%AB%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://greedyhao.cc/2019/04/06/自动控制-PID-2019-04-06-pid建立模型/</id>
    <published>2019-04-06T12:10:36.000Z</published>
    <updated>2019-04-08T15:10:47.461Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章是一份pid的指南，目的是为pid建立一个整体的概念，这一篇简单介绍了pid建立模型的三种方法</p><a id="more"></a><h1 id="根据元件性质直接得到模型">根据元件性质直接得到模型</h1><p>适用于简单的系统，需要关注整个系统的具体组成</p><p>通过欧姆定律等电路定律，为元件建模，最终得到系统模型</p><p>这种方式很麻烦，不在这里讨论</p><h1 id="系统识别的方法">系统识别的方法</h1><p>这种方法不需要关注系统的具体实现，将系统当做一个双端口的加工器，给定输入可以得到想要的输出</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_12_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>就好像图中所示的一个加热器，面包经过加热器后上升了10度，就可以给加热器建立相关的方程了，并不需要知道加热器是电阻加热还是红外光热</p><p>还需要注意的是，给定输入是否在系统输入范围，避免对系统造成损伤</p><h2 id="matlab仿真">MATLAB仿真</h2><p>这里使用到了MATLAB的system identification的工具库</p><p>本次仿真是对一个电机建立模型</p><p><a href="https://github.com/greedyhao/trembling-ball-pid/tree/master/software/matlab/motor_model_sys_id.slx" target="_blank" rel="noopener">电机模型在这里提供</a></p><p>首先需要在matlab命令行初始化模型相关的以下变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">J = 0.01;</span><br><span class="line">b = 0.1;</span><br><span class="line">K = 0.01;</span><br><span class="line">R = 1;</span><br><span class="line">L = 0.5;</span><br></pre></td></tr></table></figure><p>在simulink中运行一遍模型，回到matlab，这时候会发现工作区多了<strong>step_input</strong>和<strong>/img/matlab/motor_speed</strong>这两个变量</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/motor_sys_id_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在matlab的工具箱中找到system identification这个工具，打开</p><p><strong>import data</strong>下选择<strong>time domain data</strong>，在弹出的窗口填入下图中的信息，点击import</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/motor_sys_id_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>接下来在<strong>estimate</strong>的下拉框中选择<strong>transfer function model</strong>，点击<strong>estimate</strong>，运行完后，如图所示把结果<strong>tf1</strong>拖入<strong>to workspace</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/motor_sys_id_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>此时在MATLAB的工作区中应该能看见<strong>tf1</strong>这个变量，在命令行输入<strong>tf1</strong>，就能看见传递函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; tf1</span><br><span class="line"></span><br><span class="line">tf1 =</span><br><span class="line"> </span><br><span class="line">  From input <span class="string">"u1"</span> to output <span class="string">"y1"</span>:</span><br><span class="line">   <span class="number">-1.042e-08</span> s + <span class="number">2</span></span><br><span class="line">  ------------------</span><br><span class="line">  s^<span class="number">2</span> + <span class="number">12</span> s + <span class="number">20.02</span></span><br><span class="line"> </span><br><span class="line">Name: tf1</span><br><span class="line">Continuous-time identified transfer <span class="function"><span class="keyword">function</span>.</span></span><br><span class="line"></span><br><span class="line">Parameterization:</span><br><span class="line">   Number of poles: <span class="number">2</span>   Number of <span class="built_in">zeros</span>: <span class="number">1</span></span><br><span class="line">   Number of free coefficients: <span class="number">4</span></span><br><span class="line">   Use <span class="string">"tfdata"</span>, <span class="string">"getpvec"</span>, <span class="string">"getcov"</span> <span class="keyword">for</span> parameters and their uncertainties.</span><br><span class="line"></span><br><span class="line">Status:                                            </span><br><span class="line">Estimated using TFEST on time domain data <span class="string">"mydata"</span>.</span><br><span class="line">Fit to estimation data: <span class="number">100</span><span class="comment">% (stability enforced)  </span></span><br><span class="line">FPE: <span class="number">4.857e-33</span>, MSE: <span class="number">4.851e-33</span></span><br></pre></td></tr></table></figure><p>回到simulink，修改<strong>DC Motor Transfer Fcn</strong>为对应的传递函数，开始仿真。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/motor_sys_id_4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>仿真结束后打开scope查看，结果如下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/motor_sys_id_5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从结果可以看出这个传递函数是正确的</p><h1 id="对现有非线性模型线性化">对现有非线性模型线性化</h1><p>这个方法和前面系统辨识的方法很类似，不过上一个方法使用的是模型的输入输出结果建立模型，这个是通过对系统线性化得到模型</p><h2 id="matlab仿真-1">MATLAB仿真</h2><p><a href="https://github.com/greedyhao/trembling-ball-pid/tree/master/software/matlab/motor_model_linear.slx" target="_blank" rel="noopener">最终效果的模型在这里提供</a></p><p>如下图所示，先添加<strong>linear analysis points</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/motor_linear_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在菜单栏打开<em>Analysis-&gt;Control Design-&gt;Linear Analysis..</em></p><p>如下图所示，设置<em>t=2</em>，点击<strong>Step Plot 1</strong>，双击点开<strong>linsys1</strong>，显示线性化的选项选择<strong>Transfer Function</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/motor_linear_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如下图所示，验证这个传输函数的正确性</p><p>可以看出这个传递函数是正确的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/motor_linear_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章是一份pid的指南，目的是为pid建立一个整体的概念，这一篇简单介绍了pid建立模型的三种方法&lt;/p&gt;
    
    </summary>
    
      <category term="自动控制" scheme="http://greedyhao.cc/categories/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="Matlab" scheme="http://greedyhao.cc/tags/Matlab/"/>
    
      <category term="PID" scheme="http://greedyhao.cc/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>pid整定概述</title>
    <link href="http://greedyhao.cc/2019/03/28/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-03-28-pid%E6%95%B4%E5%AE%9A%E6%A6%82%E8%BF%B0/"/>
    <id>http://greedyhao.cc/2019/03/28/自动控制-PID-2019-03-28-pid整定概述/</id>
    <published>2019-03-28T01:51:06.000Z</published>
    <updated>2019-04-06T12:15:47.423Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章感觉需要在我pid的知识体系建立好以后重新完善一遍，很多地方很模糊，先占个位，保持顺序，先写后面的文章先</p><p>之前的文章都是介绍pid的原理，现在要说的就是在实际中应用所需要遇到的问题，pid的整定问题</p><a id="more"></a><h1 id="pid系统设计流程">pid系统设计流程</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_10.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>设计一个pid控制系统的流程大致就上面这几个阶段</p><p>本篇文章注重的控制器架构为PID，和这种架构如何调整或者说如何调优</p><h1 id="pid整定指南">pid整定指南</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_11_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>先判断系统是否表现良好，是否存在高非线性、开环不稳定、很多延时、非最小相位等问题，如果表现不良好，需要使用进阶方法</p><p>在系统表现良好的情况下，可以基于数学模型，也可以基于物理模型进行调整pid</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_11_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>增加P可以减少rise time</li><li>增加D提升稳定性和减小超调(overshoot)</li></ul><p>基于物理模型调整pid时，可以通过给系统一个阶跃序列，通过观察系统响应，来调整pid</p><p>这种观察系统响应的启发式方法有<strong>Cohen-Coon Method</strong>和<strong>Ziegler-Nichols</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_11_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我们还可以通过第一性原理，通过实验从物理系统中得到数学模型；也可以通过给物理系统一个阶跃信号，通过阶跃响应得到数学模型。再通过数学模型进行pid调整</p><p>手动调整有<strong>Pole placement</strong>, <strong>loop shaping</strong>, <strong>heuristics</strong>的方法</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_11_4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>此外还可以通过软件的方法，让pid系统自整定</p><h1 id="参考资料">参考资料</h1><ul><li><a href="https://ww2.mathworks.cn/help/control/ref/stepinfo.html?requestedDomain=zh" target="_blank" rel="noopener">stepinfo</a></li><li><a href="http://support.motioneng.com/downloads-notes/tuning//img/auto_control/pid/pid_overshoot.htm" target="_blank" rel="noopener">PID Tuning:Step Behavior</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章感觉需要在我pid的知识体系建立好以后重新完善一遍，很多地方很模糊，先占个位，保持顺序，先写后面的文章先&lt;/p&gt;
&lt;p&gt;之前的文章都是介绍pid的原理，现在要说的就是在实际中应用所需要遇到的问题，pid的整定问题&lt;/p&gt;
    
    </summary>
    
      <category term="自动控制" scheme="http://greedyhao.cc/categories/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="PID" scheme="http://greedyhao.cc/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>pid对微分器的优化</title>
    <link href="http://greedyhao.cc/2019/03/26/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-03-26-pid%E5%AF%B9%E5%BE%AE%E5%88%86%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://greedyhao.cc/2019/03/26/自动控制-PID-2019-03-26-pid对微分器的优化/</id>
    <published>2019-03-26T15:19:40.000Z</published>
    <updated>2019-03-27T07:15:05.299Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://greedyhao.cc/2019/03/25/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-03-25-pid%E6%8A%97%E9%A5%B1%E5%92%8C%E7%A7%AF%E5%88%86/">上一篇</a>文章写了对积分器的优化，这一篇写对微分器的优化</p><a id="more"></a><h1 id="为什么要优化微分器">为什么要优化微分器</h1><p>微分器对于噪声很敏感，我们可以从微分器的laplace传递函数G(s)=s看出来</p><p>通过简单的求导也可以看得出</p><p>假设噪声n(t)是一个正弦函数</p><p><span class="math display">\[n(t) = A\sin(\omega_a t+ \phi_a) \]</span></p><p><span class="math display">\[\frac{dn(t)}{dt} = A\omega_a \sin(\omega_a t+ \phi_a + \frac{\pi}{2})\]</span></p><p>Aω就是经过微分得到的幅度，可以看出，频率越高，对控制信号的影响就越大</p><h1 id="关于噪声">关于噪声</h1><p>现实中，一般情况下无法避免噪声的存在</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_9_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在pid系统中，一般通过传感器来将设备的信息采集出来，通过反馈回路送回pid系统入口处</p><p>但是采集信息的时候会不可避免的被噪声干扰，有热噪声、散射噪声等，这些噪声的存在会干扰pid系统的稳定性</p><h1 id="如何优化微分器">如何优化微分器</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_9_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>很多噪声在整个频域内均匀分布，但是我们的信号却大部分都是低频信号</p><p>为了优化我们得到的信号，一个简单有效的方法就是使用低通滤波器</p><p>通过设置一个合适的截止频率，滤除掉大部分的噪声</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://greedyhao.cc/2019/03/25/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-03-25-pid%E6%8A%97%E9%A5%B1%E5%92%8C%E7%A7%AF%E5%88%86/&quot;&gt;上一篇&lt;/a&gt;文章写了对积分器的优化，这一篇写对微分器的优化&lt;/p&gt;
    
    </summary>
    
      <category term="自动控制" scheme="http://greedyhao.cc/categories/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="PID" scheme="http://greedyhao.cc/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>pid抗饱和积分</title>
    <link href="http://greedyhao.cc/2019/03/25/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-03-25-pid%E6%8A%97%E9%A5%B1%E5%92%8C%E7%A7%AF%E5%88%86/"/>
    <id>http://greedyhao.cc/2019/03/25/自动控制-PID-2019-03-25-pid抗饱和积分/</id>
    <published>2019-03-25T00:47:18.000Z</published>
    <updated>2019-03-25T01:25:01.095Z</updated>
    
    <content type="html"><![CDATA[<p>上文介绍了PID在理想情况下的工作原理，接下来是对实际中使用积分器的展开</p><a id="more"></a><h1 id="积分器的饱和情况">积分器的饱和情况</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>(actuator:机器的一部分)</p><p>我们知道常量的误差值在经过积分器的作用会成为一个递增的函数，也就是说，给设备的指令(command)的转速会不断增加。</p><p>但是我们知道，现实中的电机转速是有限的，在设备指令增加到一定的转速时，电机的转速就不会上升了，这种情况叫做<strong>饱和</strong></p><h1 id="还是以无人机为例">还是以无人机为例</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>还是像之前一样，有一个无人机，目标是悬停在50m处的空中</p><p>但是我们在一开始的时候先<strong>固定</strong>住无人机</p><p>由于被固定住，高度误差不会减小，从而电机指令会不断增加，从而电机转速不断上升，但增加到1000rpm时，达到电机转速的极限，电机转速不再增加</p><p>但是电机指令由于<strong>没有收到高度误差减小</strong>的反馈，依然会不断增加</p><p>直到放开无人机时，电机指令开始减小，减小到1000rpm时，电机转速开始减小，但是高度误差早已经为负，意思就是无人机已经超过50m的高度，飞向自由了</p><h1 id="如何抗饱和积分">如何抗饱和积分</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>有三种方法抗饱和积分 + <strong>clamping</strong>(钳位):根据条件关闭积分器 + <strong>back-calculation</strong>(反算) + <strong>observer opproach</strong>(跟踪模式)</p><p>一般比较常用的是钳位的方法，也称条件积分，因为简单、方便，下面介绍的也是钳位的配置</p><p>我们现在不让设备指令直接给设备了，而是在设备前加一个限定，也就是<strong>钳位饱和限定</strong>，通过判定限定前和限定后的值，判断控制器是否饱和</p><p>对于钳位的情况可以描述如下：</p><ol type="1"><li>积分器的值会被限定在一个指定的值</li><li>积分器的值会在系统误差过大的时候停止，即|e|&gt;e，e为指定的值</li><li>当控制器饱和的时候，积分器的值会停止增大，即，当u≠us时</li><li>当控制器饱和并且系统误差和操作变量符号相同，即，当u≠us且e*u&gt;0时</li></ol><h1 id="参考资料">参考资料</h1><p>公众号内回复 下载|PID资料 获得</p><ul><li>Visioli, A., &quot;Modified Anti-Windup Scheme for PID Controllers,&quot; IEE Proceedings - Control Theory and Applications, Vol. 150, Number 1, January 2003</li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上文介绍了PID在理想情况下的工作原理，接下来是对实际中使用积分器的展开&lt;/p&gt;
    
    </summary>
    
      <category term="自动控制" scheme="http://greedyhao.cc/categories/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="PID" scheme="http://greedyhao.cc/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>pid是什么</title>
    <link href="http://greedyhao.cc/2019/03/24/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-03-24-pid%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://greedyhao.cc/2019/03/24/自动控制-PID-2019-03-24-pid是什么/</id>
    <published>2019-03-24T03:28:26.000Z</published>
    <updated>2019-03-24T04:16:38.344Z</updated>
    
    <content type="html"><![CDATA[<p>本人想做做之前的电赛题--滚球平衡，但这涉及到了一些自动控制的东西，比如PID。</p><p>对PID之前只是略有耳闻，为了复现滚球平衡，只能来现学PID了。</p><a id="more"></a><blockquote><p>本系列内容是看了MATLAB的教学视频后写的，<a href="https://zhuanlan.zhihu.com/p/59928003" target="_blank" rel="noopener">视频链接在此</a></p></blockquote><p>PID的公式在此</p><p><span class="math display">\[u(t) = K_p e(t) + K_i \int^t_0 e(\tau) d\tau + K_d \frac{de(t)}{dt}\]</span></p><p>看着是不是觉得挺复杂，不过放心，让我们先抛弃公式，从PID是什么以及为什么要有PID开始讲起</p><p><img src="/img/auto_control/pid/pid_1.png"></p><p>这里有这么一个我们需要控制的设备，我们需要使用<strong>驱动信号(actuating signal)</strong>取控制它，同时，我们可以获得设备的当前信息，也就是<strong>受控变量(controlled variable)</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这个驱动信号由一个控制器产生，控制器的作用是使得系统的error为0，error则是控制变量减去受控变量的值。<strong>控制变量(commanded variable)</strong>是我们对这个系统的需求，比如将烙铁加热到xx度；<strong>受控变量</strong>是从设备获得的信息，比如当前烙铁xx度。</p><p>接下来就将这个PID模型具象化，以球场上一个人走向半场的过程为例</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图所示，假设这个人离半场的距离有50m，那么控制变量为50m，设定控制器的值为0.1，那么初始速度为5m/s，人接收到速度的指令后行走，反馈回路将当前位置返回累计器，从而调整走路速度，随着人离中场越近，人的速度越慢，直到走到中场，速度为0</p><p>右下角的两张图分别是<strong>路程/时间</strong>、<strong>走路速度/时间</strong>的关系图，体现了控制器不同的值时的区别</p><p>看起来似乎一个比例就可以解决控制器的问题了，那还要积分和微分器干嘛，下面换一个无人机的例子来说明</p><p>如的图所示，有这么个无人机，想悬停在50m的空中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_4_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>无人机无法像上面人走路一样简单的比例就可以完成了，因为无人机会因为重力的作用下坠，如果到了50m的空中电机就定制转动，无人机会直接下坠</p><p>我们假定无人机的悬停需要100rpm的电机速度</p><p>通过增加增益，无人机电机转速会增加，然后上升，反馈使得误差减小，转速降低，降到100rpm时保持悬浮。只有继续增大增益，无人机才会继续上升</p><p>但是无论增益怎么增加，都没办法悬浮在50m处，如图中表格所示，最终会有误差无法消除，管这种误差叫做<strong>稳态误差(steady state error)</strong></p><p>为了消除这种<strong>稳态误差</strong>，可以请积分器出场了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_4_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图所示，一个常数值经过积分器后得到一个增大的函数，会使得转速增加，从而使得无人机上升减小误差</p><p>当误差为0时，只有积分器的输出100rpm，而比例输出为0</p><p>但是现实中并不是这么理想的，当误差E比较小的时候积分器的输出会大于100rpm，而比例的输出大于0，会使得总输出大于100rpm，会使得无人机突然超越50m的高度。这种情况叫做<strong>超调</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_5_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>为了减小这种<strong>超调</strong>的问题，就需要使用微分器了</p><p>对函数的求导可以得到它的斜率。误差函数由于是下降的趋势，微分得到的斜率是小于0的，并且随着下降的速度增大，误差函数斜率的绝对值也增大，这个负值的斜率输出到电机时会减慢电机的速度，这样就可以减小超调量</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_5_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>比例、微分、积分组合起来就是我们常说的PID控制器了，通过调整Kp Ki Kd权重因子，还可以只使用PI PD P等等</p><p>下一篇会讲到积分器的保护或者说抗饱和积分问题</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人想做做之前的电赛题--滚球平衡，但这涉及到了一些自动控制的东西，比如PID。&lt;/p&gt;
&lt;p&gt;对PID之前只是略有耳闻，为了复现滚球平衡，只能来现学PID了。&lt;/p&gt;
    
    </summary>
    
      <category term="自动控制" scheme="http://greedyhao.cc/categories/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="PID" scheme="http://greedyhao.cc/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>uboot链接脚本分析</title>
    <link href="http://greedyhao.cc/2019/03/16/%E5%B7%A5%E4%BD%9C-x210-2019-03-16-uboot%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>http://greedyhao.cc/2019/03/16/工作-x210-2019-03-16-uboot链接脚本分析/</id>
    <published>2019-03-16T13:22:28.000Z</published>
    <updated>2019-03-16T13:27:40.683Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇uboot主编译脚本分析的<a href="http://greedyhao.cc/2019/03/15/uboot%E4%B8%BB%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0">编译选项参数</a>中提到了链接脚本这么个东西</p><p>我也是写到这里才开始了解链接脚本(Linker command scripts)，之前只是大概知道有这么一个东西</p><a id="more"></a><p>先从参考资料中的内容开始说起，充当预备知识</p><blockquote><p>总的来说，脚本定义了四个内存空间(memory regions)为vect、rom、ram and cache，五个段(output sections)为vect、text、bss、init、stack</p></blockquote><h1 id="从参考资料中的范例入手">从参考资料中的范例入手</h1><p>下面是范例中提供的一个简单的链接脚本，简单而健全，先完整的贴上来，然后结合uboot的链接脚本慢慢介绍其中涉及到的OUTPUT_FORMAT、MEMORY等命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/* 要链接的文件列表</span><br><span class="line">(其他的可以在命令行上提供) */</span><br><span class="line">INPUT(libc.a libg.a libgcc.a libc.a libgcc.a)</span><br><span class="line"></span><br><span class="line">/* 输出格式</span><br><span class="line">(可以在命令行上被重写) */</span><br><span class="line">OUTPUT_FORMAT(&quot;coff-sh&quot;)</span><br><span class="line"></span><br><span class="line">/* 输出文件名</span><br><span class="line">(可以在命令行上被重写) */</span><br><span class="line">OUTPUT_FILENAME(&quot;main.out&quot;)</span><br><span class="line"></span><br><span class="line">/* 我们的程序的入口点;</span><br><span class="line">除了确保S7记录是正确的外，没有什么用处，</span><br><span class="line">因为复位向量(reset vector)实际上</span><br><span class="line">定义了大多数嵌入式系统中的“入口点” */</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">/* 内存段的列表 */</span><br><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">    vect : o = 0, l = 1k</span><br><span class="line">    rom : o = 0x400, l = 127k</span><br><span class="line">    ram : o = 0x400000, l = 128k</span><br><span class="line">    cache : o = 0xfffff000, l = 4k</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 组织每个模块中的内存段的方式 */</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    /* 中断向量表 */</span><br><span class="line">    .vect :</span><br><span class="line">    &#123;</span><br><span class="line">        __vect_start = .;</span><br><span class="line">        *(.vect);</span><br><span class="line">        __vect_end = .;</span><br><span class="line">    &#125; &gt; vect</span><br><span class="line"></span><br><span class="line">    /* 代码和常量 */</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        __text_start = .;</span><br><span class="line">        *(.text)</span><br><span class="line">        *(.strings)</span><br><span class="line">        __text_end = .;</span><br><span class="line">    &#125; &gt; rom</span><br><span class="line"></span><br><span class="line">    /* 未初始化的数据 */</span><br><span class="line">    .bss :</span><br><span class="line">    &#123;</span><br><span class="line">        __bss_start = . ;</span><br><span class="line">        *(.bss)</span><br><span class="line">        *(COMMON)</span><br><span class="line">        __bss_end = . ;</span><br><span class="line">    &#125; &gt; ram</span><br><span class="line"></span><br><span class="line">    /* 已初始化的数据 */</span><br><span class="line">    .init : AT (__text_end)</span><br><span class="line">    &#123;</span><br><span class="line">        __data_start = .;</span><br><span class="line">        *(.data)</span><br><span class="line">        __data_end = .;</span><br><span class="line">    &#125; &gt; ram</span><br><span class="line"></span><br><span class="line">    /* 应用程序栈 */</span><br><span class="line">    .stack :</span><br><span class="line">    &#123;</span><br><span class="line">        __stack_start = .;</span><br><span class="line">        *(.stack)</span><br><span class="line">        __stack_end = .;</span><br><span class="line">    &#125; &gt; ram</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="output_format命令">OUTPUT_FORMAT命令</h2><p>这条命令控制输出文件的的格式。</p><p>在x210的uboot脚本中，也是有这个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;)</span><br></pre></td></tr></table></figure><p>这条命令的使用方式为<em>OUTPUT_FORMAT(bfdname), OUTPUT_FORMAT(default, big, little)</em>，上面的例子是第一种使用方式，而uboot中的是第二种方式</p><h2 id="memory命令">MEMORY命令</h2><p>链接器的默认配置允许分配所有可用内存，你可以使用MEMORY命令来覆盖它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MEMORY &#123;</span><br><span class="line">    name [(attr)] : ORIGIN = origin, LENGTH = len</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我记得我以前使用stm32驱动显示器的时候遇到过sram不够用的情况，当时也是通过在链接脚本中添加一个段地址指向外部扩展的ddr，然后让显存地址指向这这个段解决的</p><h2 id="sections命令">SECTIONS命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text :</span><br><span class="line">&#123;</span><br><span class="line">    __text_start = .;</span><br><span class="line">    *(.text)</span><br><span class="line">    *(.strings)</span><br><span class="line">    __text_end = .;</span><br><span class="line">&#125; &gt; rom</span><br></pre></td></tr></table></figure><p>在例子中，定义了一个<strong>.text</strong> 段，并将所有输入文件中的 <strong>.text</strong> and <strong>.strings</strong> 段放入这个段中</p><p>在我们的uboot链接脚本中，还出现了一些其他的东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:</span><br><span class="line">&#123;</span><br><span class="line">    cpu/s5pc11x/start.o(.text)</span><br><span class="line">    ...</span><br><span class="line">    *(.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从脚本中看出，链接不仅仅只是能直接<strong>*(.text)</strong>操作同一类的所有输入段，还能以文件定义的方式添加到输出文件的某个SECTIONS中，以文件定义的方式可以确定不同文件的链接顺序，以免产生依赖缺失的问题</p><h2 id="at指令">AT指令</h2><p>AT指令告诉链接器将一个节的数据加载到它所在的地址之外的其他位置。使用这个指令可以将需要使用的数据存储在ROM中，在使用前将数据从ROM中提前读取到RAM中。</p><h1 id="objdump反汇编验证uboot链接脚本">objdump反汇编验证uboot链接脚本</h1><p>本uboot链接脚本如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;)</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">.text      :</span><br><span class="line">&#123;</span><br><span class="line">  cpu/s5pc11x/start.o(.text)</span><br><span class="line">  ...</span><br><span class="line">  *(.text)</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对编译后生成的elf文件进行反汇编</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ arm-linux-gnueabihf-objdump -f u-boot</span><br><span class="line"></span><br><span class="line">u-boot:     file format elf32-littlearm</span><br><span class="line">architecture: arm, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0xc3e00010</span><br></pre></td></tr></table></figure><p>前面两行就是<strong>OUTPUT_FORMAT</strong>和<strong>OUTPUT_ARCH</strong>对应内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ arm-linux-gnueabihf-objdump -h u-boot</span><br><span class="line"></span><br><span class="line">u-boot:     file format elf32-littlearm</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         0002a0b0  c3e00000  c3e00000  00008000  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>这里的<strong>.text</strong>地址也符合<a href="http://greedyhao.cc/2019/03/15/uboot%E4%B8%BB%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/#%E9%85%8D%E7%BD%AE%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE">主makefile</a>中定义的地址</p><h1 id="参考资料">参考资料</h1><ul><li><p><a href="https://gcc.gnu.org/wiki/Building_Cross_Toolchains_with_gcc?action=AttachFile&amp;do=get&amp;target=billgatliff-toolchains.pdf" target="_blank" rel="noopener">An Introduction to the GNU Compiler and Linker</a></p></li><li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/index.html" target="_blank" rel="noopener">Red Hat Enterprise Linux 4</a></p></li><li><p><a href="https://stackoverflow.com/questions/7182409/how-to-correctly-use-a-simple-linker-script-executable-gets-sigkill-when-run" target="_blank" rel="noopener">How to correctly use a simple linker script? Executable gets SIGKILL when run</a></p></li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇uboot主编译脚本分析的&lt;a href=&quot;http://greedyhao.cc/2019/03/15/uboot%E4%B8%BB%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0&quot;&gt;编译选项参数&lt;/a&gt;中提到了链接脚本这么个东西&lt;/p&gt;
&lt;p&gt;我也是写到这里才开始了解链接脚本(Linker command scripts)，之前只是大概知道有这么一个东西&lt;/p&gt;
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>uboot主编译脚本分析</title>
    <link href="http://greedyhao.cc/2019/03/15/%E5%B7%A5%E4%BD%9C-x210-2019-03-15-uboot%E4%B8%BB%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>http://greedyhao.cc/2019/03/15/工作-x210-2019-03-15-uboot主编译脚本分析/</id>
    <published>2019-03-15T05:24:59.000Z</published>
    <updated>2019-03-16T05:10:18.724Z</updated>
    
    <content type="html"><![CDATA[<p>这里是对uboot的Makefile做的一个比较详细的分析</p><a id="more"></a><h2 id="生成版本信息">生成版本信息</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VERSION = 1</span><br><span class="line">...</span><br><span class="line">U_BOOT_VERSION = <span class="variable">$(VERSION)</span>.<span class="variable">$(PATCHLEVEL)</span>.<span class="variable">$(SUBLEVEL)</span><span class="variable">$(EXTRAVERSION)</span></span><br><span class="line">VERSION_FILE = <span class="variable">$(obj)</span><span class="keyword">include</span>/version_autogenerated.h</span><br></pre></td></tr></table></figure><p>软件都是有不同版本的，uboot也不例外，在makefile开头几行就定义了版本信息，并导出到一个头文件中</p><h2 id="导出架构信息">导出架构信息</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HOSTARCH := <span class="variable">$(<span class="built_in">shell</span> uname -m | \</span></span><br><span class="line"><span class="variable">sed -e s/i.86/i386/ \</span></span><br><span class="line"><span class="variable">    ...</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable">HOSTOS := $(<span class="built_in">shell</span> uname -s | tr '[:upper:]' '[:lower:]' | \</span></span><br><span class="line"><span class="variable">    sed -e 's/\(cygwin\)</span>.*/cygwin/')</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span>HOSTARCH HOSTOS</span><br></pre></td></tr></table></figure><p>获得当前主机的架构和系统，导出到环境变量备用</p><h2 id="静默安装">静默安装</h2><p>静默安装原理很简单，只不过是把<em>echo</em>替换成了<em>:</em></p><p>静默安装时脚本就不会输出那么多没用信息了</p><h2 id="uboot链接文件产生位置">uboot链接文件产生位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># U-boot build supports producing a object files to the separate external</span><br><span class="line"># directory. Two use cases are supported:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>和其他大型的项目类似，uboot也可以把链接文件输出位置重定义到某个位置</p><p>而且uboot提供了两种方式重定义输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1) Add O= to the make command line</span><br><span class="line"># &apos;make O=/tmp/build all&apos;</span><br><span class="line">#</span><br><span class="line"># 2) Set environement variable BUILD_DIR to point to the desired location</span><br><span class="line"># &apos;export BUILD_DIR=/tmp/build&apos;</span><br><span class="line"># &apos;make&apos;</span><br></pre></td></tr></table></figure><h3 id="实现的过程">实现的过程</h3><p>这部分看看脚本就会明白，这里大概说一下</p><p>先判断定义的是O还是直接定义的<strong>BUILD_DIR</strong>，定义的是O的话就把O的值赋给<strong>BUILD_DIR</strong>(非空)</p><p>接下来就定义并导出了<strong>OBJTREE</strong>(BUILD_DIR设置过来的链接文件的位置) <strong>SRCTREE</strong>(当前目录设置来的源码目录) <strong>TOPDIR</strong>(当前目录设置为顶层) <strong>LNDIR</strong>(OBJTREE保存为链接文件位置)</p><p>定义并导出<strong>MKCONFIG</strong>(SRCTREE下的mkconfig脚本，用于配置uboot)</p><p>如果<strong>OBJTREE</strong>和<strong>SRCTREE</strong>不等就定义并导出<strong>REMOTE_BUILD</strong>，并<em>obj := $(OBJTREE) src := $(SRCTREE)</em></p><h2 id="配置交叉编译工具链">配置交叉编译工具链</h2><p>从<em>$(obj)include/config.mk</em>导入<strong>ARCH CPU BOARD VENDOR SOC</strong>这几个变量，<strong>config.mk</strong>这个文件是<em>make x210_sd_config</em>产生的，<strong>x210_sd_config</strong>在Makefile的最后一部分有定义，这是为了确保Makefile的通用性</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x210_sd_config :unconfig</span><br><span class="line">@<span class="variable">$(MKCONFIG)</span> $(@:_config=) arm s5pc11x x210 samsung s5pc110</span><br><span class="line">@echo <span class="string">"TEXT_BASE = 0xc3e00000"</span> &gt; <span class="variable">$(obj)</span>board/samsung/x210/config.mk</span><br></pre></td></tr></table></figure><p>之后就是通过判断<strong>ARCH</strong>的不同，使用不同的<strong>CROSS_COMPILE</strong></p><p>然后就是导入<em>$(TOPDIR)/config.mk</em>中的其他配置</p><h2 id="topdirconfig.mk">$(TOPDIR)/config.mk</h2><p>大概看了下，这个文件提供了编译选项和变量</p><h3 id="导入make变量">导入make变量</h3><p>定义的<strong>CROSS_COMPILE</strong>会在<em>$(TOPDIR)/config.mk</em>中使用</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AS= <span class="variable">$(CROSS_COMPILE)</span>as</span><br><span class="line">LD= <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">CC= <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="导入自动生成配置">导入自动生成配置</h3><p>然后导入*<span class="math inline">\((OBJTREE)/include/autoconf.mk*，这是一个根据开发板自动生成(根据\)</span>(TOPDIR)/include/configs/x210_sd.h定义生成)的脚本，里面定义了一些硬件相关的配置</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_CMD_FAT=y</span><br><span class="line">CONFIG_USB_OHCI=y</span><br><span class="line">CONFIG_SYS_CLK_FREQ=24000000</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再根据<strong>ARCH</strong>等变量，导入对应的config脚本</p><h3 id="编译选项参数">编译选项参数</h3><p>这一部分定义了一堆的FLAGS</p><p><strong>LDSCRIPT</strong>定义链接脚本是否使用nand版</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> LDSCRIPT</span><br><span class="line"><span class="comment">#LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds.debug</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_NAND_U_BOOT)</span>,y)</span><br><span class="line">LDSCRIPT := <span class="variable">$(TOPDIR)</span>/board/<span class="variable">$(BOARDDIR)</span>/u-boot-nand.lds</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LDSCRIPT := <span class="variable">$(TOPDIR)</span>/board/<span class="variable">$(BOARDDIR)</span>/u-boot.lds</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p><strong>TEXT_BASE</strong>是在Makefile中定义的uboot链接地址，上面的<a href="#配置交叉编译工具链">配置交叉编译工具链</a>里就有写</p><p>这里的地址是虚拟地址，物理地址取决于uboot中的地址映射</p><h2 id="uboot链接对象">uboot链接对象</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># U-Boot objects....order is important (i.e. start must be first)</span></span><br><span class="line"></span><br><span class="line">OBJS  = cpu/<span class="variable">$(CPU)</span>/start.o</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CPU)</span>,i386)</span><br><span class="line">OBJS += cpu/<span class="variable">$(CPU)</span>/start16.o</span><br><span class="line">OBJS += cpu/<span class="variable">$(CPU)</span>/reset.o</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这一部分是链接一些必要的库和.o文件</p><h2 id="all标签">ALL标签</h2><p>当我们在命令行使用<em>make</em>时，就会执行这一部分的脚本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALL += <span class="variable">$(obj)</span>u-boot.srec <span class="variable">$(obj)</span>u-boot.bin <span class="variable">$(obj)</span>System.map <span class="variable">$(U_BOOT_NAND)</span> <span class="variable">$(U_BOOT_ONENAND)</span> <span class="variable">$(obj)</span>u-boot.dis</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(ARCH)</span>,blackfin)</span><br><span class="line">ALL += <span class="variable">$(obj)</span>u-boot.ldr</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:<span class="variable">$(ALL)</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在make编译后，我们也能看到这些对象</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ ls | grep u-boot</span></span><br><span class="line">u-boot</span><br><span class="line">u-boot.bin</span><br><span class="line">u-boot.dis</span><br><span class="line">u-boot.map</span><br><span class="line">u-boot.srec</span><br></pre></td></tr></table></figure><h2 id="unconfig">unconfig</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">unconfig:</span></span><br><span class="line">@rm -f <span class="variable">$(obj)</span><span class="keyword">include</span>/config.h <span class="variable">$(obj)</span><span class="keyword">include</span>/config.mk \</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意到上面<a href="#配置交叉编译工具链">配置交叉编译工具链</a>中的<strong>x210_sd_config</strong>和这里的<strong>unconfig</strong>有关，现在再对<strong>x210_sd_config</strong>的这段脚本做进一步的探讨</p><p>$(@:_config=)会把<strong>x210_sd_config</strong>匹配成<strong>x210_sd</strong>，从而使得mkconfig得到了6个参数<strong>x210_sd arm s5pc11x x210 samsung s5pc110</strong></p><h3 id="mkconfig">mkconfig</h3><p>接下来就进入到mkconfig</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span> -gt 0 ] ; <span class="keyword">do</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">--) <span class="built_in">shift</span> ; <span class="built_in">break</span> ;;</span><br><span class="line">-a) <span class="built_in">shift</span> ; APPEND=yes ;;</span><br><span class="line">-n) <span class="built_in">shift</span> ; BOARD_NAME=<span class="string">"<span class="variable">$&#123;1%%_config&#125;</span>"</span> ; <span class="built_in">shift</span> ;;</span><br><span class="line">*)  <span class="built_in">break</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这段脚本的作用就是对传入的第一个参数<strong>$1</strong>进行匹配，<strong>x210_sd</strong>只能匹配上*</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">"<span class="variable">$&#123;BOARD_NAME&#125;</span>"</span> ] || BOARD_NAME=<span class="string">"<span class="variable">$1</span>"</span></span><br></pre></td></tr></table></figure><p>这里就将参数1的值赋给了<strong>BOARD_NAME</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="variable">$#</span> -lt 4 ] &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">[ <span class="variable">$#</span> -gt 6 ] &amp;&amp; <span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>这里是为了避免参数的数量不正确</p><p>之后就是为架构的指定头文件创建符号链接，这是为了可移植性，通过判断传入的<strong>ARCH CPU BOARD</strong>这几个参数，链接不同的头文件</p><h2 id="各种适配">各种适配</h2><p>再接下来的内容就是各种系统下的适配，<a href="#配置交叉编译工具链">配置交叉编译工具链</a>的脚本也是这部分的内容</p><h2 id="make的其他选项">make的其他选项</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">@rm -f <span class="variable">$(obj)</span>examples/82559_eeprom <span class="variable">$(obj)</span>examples/eepro100_eeprom \</span><br><span class="line">...</span><br><span class="line"><span class="section">clobber:clean</span></span><br><span class="line">...</span><br><span class="line"><span class="section">distclean:clobber unconfig</span></span><br><span class="line">    ...</span><br><span class="line"><span class="section">backup:</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是对uboot的Makefile做的一个比较详细的分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>uboot源码目录分析</title>
    <link href="http://greedyhao.cc/2019/03/13/%E5%B7%A5%E4%BD%9C-x210-2019-03-13-uboot%E6%BA%90%E7%A0%81%E6%9E%84%E6%88%90%E5%88%86%E6%9E%90/"/>
    <id>http://greedyhao.cc/2019/03/13/工作-x210-2019-03-13-uboot源码构成分析/</id>
    <published>2019-03-13T04:44:00.000Z</published>
    <updated>2019-03-13T04:49:52.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="uboot源码简单分析">uboot源码简单分析</h1><p>这里只是对uboot源码目录下的内容做一个简单的分析而已，具体的学习会在之后，先来一个整体的了解。</p><a id="more"></a><h1 id="脚本文件分析">脚本文件分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ tree -FL 1 | grep -v /$</span><br><span class="line">.</span><br><span class="line">├── arm_config.mk</span><br><span class="line">├── CHANGELOG</span><br><span class="line">├── CHANGELOG-before-U-Boot-1.1.5</span><br><span class="line">├── Changelog_Samsung</span><br><span class="line">├── config.mk</span><br><span class="line">├── COPYING</span><br><span class="line">├── CREDITS</span><br><span class="line">├── image_split*</span><br><span class="line">├── MAINTAINERS</span><br><span class="line">├── MAKEALL*</span><br><span class="line">├── Makefile</span><br><span class="line">├── mk*</span><br><span class="line">├── mkconfig*</span><br><span class="line">├── mkmovi*</span><br><span class="line">├── README</span><br><span class="line">├── rules.mk</span><br><span class="line">├── System.map</span><br><span class="line">├── u-boot*</span><br><span class="line">├── u-boot.bin*</span><br><span class="line">├── u-boot.dis</span><br><span class="line">├── u-boot.map</span><br><span class="line">└── u-boot.srec*</span><br></pre></td></tr></table></figure><p>常见的类似git、changelog、copyright就略过吧</p><h2 id="image_split">image_split</h2><p>用于分割uboot到BL1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ cat image_split </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script split u-boot binary for secure boot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># spiliting u-boot for BL1 (8KB -128 Byte)</span></span><br><span class="line">rm bl2*</span><br><span class="line">split -b 8064 u-boot.bin bl2.bin</span><br></pre></td></tr></table></figure><h2 id="makeall-makefile-mk">MAKEALL Makefile mk</h2><p>这三个是用来编译uboot的脚本</p><p>MAKEALL大概是用来设置如何编译的，因为看了脚本的前面一部分，是判断如何MAKE、LOG位置、BUILD位置的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;CROSS_COMPILE&#125;</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">MAKE=<span class="string">"make CROSS_COMPILE=<span class="variable">$&#123;CROSS_COMPILE&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">MAKE=make</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;MAKEALL_LOGDIR&#125;</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">LOG_DIR=<span class="variable">$&#123;MAKEALL_LOGDIR&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LOG_DIR=<span class="string">"LOG"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="string">"<span class="variable">$&#123;BUILD_DIR&#125;</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">BUILD_DIR=<span class="string">"."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">[ -d <span class="variable">$&#123;LOG_DIR&#125;</span> ] || mkdir <span class="variable">$&#123;LOG_DIR&#125;</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line">LIST=<span class="string">""</span></span><br></pre></td></tr></table></figure><p>Makefile就是主编译脚本了，用来管理整个uboot的编译，脚本有3千多行，暂时先放一边</p><p>至于mk就是一种类似与一键编译的东西，就把原先编译时需要手动输入的命令放到脚本里，直接执行脚本就可以编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make distclean</span><br><span class="line">make x210_sd_config</span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure><h2 id="mkconfig">mkconfig</h2><p>这个是uboot的主要配置脚本，它会为指定的开发板生成配置需要的头文件和链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh -e</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Script to create header files and links to configure</span></span><br><span class="line"><span class="comment"># U-Boot for a specific board.</span></span><br></pre></td></tr></table></figure><h2 id="mkmovi">mkmovi</h2><p>这个脚本和inand/SD卡启动有关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script will create a u-boot binary for movinand/mmc boot</span></span><br></pre></td></tr></table></figure><h2 id="rules.mk">rules.mk</h2><p>uboot的Makefile使用规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_depend:$(obj).depend</span><br><span class="line"></span><br><span class="line">$(obj).depend:$(src)Makefile $(TOPDIR)/config.mk $(SRCS)</span><br><span class="line">@rm -f <span class="variable">$@</span></span><br><span class="line">@<span class="keyword">for</span> f <span class="keyword">in</span> $(SRCS); <span class="keyword">do</span> \</span><br><span class="line">g=`basename $<span class="variable">$f</span> | sed -e <span class="string">'s/\(.*\)\.\w/\1.o/'</span>`; \</span><br><span class="line">$(CC) -M $(HOST_CFLAGS) $(CPPFLAGS) -MQ $(obj)$<span class="variable">$g</span> $<span class="variable">$f</span> &gt;&gt; <span class="variable">$@</span> ; \</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="其他目录分析">其他目录分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ tree -d -L 1</span><br><span class="line">.</span><br><span class="line">├── api</span><br><span class="line">├── api_examples</span><br><span class="line">├── board</span><br><span class="line">├── common</span><br><span class="line">├── cpu</span><br><span class="line">├── disk</span><br><span class="line">├── doc</span><br><span class="line">├── drivers</span><br><span class="line">├── examples</span><br><span class="line">├── fs</span><br><span class="line">├── include</span><br><span class="line">├── lib_arm</span><br><span class="line">├── libfdt</span><br><span class="line">├── lib_generic</span><br><span class="line">├── nand_spl</span><br><span class="line">├── net</span><br><span class="line">├── onenand_bl1</span><br><span class="line">├── onenand_ipl</span><br><span class="line">├── post</span><br><span class="line">├── sd_fusing</span><br><span class="line">└── tools</span><br></pre></td></tr></table></figure><h2 id="api-api_examples">api api_examples</h2><p>api提供了一系列的系统调用</p><p>api_examples则提供了api的使用例程</p><h2 id="board">board</h2><p>为特定开发板提供移植的文件放在这个文件夹中</p><h2 id="common">common</h2><p>通用代码，与处理器架构无关代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot/common$ ls</span><br><span class="line">ace_sha1.c        cmd_dcr.c       cmd_immap.c      cmd_onenand.c   cmd_vfd.c        env_nowhere.c  miiphybb.c</span><br><span class="line">ACEX1K.c          cmd_df.c        cmd_itest.c      cmd_otp.c       cmd_ximg.c       env_nvram.c    miiphyutil.c</span><br><span class="line">altera.c          cmd_diag.c      cmd_jffs2.c      cmd_pci.c       command.c        env_onenand.c  secure_boot.c</span><br><span class="line">bedbug.c          cmd_display.c   cmd_load.c       cmd_pcmcia.c    console.c        env_sf.c       serial.c</span><br><span class="line">circbuf.c         cmd_doc.c       cmd_log.c        cmd_portio.c    crc16.c          exports.c      soft_i2c.c</span><br><span class="line">cmd_ambapp.c      cmd_dtt.c       cmd_mac.c        cmd_reginfo.c   cyclon2.c        fdt_support.c  soft_spi.c</span><br><span class="line">cmd_android.c     cmd_eeprom.c    cmd_mem.c        cmd_reiser.c    devices.c        flash.c        spartan2.c</span><br><span class="line">cmd_autoscript.c  cmd_elf.c       cmd_mfsl.c       cmd_sata.c      dlmalloc.c       fpga.c         spartan3.c</span><br><span class="line">cmd_bdinfo.c      cmd_ext2.c      cmd_mii.c        cmd_scsi.c      dlmalloc.src     gunzip.c       s_record.c</span><br><span class="line">cmd_bedbug.c      cmd_fastboot.c  cmd_misc.c       cmd_setexpr.c   docecc.c         hush.c         stratixII.c</span><br><span class="line">cmd_bmp.c         cmd_fat.c       cmd_mmc.c        cmd_sf.c        env_auto.c       image.c        usb.c</span><br><span class="line">cmd_boot.c        cmd_fdc.c       cmd_mmc_fdisk.c  cmd_spi.c       env_common.c     kgdb.c         usb_kbd.c</span><br><span class="line">cmd_bootldr.c     cmd_fdos.c      cmd_movi.c       cmd_strings.c   env_dataflash.c  lcd.c          usb_storage.c</span><br><span class="line">cmd_bootm.c       cmd_fdt.c       cmd_mp.c         cmd_terminal.c  env_eeprom.c     lists.c        virtex2.c</span><br><span class="line">cmd_cache.c       cmd_flash.c     cmd_mtdparts.c   cmd_ubi.c       env_flash.c      lynxkdi.c      xilinx.c</span><br><span class="line">cmd_console.c     cmd_fpga.c      cmd_nand.c       cmd_universe.c  environment.c    main.c         xyzModem.c</span><br><span class="line">cmd_cplbinfo.c    cmd_i2c.c       cmd_net.c        cmd_usb.c       env_movi.c       Makefile</span><br><span class="line">cmd_date.c        cmd_ide.c       cmd_nvedit.c     cmd_usbd.c      env_nand.c       memsize.c</span><br></pre></td></tr></table></figure><p>从上面的输出可以看出有三大类的文件 + cmd开头的文件是实现uboot命令的 + env开头的文件是实现环境变量的 + 其他文件是实现一些其他功能如加密算法、驱动框架等等</p><h2 id="cpu">cpu</h2><p>处理器相关的初始化和控制代码</p><p>基本不需要修改</p><h2 id="disk">disk</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot/disk$ ls</span><br><span class="line">Makefile  part_amiga.c  part_amiga.h  part.c  part_dos.c  part_dos.h  part_iso.c  part_iso.h  part_mac.c  part_mac.h</span><br></pre></td></tr></table></figure><p>这个目录下放的是各种系统的分区表，感觉像是用来在不同系统下获取分区信息的</p><h2 id="doc">doc</h2><p>uboot相关文档，不过感觉很乱，架构、算法、存储器、命令等等都混在一起，看起来不怎么方便</p><h2 id="drivers">drivers</h2><p>从linux中移植来的驱动</p><h2 id="examples">examples</h2><p>示例代码</p><h2 id="fs">fs</h2><p>文件系统</p><h2 id="include">include</h2><p>头文件目录</p><h2 id="lib_arm-lib_generic">lib_arm lib_generic</h2><p>架构相关的库文件</p><h2 id="libfdt">libfdt</h2><p>设备树相关</p><h2 id="net">net</h2><p>网络相关代码的简单实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot/net$ ls</span><br><span class="line">bootp.c  bootp.h  eth.c  Makefile  net.c  nfs.c  nfs.h  rarp.c  rarp.h  sntp.c  sntp.h  tftp.c  tftp.h</span><br></pre></td></tr></table></figure><h2 id="onenand-onenan相关代码">onenand* onenan相关代码</h2><h2 id="sd_fusing">sd_fusing</h2><p>SD卡烧写代码</p><h2 id="tools">tools</h2><p>在这个目录下可以看到一些熟悉的名词像crc gdb md5等，这里就是一个工具的集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot/tools$ lsbddb        </span><br><span class="line">envcrc.c       fdt_rw.c        image.c            logos           mkimage.h        sha1.c</span><br><span class="line">bmp_logo.c  environment.c  fdt_strerror.c  img2brec.sh        Makefile        mpc86x_clk.c     ubsha1.c</span><br><span class="line">crc32.c     fdt.c          fdt_wip.c       img2srec.c         Makefile.win32  ncb.c            updater</span><br><span class="line">easylogo    fdt_host.h     gdb             inca-swap-bytes.c  md5.c           scripts          zlib.h</span><br><span class="line">env         fdt_ro.c       gen_eth_addr.c  libfdt_internal.h  mkimage.c       setlocalversion</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;uboot源码简单分析&quot;&gt;uboot源码简单分析&lt;/h1&gt;
&lt;p&gt;这里只是对uboot源码目录下的内容做一个简单的分析而已，具体的学习会在之后，先来一个整体的了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>uboot编译体验</title>
    <link href="http://greedyhao.cc/2019/03/11/%E5%B7%A5%E4%BD%9C-x210-2019-03-11-uboot%E7%BC%96%E8%AF%91%E4%BD%93%E9%AA%8C/"/>
    <id>http://greedyhao.cc/2019/03/11/工作-x210-2019-03-11-uboot编译体验/</id>
    <published>2019-03-11T14:15:37.000Z</published>
    <updated>2019-03-11T14:16:05.846Z</updated>
    
    <content type="html"><![CDATA[<p>想玩玩zynq，但是发现需要linux方面的知识配合会更加合适，因为zynq有arm的硬核，有的时候可能会需要用上linux</p><a id="more"></a><p>正好买了朱有鹏视频，就拿来学习一下</p><p>看了看学习的进程大概是这样的 + 安装编译工具，编译uboot + 分析uboot源码和makefile</p><h1 id="安装交叉编译工具链">安装交叉编译工具链</h1><p>本人使用的开发部是s5pv210，需要安装的交叉编译工具链是<em>arm-2019q3</em></p><p>遵循默认规则，将工具链解压安装到了<em>/usr/local/arm</em>下</p><p>添加到了PATH中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ARM Cross Complier PATH</span><br><span class="line">export PATH=/usr/local/arm/arm-2009q3/bin:$PATH</span><br></pre></td></tr></table></figure><p>测试工具链是否正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:~$ arm-none-linux-gnueabi-gcc --version</span><br><span class="line">arm-none-linux-gnueabi-gcc (Sourcery G++ Lite 2009q3-67) 4.4.1</span><br><span class="line">Copyright (C) 2009 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><h1 id="编译uboot">编译uboot</h1><p>毕竟是有课程学习，有提供做好的uboot源码，可以体验一下编译的感觉，氪金了还真是不一样</p><p>首先是先找到需要编译的bsp,QT4.8版本，并解压出来</p><h2 id="配置">配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ make x210_sd_config </span><br><span class="line">Configuring for x210_sd board...</span><br></pre></td></tr></table></figure><p>如果出现了上面的信息就说明配置成功</p><p>检查Makefile中的编译链位置是否正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-</span><br></pre></td></tr></table></figure><p>查看编译结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ du u-boot*</span><br><span class="line">936u-boot</span><br><span class="line">384u-boot.bin</span><br><span class="line">1780u-boot.dis</span><br><span class="line">184u-boot.map</span><br><span class="line">1156u-boot.srec</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想玩玩zynq，但是发现需要linux方面的知识配合会更加合适，因为zynq有arm的硬核，有的时候可能会需要用上linux&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://greedyhao.cc/tags/Linux/"/>
    
      <category term="x210" scheme="http://greedyhao.cc/tags/x210/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo需要配置的东西</title>
    <link href="http://greedyhao.cc/2019/03/08/%E5%B7%A5%E4%BD%9C-hexo-2019-03-08-%E4%BD%BF%E7%94%A8hexo%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    <id>http://greedyhao.cc/2019/03/08/工作-hexo-2019-03-08-使用hexo需要配置的东西/</id>
    <published>2019-03-08T06:27:14.000Z</published>
    <updated>2019-03-08T06:29:28.659Z</updated>
    
    <content type="html"><![CDATA[<p>每次重装电脑后都要重新部署hexo，每次要配置的东西都要重新去网上找，现在在这里整合以下，免得麻烦</p><a id="more"></a><h1 id="npm">npm</h1><p>先确定npm位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure><p>如果是在<em>/usr/local</em>下，就输入下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R `whoami` &lt;directory&gt; <span class="comment"># directory为你的node_modules位置</span></span><br></pre></td></tr></table></figure><p>如果是在<em>/usr</em>下，可以选择创建一个目录用来安装npm包</p><p>个人是放在<em>/usr/local/lib/node_modules</em>下，然后和上面一样，更改用户组</p><h1 id="hexo安装">hexo安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><h1 id="使用ssh">使用ssh</h1><p>按照下面的命令就可以了，没有的文件就创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"hao_kr@163.com"</span> -f <span class="string">"id_rsa_github"</span> <span class="comment"># 中间一直按回车就好</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"hao_kr@163.com"</span> -f <span class="string">"id_rsa_gitee"</span></span><br></pre></td></tr></table></figure><p>创建一个config文件配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim config</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># gitee</span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_gitee</span><br><span class="line"></span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure><p>最后测试是否成功，如果输出<em>Hi,..</em>就表示成功 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><h1 id="hexo-deploy卡住问题">hexo deploy卡住问题</h1><p>我翻看了很多人写的笔记，给git设置了proxy，使用ssh，但是都没有解决问题</p><p>最后没有办法，只能手动push了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .deploy_git</span><br><span class="line">git remote add git@github.com:xxxx/xxxx.github.io.git</span><br><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><p>这句命令可能会产生一些冲突信息，不用理会</p><p>然后重新生成一下静态页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>回到deploy目录，手动push，第一次push需要设置upstream <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd .deploy_git</span><br><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure></p><p>在这之后我又试了一次<em>hexo d</em>，发现可以成功deploy了，可能之前deploy失败和hexo没有把git的remote设置好有关吧，手动设置remote后就正常了</p><h1 id="markdown渲染">markdown渲染</h1><p>更换mathjax渲染引擎，使用<em>hexo-renderer-pandoc</em>渲染</p><p>首先需要安装pandoc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install pandoc</span><br></pre></td></tr></table></figure><p>之后来到你的hexo的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次重装电脑后都要重新部署hexo，每次要配置的东西都要重新去网上找，现在在这里整合以下，免得麻烦&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://greedyhao.cc/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>体验deepin系统</title>
    <link href="http://greedyhao.cc/2019/03/04/%E5%B7%A5%E4%BD%9C-Linux-2019-03-04-%E4%BD%93%E9%AA%8Cdeepin%E7%B3%BB%E7%BB%9F/"/>
    <id>http://greedyhao.cc/2019/03/04/工作-Linux-2019-03-04-体验deepin系统/</id>
    <published>2019-03-04T15:42:25.000Z</published>
    <updated>2019-03-08T06:22:28.598Z</updated>
    
    <content type="html"><![CDATA[<p>之前体验了<a href="http://mp.weixin.qq.com/s?__biz=MzU0OTAyODAzMg==&amp;mid=100000323&amp;idx=1&amp;sn=7d889a7a8488e70c2ba32a97c7054672&amp;chksm=7bb76bec4cc0e2faeead09d5423fa334110b882d54dd104e790d2691d2d95f5ed0e6cd714d22#rd" target="_blank" rel="noopener">Ubuntu18.04</a>，在使用了几个月后，还是放弃了</p><a id="more"></a><p>主要是Ubuntu18.04有一些很难接受的问题如下: + 双屏体验很差。每次重启后会将笔记本的屏幕设置为主屏幕；从双屏转为单屏时，被关闭屏幕的图标不会自动移动到另一个屏幕。 + 会出现莫名奇妙的BUG</p><p>偶然间了解到了deepin这个系统，看了看他的演示视频，觉得真心不错。很顺畅，界面也好看。</p><p>先上一张启动器的图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/deepin/launcher.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="前期工作">前期工作</h1><p>可以参考一下官方的文档中说的<a href="https://www.deepin.org/installation/" target="_blank" rel="noopener">如何安装</a></p><h2 id="备份">备份</h2><p>如果当前电脑硬盘是MBR格式的话，在安装系统的时候会提示说无法安装，因为需要GPT格式的硬盘才支持安装。</p><p>如果是参考之前的<a href="http://mp.weixin.qq.com/s?__biz=MzU0OTAyODAzMg==&amp;mid=100000323&amp;idx=1&amp;sn=7d889a7a8488e70c2ba32a97c7054672&amp;chksm=7bb76bec4cc0e2faeead09d5423fa334110b882d54dd104e790d2691d2d95f5ed0e6cd714d22#rd" target="_blank" rel="noopener">Ubuntu18.04+win10双系统</a>安装的系统，可能是需要备份一下再安装，安装时会自动帮你转换硬盘格式</p><h2 id="制作启动盘">制作启动盘</h2><p>制作启动盘的方法可以参考官方的文档<a href="https://wiki.deepin.org/wiki/%E5%8E%9F%E7%94%9F%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">原生安装</a></p><p>制作启动盘推荐使用官方制作工具<a href="https://www.deepin.org/original/deepin-boot-maker/" target="_blank" rel="noopener">深度启动盘制作工具</a>，我试过了软碟通制作的启动盘是无法使用的</p><h2 id="选择文件格式挂载点分配空间">选择文件格式、挂载点、分配空间</h2><p>以下配置推荐来自<a href="https://www.deepin.org/installation/" target="_blank" rel="noopener">官方推荐</a>，如果是安装双系统的话需要boot分区</p><table><thead><tr class="header"><th style="text-align: left;">挂载点</th><th style="text-align: left;">挂载点中文名</th><th style="text-align: left;">文件系统</th><th style="text-align: left;">大小</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">/</td><td style="text-align: left;">根分区（必选）</td><td style="text-align: left;">EXT4（推荐）</td><td style="text-align: left;">最少10G</td></tr><tr class="even"><td style="text-align: left;">/boot</td><td style="text-align: left;">引导盘（可选）</td><td style="text-align: left;">EXT4（推荐）</td><td style="text-align: left;">最少800M</td></tr><tr class="odd"><td style="text-align: left;">/home</td><td style="text-align: left;">家目录（推荐）</td><td style="text-align: left;">EXT4（推荐）</td><td style="text-align: left;">最少10G</td></tr><tr class="even"><td style="text-align: left;">swap</td><td style="text-align: left;">交换分区（可选）</td><td style="text-align: left;">不设置</td><td style="text-align: left;">4G内存以下分配2G，4G以上可不分配</td></tr></tbody></table><h1 id="后期工作">后期工作</h1><h2 id="切换显卡驱动">切换显卡驱动</h2><p>进入到启动器搜索gpu，找到打开<strong>显卡驱动管理</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/deepin/gpu_driver_m.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>需要使用双屏的需要选择<strong>NV-PRIME</strong>，单屏的话可以选择<strong>小黄蜂</strong></p><p>有时候切换驱动会失败，一般再试下就可以切换成功了</p><h2 id="系统更新">系统更新</h2><p>在使用前最好更新下系统，因为有些旧版软件有BUG</p><p>在命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade -y</span><br></pre></td></tr></table></figure><h2 id="添加桌面快捷方式">添加桌面快捷方式</h2><p>一些常用软件可以在桌面添加一个快捷方式，这样启动起来比在命令行中启动方便</p><p>可以参考<a href="https://wiki.deepin.org/wiki/Desktop_Entry_%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">Desktop Entry 文件</a>这个文档</p><p>这里简单的说说</p><p>一般个人软件就放在<em>~/.local/share/applications</em>下，Desktop Entry 文件格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry] #每个desktop文件都以这个标签开始，说明这是一个Desktop Entry文件</span><br><span class="line">Version = 1.0 #标明Desktop Entry的版本（可选）</span><br><span class="line">Name = Firefox #程序名称（必须），这里以创建一个Firefox的快捷方式为例</span><br><span class="line">GenericName = Web Browser #程序通用名称（可选）</span><br><span class="line">Comment = A Web Browser #程序描述（可选）</span><br><span class="line">Exec = firefox %u #程序的启动命令（必选），可以带参数运行,当下面的Type为Application，此项有效</span><br><span class="line">Icon = firefox #设置快捷方式的图标（可选）</span><br><span class="line">Terminal = false #是否在终端中运行（可选），当Type为Application，此项有效</span><br><span class="line">Type = Application #desktop的类型（必选），常见值有“Application”和“Link”</span><br><span class="line">Categories = GNOME;Application;Network; #注明在菜单栏中显示的类别（可选）</span><br></pre></td></tr></table></figure><p>以我个人的配置作为示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name = STM32CubeMX</span><br><span class="line">Version = 5.1.0</span><br><span class="line">GenericName = STM32CubeMX</span><br><span class="line">Exec = /usr/local/STM32CubeMX/STM32CubeMX</span><br><span class="line">Icon = /usr/local/STM32CubeMX/help/STM32CubeMX.ico</span><br><span class="line">Path = /usr/local/STM32CubeMX</span><br><span class="line">Terminal = false </span><br><span class="line">Type = Application </span><br><span class="line">Categories = Development</span><br></pre></td></tr></table></figure><p>创建完这个文件就可以在启动器中看见这个软件了，右键即可添加到桌面</p><h1 id="事后感言">事后感言</h1><p>deepin团队修改完善了内核的一些方面，也开发了一些优秀的软件包方便使用deepin，基本的软件如QQ 微信 chrome都已经预装，开箱即用很方便</p><p><strong>双屏体验</strong>在deepin上得到了优化，不仅仅只是可以设置外接显示屏为主显示器，而且可以将外接显示器与自带显示器位置互换，并在重启后自定义位置不会重置，还可以将这个设置保存为一个自定义选项，方便从双屏与单屏之间的切换。截屏的功能在双屏下可以正常使用，不过录屏的功能无法录制扩展屏，暂时还不清楚是什么原因</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/deepin/launcher.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>deepin-wine</strong>无法安装LOL。<strong>steam</strong>下的porton效果也不是太好，目前发现无法运行PUBG，主要是无法启动battleye服务</p><p>安装应用不要使用root权限，可以通过修改文件夹所有用户组安装，具体步骤下次说</p><p>希望这个系统的新鲜感保质期能久一点</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前体验了&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0OTAyODAzMg==&amp;amp;mid=100000323&amp;amp;idx=1&amp;amp;sn=7d889a7a8488e70c2ba32a97c7054672&amp;amp;chksm=7bb76bec4cc0e2faeead09d5423fa334110b882d54dd104e790d2691d2d95f5ed0e6cd714d22#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu18.04&lt;/a&gt;，在使用了几个月后，还是放弃了&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://greedyhao.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何移植RT-Thread的BSP</title>
    <link href="http://greedyhao.cc/2018/12/12/%E5%B7%A5%E4%BD%9C-rt-thread-2018-12-12-%E5%A6%82%E4%BD%95%E7%A7%BB%E6%A4%8DRT-Thread%E7%9A%84BSP/"/>
    <id>http://greedyhao.cc/2018/12/12/工作-rt-thread-2018-12-12-如何移植RT-Thread的BSP/</id>
    <published>2018-12-12T09:00:02.000Z</published>
    <updated>2018-12-12T09:07:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近RT-Thread重构了stm32的BSP，看了一下，感觉很思路很清晰</p><a id="more"></a><table><thead><tr class="header"><th style="text-align: left;">目录</th><th style="text-align: left;">简介</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">bsp32</td><td style="text-align: left;">重构BSP的介绍文档</td></tr><tr class="even"><td style="text-align: left;">bsp32</td><td style="text-align: left;">各系列的stm32的HAL库</td></tr><tr class="odd"><td style="text-align: left;">bsp32_Drivers</td><td style="text-align: left;">基于HAL库的设备驱动</td></tr><tr class="even"><td style="text-align: left;">bsp32_Drivers</td><td style="text-align: left;">外设驱动的配置文件</td></tr><tr class="odd"><td style="text-align: left;">bsp32_Drivers_flash</td><td style="text-align: left;">flash的配置文件</td></tr><tr class="even"><td style="text-align: left;">bsp32</td><td style="text-align: left;">移植BSP的模板</td></tr><tr class="odd"><td style="text-align: left;">bsp3232fxxx-xxx-xxx</td><td style="text-align: left;">各开发板的适配工程</td></tr></tbody></table><p>我觉得这就是我想要的，于是就开始移植重构后的BSP</p><h1 id="移植流程">移植流程</h1><ul><li>复制一个与自己开发板系列相近的BSP</li><li>修改Scons脚本文件</li><li>修改驱动文件</li><li>规范BSP</li></ul><h1 id="复制一个与自己开发板系列相近的bsp">复制一个与自己开发板系列相近的BSP</h1><p>先找一个和自己开发板MCU类似的BSP，例如我的开发板的MCU是stm32f767，所以我复制了这个目录下的工程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger</span><br></pre></td></tr></table></figure><p>修改名字为你的开发板名字，例如我的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f767-fire-challenger</span><br></pre></td></tr></table></figure><p>然后，在libraries目录下加入你使用的MCU系列的HAL库文件，比如我的f7系列就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\STM32F7xx_HAL</span><br></pre></td></tr></table></figure><p>HAL库文件可以从<a href="https://www.st.com/zh/development-tools/stm32cubemx.html" target="_blank" rel="noopener">STM32CubeFx</a>中解压得到</p><p>然后参照着已经有的HAL库文件夹的情况，将一些使用不到的文件删除，特别是以下文件需要删除，否则会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\STM32F7xx_HAL\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_msp_template.c</span><br><span class="line">bsp\stm32\libraries\STM32F7xx_HAL\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_timebase_rtc_alarm_template.c</span><br><span class="line">bsp\stm32\libraries\STM32F7xx_HAL\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_timebase_rtc_wakeup_template.c</span><br><span class="line">bsp\stm32\libraries\STM32F7xx_HAL\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_timebase_tim_template.c</span><br></pre></td></tr></table></figure><p><strong>在移植完成后</strong>，将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f767-fire-challenger</span><br></pre></td></tr></table></figure><p>复制到下面这个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates</span><br></pre></td></tr></table></figure><p>将名字更改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f7xx</span><br></pre></td></tr></table></figure><h1 id="修改scons脚本文件">修改Scons脚本文件</h1><p>需要修改的脚本文件有点多，不过不急，慢慢来</p><p>可以从<a href="https://github.com/RT-Thread/rt-thread/pull/2058/files" target="_blank" rel="noopener">我提交的pr</a>中看到我修改过的脚本文件，我将他们全部列出来，免得有人遗漏了需要修改的地方</p><ul><li>bsp/stm32/libraries/HAL_Drivers/SConscript</li><li>bsp/stm32/libraries/HAL_Drivers/drv_config.h</li><li>bsp/stm32/libraries/Kconfig</li><li>bsp/stm32/libraries/STM32F7xx_HAL/SConscript</li><li>bsp/stm32/stm32f767-fire-challenger/Kconfig</li><li>bsp/stm32/stm32f767-fire-challenger/SConscript</li><li>bsp/stm32/stm32f767-fire-challenger/SConstruct</li><li>bsp/stm32/stm32f767-fire-challenger/applications/SConscript</li><li>bsp/stm32/stm32f767-fire-challenger/board/Kconfig</li><li>bsp/stm32/stm32f767-fire-challenger/board/SConscript</li><li>bsp/stm32/stm32f767-fire-challenger/rtconfig.py</li><li>bsp/stm32/libraries/templates/stm32f7xx/Kconfig</li><li>bsp/stm32/libraries/templates/stm32f7xx/SConscript</li><li>bsp/stm32/libraries/templates/stm32f7xx/SConstruct</li><li>bsp/stm32/libraries/templates/stm32f7xx/applications/SConscript</li><li>bsp/stm32/libraries/templates/stm32f7xx/board/Kconfig</li><li>bsp/stm32/libraries/templates/stm32f7xx/board/SConscript</li><li>bsp/stm32/libraries/templates/stm32f7xx/rtconfig.py</li></ul><p>看着脚本文件很多，其实也不是太麻烦，只要参考已有的模板，该起来很容易的，那么接下来一个个来讲解吧</p><h2 id="bspstm32librarieshal_driverssconscript">bsp/stm32/libraries/HAL_Drivers/SConscript</h2><p>需要在这个文件中加入你的soc系列，按顺序排好，如图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librarieshal_driversdrv_config.h">bsp/stm32/libraries/HAL_Drivers/drv_config.h</h2><p>同上，加入你的soc系列</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librarieskconfig">bsp/stm32/libraries/Kconfig</h2><p>同上，加入你的soc系列</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librariesstm32f7xx_halsconscript">bsp/stm32/libraries/STM32F7xx_HAL/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\STM32F4xx_HAL\SConscript</span><br></pre></td></tr></table></figure><p>然后修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32stm32f767-fire-challengerkconfig">bsp/stm32/stm32f767-fire-challenger/Kconfig</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\Kconfig</span><br></pre></td></tr></table></figure><h2 id="bspstm32stm32f767-fire-challengersconscript">bsp/stm32/stm32f767-fire-challenger/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\SConscript</span><br></pre></td></tr></table></figure><h2 id="bspstm32stm32f767-fire-challengersconstruct">bsp/stm32/stm32f767-fire-challenger/SConstruct</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\SConstruct</span><br></pre></td></tr></table></figure><h2 id="bspstm32stm32f767-fire-challengerapplicationssconscript">bsp/stm32/stm32f767-fire-challenger/applications/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\applications\SConscript</span><br></pre></td></tr></table></figure><h2 id="bspstm32stm32f767-fire-challengerboardkconfig">bsp/stm32/stm32f767-fire-challenger/board/Kconfig</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\board\Kconfig</span><br></pre></td></tr></table></figure><p>不过需要修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32stm32f767-fire-challengerboardsconscript">bsp/stm32/stm32f767-fire-challenger/board/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\board\SConscript</span><br></pre></td></tr></table></figure><p>不过需要修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32stm32f767-fire-challengerrtconfig.py">bsp/stm32/stm32f767-fire-challenger/rtconfig.py</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32f7-disco\rtconfig.py</span><br></pre></td></tr></table></figure><p>我是从旧版BSP中找的，你也可以找找你对应型号的旧版BSP中的这个脚本</p><h2 id="之后这个templates中的脚本修改内容和前面基本一样的">之后这个<strong>templates</strong>中的脚本修改内容和前面基本一样的</h2><h2 id="bspstm32librariestemplatesstm32f7xxkconfig">bsp/stm32/libraries/templates/stm32f7xx/Kconfig</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\Kconfig</span><br></pre></td></tr></table></figure><h2 id="bspstm32librariestemplatesstm32f7xxsconscript">bsp/stm32/libraries/templates/stm32f7xx/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\SConscript</span><br></pre></td></tr></table></figure><h2 id="bspstm32librariestemplatesstm32f7xxsconstruct">bsp/stm32/libraries/templates/stm32f7xx/SConstruct</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\SConstruct</span><br></pre></td></tr></table></figure><h2 id="bspstm32librariestemplatesstm32f7xxapplicationssconscript">bsp/stm32/libraries/templates/stm32f7xx/applications/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\applications\SConscript</span><br></pre></td></tr></table></figure><h2 id="bspstm32librariestemplatesstm32f7xxboardkconfig">bsp/stm32/libraries/templates/stm32f7xx/board/Kconfig</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\board\Kconfig</span><br></pre></td></tr></table></figure><p>不过需要修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librariestemplatesstm32f7xxboardsconscript">bsp/stm32/libraries/templates/stm32f7xx/board/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\board\SConscript</span><br></pre></td></tr></table></figure><p>不过需要修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librariestemplatesstm32f7xxrtconfig.py">bsp/stm32/libraries/templates/stm32f7xx/rtconfig.py</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32f7-disco\rtconfig.py</span><br></pre></td></tr></table></figure><h1 id="修改驱动文件">修改驱动文件</h1><p>驱动文件分为：<strong>实现</strong>和<strong>配置</strong></p><p>实现是下面这个目录下的.c文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\HAL_Drivers</span><br></pre></td></tr></table></figure><p>配置是以下目录下的.h和部分.c文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\HAL_Drivers\config\fx</span><br><span class="line">bsp\stm32\libraries\HAL_Drivers\drv_flash</span><br><span class="line">bsp\stm32\stm32f767-fire-challenger\board\ports</span><br></pre></td></tr></table></figure><p>我们需要做的事就是根据开发板实际情况进行修改</p><h2 id="下面以移植uart为例子">下面以移植uart为例子</h2><p>先确认config文件是否符合开发板实际情况，同一个系列的MCU的移植不需要修改config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\HAL_Drivers\config\f7\uart_config.h</span><br></pre></td></tr></table></figure><p>根据HAL库的情况修改以下文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\HAL_Drivers\drv_usart.c</span><br></pre></td></tr></table></figure></p><p>例如f7系列，参照stm32f7xx_hal_uart.h，看看什么drv_usart.c中使用到的API是stm32f7xx_hal_uart.h中没有的，改为stm32f7xx_hal_uart.h有的接口，可以参考下面的方式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>还要注意一些寄存器是某些系列的产品特有的，要用宏定义区分，例如</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>其他需要修改的地方都是差不多的，可以参考一下我的修改</p><p>在移植完驱动后，需要使用Cubemx启动外设，这部分请参考<a href="https://github.com/RT-Thread/rt-thread/blob/master/bsp/stm32/docs/BSP%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md#%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%89%87%E4%B8%8A%E8%B5%84%E6%BA%90%E9%80%89%E9%A1%B9" target="_blank" rel="noopener">如何添加更多的片上资源选项</a></p><p>不过串口1默认是开启的</p><h1 id="规范bsp">规范BSP</h1><p>这部分请参考<a href="https://github.com/RT-Thread/rt-thread/blob/master/bsp/stm32/docs/STM32%E7%B3%BB%E5%88%97BSP%E5%88%B6%E4%BD%9C%E8%A7%84%E8%8C%83.md" target="_blank" rel="noopener">STM32 系列 BSP 制作规范</a></p><p>移植到此结束，欢迎尝试</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近RT-Thread重构了stm32的BSP，看了一下，感觉很思路很清晰&lt;/p&gt;
    
    </summary>
    
    
      <category term="rt-thread" scheme="http://greedyhao.cc/tags/rt-thread/"/>
    
      <category term="stm32" scheme="http://greedyhao.cc/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>通信原理角度调制</title>
    <link href="http://greedyhao.cc/2018/12/08/%E5%B7%A5%E4%BD%9C-wireless-2018-12-08-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E8%A7%92%E5%BA%A6%E8%B0%83%E5%88%B6/"/>
    <id>http://greedyhao.cc/2018/12/08/工作-wireless-2018-12-08-通信原理角度调制/</id>
    <published>2018-12-08T15:32:39.000Z</published>
    <updated>2018-12-08T15:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="角度调制的两种方法">角度调制的两种方法</h1><a id="more"></a><p>一般表达式为</p><p><span class="math display">\[s(t)=A_c\cos[2\pi f_c t+\theta(t)]  \tag{1}\]</span></p><h2 id="fm与pm的表达式">FM与PM的表达式</h2><p>PM: 消息直接放在相位上</p><p><span class="math display">\[\begin{aligned}\theta(t) &amp;= K_p m(t) \\s_{PM}(t) &amp;= A_c\cos\left[2\pi f_c t + k_{PM} m(t)\right] \end{aligned} \tag{2}\]</span></p><p>FM: 消息直接放在角频率上</p><p><span class="math display">\[\begin{aligned}\frac{d\theta(t)}{dt} &amp;= K_f m(t)  \\\theta(t) &amp;= K_f\int m(t)dt  \\s_{FM}(t) &amp;= A_c\cos\left[2\pi f_c t + 2\pi k_{FM}\int m(t)dt\right]\end{aligned} \tag{3}\]</span></p><h2 id="fm与pm之间的联系">FM与PM之间的联系</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看出来，PM和FM是存在某种联系的，他们是相对的、关联的。</p><p>这是由于频率与相位之间存在微分与积分的关系，FM和PM之间是可以互相转换的。</p><ul><li>消息信号经过积分器再进入PM调制器可以得到FM信号</li><li>消息信号经过微分器再进入FM调制器可以得到PM信号</li></ul><h2 id="角度调制的优势">角度调制的优势</h2><p>他是恒幅波，不怕非线性失真，这解决了大功率放大器的非线性失真问题</p><h1 id="角度调制的基本参数">角度调制的基本参数</h1><h2 id="调制程度">调制程度</h2><p><strong>最大相偏</strong></p><p>联合(1)(2)(3)式，我们可以得到最大相偏<span class="math inline">\(\Delta \theta_{max}\)</span></p><p><span class="math display">\[\begin{aligned}&amp;PM:\ \ k_{PM}|m(t)|_{max} \\&amp;FM:\ \ 2\pi k_{FM}\left| \int m(t)dt\right|_{max}\end{aligned}\]</span></p><p><strong>最大频偏</strong></p><p>根据(3)式可以知道频率与相位之间存在微分积分的关系，因此我们可以得到角度调制的频率变化函数</p><p><span class="math display">\[PM:\ \ f_i (t) = f_c + \frac{1}{2\pi} \frac{d}{dt} \theta(t) \\FM:\ \ f_i (t) = f_c + k_{FM} m(t)\]</span></p><p>因此可以得到最大频偏<span class="math inline">\(\Delta f_{max}\)</span></p><p><span class="math display">\[\begin{aligned}&amp;PM:\ \ \frac{1}{2\pi} k_{PM}|m\prime (t)|_{max} \\&amp;FM:\ \ k_{FM}\left| m(t)dt\right|_{max}\end{aligned}\]</span></p><p>从上面的分析中，我们可以发现最大频偏/相偏正比于调制系数与消息信号的最大幅度</p><h2 id="正弦消息特例与调制指数">正弦消息特例与调制指数</h2><p>令消息信号m(t)如下</p><p><span class="math display">\[m(t) = a\cos(2\pi f_m t)\]</span></p><p>角度调制公式则如下</p><p><span class="math display">\[PM:\ \  s_{PM}(t) =  A_c\cos\left[2\pi f_c t +\beta \cos(2\pi f_m t) \right] \\\theta_{max} = k_{PM}a \\ \Delta f_{max} = f_m k_{PM}a  \\ \beta_{PM} = \Delta \theta_{max} \\FM:\ \  s_{FM}(t) = A_c\cos\left[2\pi f_c t + \beta \sin(2\pi f_m t) \right] \\\Delta f_{max} = k_{FM}a  \\ \beta_{FM} = \frac{\Delta f_{max}}{f_m} \\\]</span></p><p>调制指数是角度调制的基本参数之一，所以很重要，对于一般信号的定义如下</p><p><span class="math display">\[\beta = \frac{\Delta f_{max}}{B}\]</span></p><p>式中B为消息信号的带宽</p><h2 id="角度调制的信号带宽">角度调制的信号带宽</h2><h2 id="信号带宽">信号带宽</h2><p>角度调制信号的频谱无法用公式表示，不过他的带宽可以使用Carson公式计算得到，这个公式是通过对角度调制信号傅里叶系数分解得到的</p><p><span class="math display">\[B_T = 2\Delta f_{max} + 2B = 2(D+1)B\\D = \frac{\Delta f_{max}}{B}\]</span></p><p>式中的D为频偏比，也就是调制指数</p><h2 id="频谱特点">频谱特点</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从单音调频信号的频谱也再次验证了角度调制是非线性调制。而且也看得出FM调制会占用很宽的频带，但也正是因此，FM信号抗干扰、高质量。</p><p>实际生活中 + 宽带调频应用广泛 + 窄带调频应用较少</p><h1 id="角度调制的产生与接收">角度调制的产生与接收</h1><p>简单的说，角度调制就是将信号幅度上的变化转变为频率相位上的变化</p><h2 id="直接调频">直接调频</h2><p>直接调频是通过前文提到过的压控振荡器(VCO)实现的，VCO的振荡频率正比于输入控制电压</p><p><span class="math display">\[f_i (t) = f_c + k_{FM} m(t)\]</span></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>VCO可以通过LC振荡器实现，目前常用的电抗元件是变容二极管。但是这种直接调频的方法频率稳定性不好，不过可以通过使用PLL电路优化。因此，在早期的时候，直接调频的方法并不好用，主要使用的是间接调频的方法。</p><h2 id="间接调频">间接调频</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>间接调频使用的是阿姆斯特朗(Armstrong)法，它是先将消息信号积分，然后对载波调相，得到窄带调频(NBFM)信号，经过倍频得到宽带调频(WBFM)信号。上图就是他是系统框图</p><p>下面来解释他的原理</p><p>当<span class="math inline">\(\theta (t)\)</span>远小于1时，<span class="math inline">\(\cos\theta(t)\)</span>接近于1，<span class="math inline">\(\sin\theta(t)\)</span>接近于<span class="math inline">\(\theta(t)\)</span>；因为<span class="math inline">\(\theta(t)\)</span>很小，所以调制指数<span class="math inline">\(\beta=\Delta\theta_{max}\)</span>也就很小，因此这是一个<strong>窄带调频信号</strong>。</p><p>从系统框图我们可以看出，这个信号的产生是将消息信号m(t)通过积分器得到<span class="math inline">\(\theta(t)\)</span>，并将<span class="math inline">\(\theta(t)\)</span>控制得很小，再乘以cos信号反相得到的sin信号，最后再加上这个cos信号就得到了NBFM信号；由于这个NBFM信号不是理想的，所以还存在起伏，通过限幅器减小这种畸变；再经过倍频器和贷带通滤波器，得到WBFM。</p><h2 id="角度调制信号解调">角度调制信号解调</h2><p>解调是用和调制相反的方法，也就是将调制信号的疏密(频率相位)转换为幅度</p><p>先从数学上分析解调过程</p><p><span class="math display">\[s_{FM}(t) = A_c\cos\left[2\pi f_c t + K_f\int m(t)dt\right]\]</span></p><p>将其对t求微分</p><p><span class="math display">\[\frac{d s_{FM}(t)}{dt} = -A_c[2\pi f_c t + K_f m(t)]\sin\left[2\pi f_c t + K_f\int m(t)dt\right]\]</span></p><p>联系在AM中解调的方法，将包络提取出来，再去掉直流信号与高频载波信号，就得到m(t)信号了。</p><p>下面是解调的系统框图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在包络检波时，如果使用单调谐回路存在线性度差、线性范围较小的问题，而且还存在直流分量，虽然可以使用电容隔离直流，但是也有可能对低频信号产生损失；为了改进包络检波的电路，可以使用双调谐互补电路，在线性度好的同时，还没有直流成分的存在。</p><h2 id="篇外话">篇外话</h2><p>无论是发送还是接收，现代流行的技术方案都是采用基带处理与正交调制相结合的方案。</p><p>基带处理可以用DSP FPGA方便灵活实现各种调制方案</p><h1 id="噪声分析">噪声分析</h1><p>无论什么系统，在通过信道传输后总会被噪声干扰，只有了解噪声才能降低噪声的干扰，下面开始对噪声的分析</p><ul><li>如何分析</li><li>解调增益 系统增益</li><li>各种调制方法性能</li></ul><h2 id="噪声分析方法">噪声分析方法</h2><p><strong>基带传输中的噪声</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>一般情况下，噪声都可以简化为高斯白噪声信号</p><p>去除噪声的方法就是使用一个和调制信号带宽相同的理想滤波器滤除噪声，不过调制信号带宽内的噪声无法去除</p><p>我们使用信噪比(SNR)来度量消息的质量</p><p>高斯白噪声是平坦的，通过低通滤波器后还是平坦的，因此噪声信号功率可以通过噪声信号的面积得到</p><p><span class="math display">\[SNR_o = \frac{P_m}{P_{n_o}} = \frac{\overline{m^2(t)}}{N_o B}\]</span></p><p><strong>频带传输中的噪声</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在频带分析中会涉及到调制解调，解调可能会使得消息信号发生变化，所以无法得知调制信号和残留噪声的具体值，因此SNR的分析就不是那么简单了，就需要更细致的分析</p><ul><li>针对具体解调方法分析</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>ENV指包络的意思</p><ul><li>将具体信号带入分析</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="解调增益和系统增益">解调增益和系统增益</h2><p><strong>解调增益</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_10.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这个表中有列举几种调制的解调增益，输入SNR比较容易获得，我们可以通过解调增益和输入SNR求得输出SNR</p><p><strong>系统增益</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_11.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>将基带传输信噪比与频带传输信噪比对比，得到系统增益，通过系统增益衡量频带传输系统的好坏</p><p>通过推导可以得到系统增益与解调增益之间的关系如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_12.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>下面这个表列举了几种调制的系统增益</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_13.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过系统增益可以直接比较不同系统的性能</p><h2 id="各种调制性能比较">各种调制性能比较</h2><p><strong>模拟调制性能指标</strong></p><ul><li>可靠性 输出信号的信噪比</li><li>有效性 占用的带宽</li></ul><p><strong>各种调制系统的性能比较</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_14.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>比较结论</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_15.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="参考资料">参考资料：</h1><ul><li><a href="http://www.icourse163.org/learn/UESTC-238011?tid=1003260003#/learn/content" target="_blank" rel="noopener">通信原理 电子科技大学 中国大学MOOC</a></li><li><a href="http://wzzjzxx.com:8081/Media/2011/05/09/49b31ce5-8019-49cb-8a06-6a7a279f151b/65c0473b-61d1-4ccf-9c93-5bd89de4bb87.doc" target="_blank" rel="noopener">模拟调制系统</a></li><li><a href="http://101.96.10.63/www.eie.polyu.edu.hk/~em/cf03pdf/9%20FM2.pdf" target="_blank" rel="noopener">FM – Generation and Detection</a></li><li><a href="https://www.tutorialspoint.com/analog_communication/analog_communication_fm_modulators.htm" target="_blank" rel="noopener">Analog Communication FM Modulators - Tutorialspoint</a></li><li><a href="https://www.radio-electronics.com/info/rf-technology-design/fm-reception/fm-demodulation-detection-overview.php" target="_blank" rel="noopener">FM Demodulation / Detection Tutorial</a></li><li><a href="http://www.chinabaike.com/t/35816/2014/0623/2536846.html" target="_blank" rel="noopener">微分法鉴频器原理电路知识</a></li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;角度调制的两种方法&quot;&gt;角度调制的两种方法&lt;/h1&gt;
    
    </summary>
    
    
      <category term="wireless" scheme="http://greedyhao.cc/tags/wireless/"/>
    
  </entry>
  
  <entry>
    <title>通信原理线性调制</title>
    <link href="http://greedyhao.cc/2018/11/29/%E5%B7%A5%E4%BD%9C-wireless-2018-11-29-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%BA%BF%E6%80%A7%E8%B0%83%E5%88%B6/"/>
    <id>http://greedyhao.cc/2018/11/29/工作-wireless-2018-11-29-通信原理线性调制/</id>
    <published>2018-11-29T14:41:19.000Z</published>
    <updated>2018-12-08T15:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模拟线性调制">模拟线性调制</h1><a id="more"></a><h2 id="常规调幅-am">常规调幅 AM</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/am_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>AM 调制是一种线性调制，它的作用是将基带信号转变为调制信号。之所以调制的原因在上一篇文章说了，天线的长度要不短于信号的波长的1/10，这是为了阻抗匹配，具体原因在电磁波相关的书籍有介绍。</p><p>从图中不难看出，AM调制是一个很简单的调制方式，简单的只需要一个乘法器和一个加法器就可以完成。</p><p><strong>频谱特点</strong></p><ol type="1"><li>频带信号：位于载频fc，带宽BT = 2B</li><li>上下两个边带</li><li>+-fc处有两个冲激，有纯载波</li></ol><p><strong>波形特点</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/am_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>消息突显在载波包络上</p><p>通过调节消息信号的幅度，可以调节调幅指数，从而调节调制强度。调幅指数的定义如下</p><p><span class="math display">\[\begin {aligned}\beta_{AM} &amp;= \frac{max[s_{AM}(t)]-A_c}{A_c} \\&amp;= max|m(t)|\end {aligned}\]</span></p><p>不过调幅指数不能大于1，否则会发生上图中的过调制情况；过调制会导致承载消息的已调波变形，使得消息错误。</p><p><strong>发送与接收</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/am_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>发送使用的是一个乘法器与一个加法器的组合</p><p>接收端使用的是包络检波器，基本原理是：正弦波上升时，二极管正向导通给电容充电，正弦波下降时二极管截止，电容放电；通过电容的充放电就可以展示出消息信号的波形。</p><p>包络检波器的R C选值需要考虑输入信号的频率和载波的频率</p><p><strong>功率与效率</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/am_4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>功率就是已调信号的平方的平均值</p><p>效率就是消息信号的功率比上总功率。使用正弦信号时，峰均功率比PARPm(t)最低，效率也只有33.3%，由此可以看出AM调制效率的低。</p><h2 id="抑制载波双边带调幅-dsb">抑制载波双边带调幅 DSB</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/dsb_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>DSB调制和AM调制信号很类似，频域上的特性基本相同，不过在fc处没有了冲激，而且DSB调制信号在时域上有一个反向点。</p><p>DSB调制效率为1</p><p><strong>接收方法</strong></p><p>包络没有直接直接呈现消息信号，所以无法使用包络检波器</p><p>可以通过乘以同频同相正弦函数调制回基频</p><p><span class="math display">\[\begin {aligned}&amp;S_{DSB} \times \cos 2\pi f_c t \\&amp;= A_c m(t) \cos^2 2\pi f_c t \\&amp;= A_c m(t) \frac{1+\cos 4\pi f_c t}{2}\end {aligned}\]</span></p><p>分析公式可以知道，乘以一个同频同相正弦信号的结果就是会产生基频信号和4倍基频信号，再同过一个低通滤波器就可以得到我们想要的原信号了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/dsb_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>乘法解调器的示意图如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/dsb_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>同步问题</strong></p><p>前面说了使用乘法解调器需要同频同相的正弦波，但是发射端和接收端一般都有一定的距离，很难保证频率相同。</p><p>为了保证接收端的本振和发射端的震荡频率相同，使用锁相环(PLL)做一个可控振荡器，通过比较接收到的DSB信号的频率来产生相同的频率</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/dsb_4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="单边带调制-ssb">单边带调制 SSB</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>傅里叶变换的性质，信号的共轭等于原信号的频域信号的取反。而实信号的共轭等于它本身，因此可以推导出信号的频域共轭对称</p><p>因此可以去掉DSB调制的一半的带宽，但是自然界中只存在实信号，也就是说+-fc处都要有频带，因此只有两种单边带调制方式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>接收方法</strong></p><p>接收方法可以通过相干解调，解调过程图示如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>SSB调制信号的时域公式比较复杂，先搁置</p><p>SSB调制信号还可以通过增加载波分量的方法，可以实现包络检波</p><h2 id="残留边带调幅-vsb">残留边带调幅 VSB</h2><p>前面讲的SSB是理想情况下的，实现SSB需要非常陡峭的滤波器，这在显示中是不存在的；因此，为了能够实现这个滤波器，就加大了滤波器的过渡带，不过过渡带形状必须要对称互补</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/vsb_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="相移法生成单边带">相移法生成单边带</h2><p>前文讲的SSB VSB都是在频域进行滤波生成的单边带，接下来讲一个在现代使用的更多的相移法，尤其是在生成高频率的单边带时。</p><p>相移法是在时域处理的，所以需要在时域讨论SSB</p><p>目前我们知道的是，DSB的时域表达式</p><p>设调制信号为</p><p><span class="math display">\[m(t) = A_m\cos\omega_m t\]</span></p><p>载波为</p><p><span class="math display">\[c(t) = \cos\omega_c t\]</span></p><p>则DSB表达式为</p><p><span class="math display">\[\begin {aligned}s_{DSB}(t) &amp;= A_m \cos\omega_m t\cos\omega_c t \\&amp;= \frac{1}{2} A_m \cos (\omega_c+\omega_m)t + \frac{1}{2} A_m \cos (\omega_c-\omega_m)t\end {aligned}\]</span></p><p>保留上边带则有</p><p><span class="math display">\[\begin {aligned}s_{USB}(t) &amp;= \frac{1}{2} A_m \cos (\omega_c+\omega_m)t \\&amp;= \frac{1}{2}A_m \cos\omega_m t\cos\omega_c t-\frac{1}{2}A_m \sin\omega_m t\sin\omega_c t\end {aligned}\]</span></p><p>保留下边带则有</p><p><span class="math display">\[\begin {aligned}s_{LSB}(t) &amp;= \frac{1}{2} A_m \cos (\omega_c-\omega_m)t \\&amp;= \frac{1}{2}A_m \cos\omega_m t\cos\omega_c t+\frac{1}{2}A_m \sin\omega_m t\sin\omega_c t\end {aligned}\]</span></p><p>综合起来</p><p><span class="math display">\[\begin {aligned}s_{SSB}(t) &amp;= \frac{1}{2}m(t)\cos\omega_c t-\frac{1}{2}\hat{m}(t)\sin\omega_c t\end {aligned}\]</span></p><p>式中<span class="math inline">\(\hat{m}(t)\)</span>为希尔伯特变换，相当于正弦信号相移pi/2</p><p>为了验证SSB时域表达式的正确性，我们可以从频域进行分析</p><p><span class="math display">\[\begin {aligned}S_{SSB}(f) &amp;= \frac{M(f-f_c)+M(f+f_c)}{2} - \frac{-j\hat{M}(f-f_c)-j\hat{M}(f+f_c)}{2}\end {aligned}\]</span></p><p>希尔伯特变换的相关信息如下</p><p><span class="math display">\[\begin {aligned}&amp;\hat{m}(t) = m(t)*\frac{1}{\pi t} \\&amp;\hat{M}(f) = M(f)x[-j sgn(f)]\\&amp;j\hat{M}(f) = -j^2 M(f)sgn(f)\\\end {aligned}\]</span></p><p>在频域中，做希尔伯特变换相当于乘以了一个符号函数，SSB过程图示如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>接下来就是根据时域表达式实现相移法</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模拟线性调制&quot;&gt;模拟线性调制&lt;/h1&gt;
    
    </summary>
    
    
      <category term="wireless" scheme="http://greedyhao.cc/tags/wireless/"/>
    
  </entry>
  
</feed>
