<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhuhao&#39;s Blog</title>
  
  <subtitle>I am the captain of my ship and the master of my fate.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://greedyhao.cc/"/>
  <updated>2019-03-27T07:15:05.299Z</updated>
  <id>http://greedyhao.cc/</id>
  
  <author>
    <name>Greedyhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pid对微分器的优化</title>
    <link href="http://greedyhao.cc/2019/03/26/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-03-26-pid%E5%AF%B9%E5%BE%AE%E5%88%86%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://greedyhao.cc/2019/03/26/自动控制-PID-2019-03-26-pid对微分器的优化/</id>
    <published>2019-03-26T15:19:40.000Z</published>
    <updated>2019-03-27T07:15:05.299Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://greedyhao.cc/2019/03/25/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-03-25-pid%E6%8A%97%E9%A5%B1%E5%92%8C%E7%A7%AF%E5%88%86/">上一篇</a>文章写了对积分器的优化，这一篇写对微分器的优化</p><a id="more"></a><h1 id="为什么要优化微分器">为什么要优化微分器</h1><p>微分器对于噪声很敏感，我们可以从微分器的laplace传递函数G(s)=s看出来</p><p>通过简单的求导也可以看得出</p><p>假设噪声n(t)是一个正弦函数</p><p><span class="math display">\[n(t) = A\sin(\omega_a t+ \phi_a) \]</span></p><p><span class="math display">\[\frac{dn(t)}{dt} = A\omega_a \sin(\omega_a t+ \phi_a + \frac{\pi}{2})\]</span></p><p>Aω就是经过微分得到的幅度，可以看出，频率越高，对控制信号的影响就越大</p><h1 id="关于噪声">关于噪声</h1><p>现实中，一般情况下无法避免噪声的存在</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_9_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在pid系统中，一般通过传感器来将设备的信息采集出来，通过反馈回路送回pid系统入口处</p><p>但是采集信息的时候会不可避免的被噪声干扰，有热噪声、散射噪声等，这些噪声的存在会干扰pid系统的稳定性</p><h1 id="如何优化微分器">如何优化微分器</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_9_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>很多噪声在整个频域内均匀分布，但是我们的信号却大部分都是低频信号</p><p>为了优化我们得到的信号，一个简单有效的方法就是使用低通滤波器</p><p>通过设置一个合适的截止频率，滤除掉大部分的噪声</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://greedyhao.cc/2019/03/25/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-03-25-pid%E6%8A%97%E9%A5%B1%E5%92%8C%E7%A7%AF%E5%88%86/&quot;&gt;上一篇&lt;/a&gt;文章写了对积分器的优化，这一篇写对微分器的优化&lt;/p&gt;
    
    </summary>
    
      <category term="自动控制" scheme="http://greedyhao.cc/categories/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="PID" scheme="http://greedyhao.cc/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>pid抗饱和积分</title>
    <link href="http://greedyhao.cc/2019/03/25/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-03-25-pid%E6%8A%97%E9%A5%B1%E5%92%8C%E7%A7%AF%E5%88%86/"/>
    <id>http://greedyhao.cc/2019/03/25/自动控制-PID-2019-03-25-pid抗饱和积分/</id>
    <published>2019-03-25T00:47:18.000Z</published>
    <updated>2019-03-25T01:25:01.095Z</updated>
    
    <content type="html"><![CDATA[<p>上文介绍了PID在理想情况下的工作原理，接下来是对实际中使用积分器的展开</p><a id="more"></a><h1 id="积分器的饱和情况">积分器的饱和情况</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>(actuator:机器的一部分)</p><p>我们知道常量的误差值在经过积分器的作用会成为一个递增的函数，也就是说，给设备的指令(command)的转速会不断增加。</p><p>但是我们知道，现实中的电机转速是有限的，在设备指令增加到一定的转速时，电机的转速就不会上升了，这种情况叫做<strong>饱和</strong></p><h1 id="还是以无人机为例">还是以无人机为例</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>还是像之前一样，有一个无人机，目标是悬停在50m处的空中</p><p>但是我们在一开始的时候先<strong>固定</strong>住无人机</p><p>由于被固定住，高度误差不会减小，从而电机指令会不断增加，从而电机转速不断上升，但增加到1000rpm时，达到电机转速的极限，电机转速不再增加</p><p>但是电机指令由于<strong>没有收到高度误差减小</strong>的反馈，依然会不断增加</p><p>直到放开无人机时，电机指令开始减小，减小到1000rpm时，电机转速开始减小，但是高度误差早已经为负，意思就是无人机已经超过50m的高度，飞向自由了</p><h1 id="如何抗饱和积分">如何抗饱和积分</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>有三种方法抗饱和积分 + <strong>clamping</strong>(钳位):根据条件关闭积分器 + <strong>back-calculation</strong>(反算) + <strong>observer opproach</strong>(跟踪模式)</p><p>一般比较常用的是钳位的方法，也称条件积分，因为简单、方便，下面介绍的也是钳位的配置</p><p>我们现在不让设备指令直接给设备了，而是在设备前加一个限定，也就是<strong>钳位饱和限定</strong>，通过判定限定前和限定后的值，判断控制器是否饱和</p><p>对于钳位的情况可以描述如下：</p><ol type="1"><li>积分器的值会被限定在一个指定的值</li><li>积分器的值会在系统误差过大的时候停止，即|e|&gt;e，e为指定的值</li><li>当控制器饱和的时候，积分器的值会停止增大，即，当u≠us时</li><li>当控制器饱和并且系统误差和操作变量符号相同，即，当u≠us且e*u&gt;0时</li></ol><h1 id="参考资料">参考资料</h1><p>公众号内回复 下载|PID资料 获得</p><ul><li>Visioli, A., &quot;Modified Anti-Windup Scheme for PID Controllers,&quot; IEE Proceedings - Control Theory and Applications, Vol. 150, Number 1, January 2003</li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上文介绍了PID在理想情况下的工作原理，接下来是对实际中使用积分器的展开&lt;/p&gt;
    
    </summary>
    
      <category term="自动控制" scheme="http://greedyhao.cc/categories/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="PID" scheme="http://greedyhao.cc/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>pid是什么</title>
    <link href="http://greedyhao.cc/2019/03/24/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-03-24-pid%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://greedyhao.cc/2019/03/24/自动控制-PID-2019-03-24-pid是什么/</id>
    <published>2019-03-24T03:28:26.000Z</published>
    <updated>2019-03-24T04:16:38.344Z</updated>
    
    <content type="html"><![CDATA[<p>本人想做做之前的电赛题--滚球平衡，但这涉及到了一些自动控制的东西，比如PID。</p><p>对PID之前只是略有耳闻，为了复现滚球平衡，只能来现学PID了。</p><a id="more"></a><blockquote><p>本系列内容是看了MATLAB的教学视频后写的，<a href="https://zhuanlan.zhihu.com/p/59928003" target="_blank" rel="noopener">视频链接在此</a></p></blockquote><p>PID的公式在此</p><p><span class="math display">\[u(t) = K_p e(t) + K_i \int^t_0 e(\tau) d\tau + K_d \frac{de(t)}{dt}\]</span></p><p>看着是不是觉得挺复杂，不过放心，让我们先抛弃公式，从PID是什么以及为什么要有PID开始讲起</p><p><img src="/img/auto_control/pid/pid_1.png"></p><p>这里有这么一个我们需要控制的设备，我们需要使用<strong>驱动信号(actuating signal)</strong>取控制它，同时，我们可以获得设备的当前信息，也就是<strong>受控变量(controlled variable)</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个驱动信号由一个控制器产生，控制器的作用是使得系统的error为0，error则是控制变量减去受控变量的值。<strong>控制变量(commanded variable)</strong>是我们对这个系统的需求，比如将烙铁加热到xx度；<strong>受控变量</strong>是从设备获得的信息，比如当前烙铁xx度。</p><p>接下来就将这个PID模型具象化，以球场上一个人走向半场的过程为例</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如图所示，假设这个人离半场的距离有50m，那么控制变量为50m，设定控制器的值为0.1，那么初始速度为5m/s，人接收到速度的指令后行走，反馈回路将当前位置返回累计器，从而调整走路速度，随着人离中场越近，人的速度越慢，直到走到中场，速度为0</p><p>右下角的两张图分别是<strong>路程/时间</strong>、<strong>走路速度/时间</strong>的关系图，体现了控制器不同的值时的区别</p><p>看起来似乎一个比例就可以解决控制器的问题了，那还要积分和微分器干嘛，下面换一个无人机的例子来说明</p><p>如的图所示，有这么个无人机，想悬停在50m的空中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_4_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>无人机无法像上面人走路一样简单的比例就可以完成了，因为无人机会因为重力的作用下坠，如果到了50m的空中电机就定制转动，无人机会直接下坠</p><p>我们假定无人机的悬停需要100rpm的电机速度</p><p>通过增加增益，无人机电机转速会增加，然后上升，反馈使得误差减小，转速降低，降到100rpm时保持悬浮。只有继续增大增益，无人机才会继续上升</p><p>但是无论增益怎么增加，都没办法悬浮在50m处，如图中表格所示，最终会有误差无法消除，管这种误差叫做<strong>稳态误差(steady state error)</strong></p><p>为了消除这种<strong>稳态误差</strong>，可以请积分器出场了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_4_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如图所示，一个常数值经过积分器后得到一个增大的函数，会使得转速增加，从而使得无人机上升减小误差</p><p>当误差为0时，只有积分器的输出100rpm，而比例输出为0</p><p>但是现实中并不是这么理想的，当误差E比较小的时候积分器的输出会大于100rpm，而比例的输出大于0，会使得总输出大于100rpm，会使得无人机突然超越50m的高度。这种情况叫做<strong>超调</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_5_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为了减小这种<strong>超调</strong>的问题，就需要使用微分器了</p><p>对函数的求导可以得到它的斜率。误差函数由于是下降的趋势，微分得到的斜率是小于0的，并且随着下降的速度增大，误差函数斜率的绝对值也增大，这个负值的斜率输出到电机时会减慢电机的速度，这样就可以减小超调量</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_5_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>比例、微分、积分组合起来就是我们常说的PID控制器了，通过调整Kp Ki Kd权重因子，还可以只使用PI PD P等等</p><p>下一篇会讲到积分器的保护或者说抗饱和积分问题</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人想做做之前的电赛题--滚球平衡，但这涉及到了一些自动控制的东西，比如PID。&lt;/p&gt;
&lt;p&gt;对PID之前只是略有耳闻，为了复现滚球平衡，只能来现学PID了。&lt;/p&gt;
    
    </summary>
    
      <category term="自动控制" scheme="http://greedyhao.cc/categories/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="PID" scheme="http://greedyhao.cc/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>uboot链接脚本分析</title>
    <link href="http://greedyhao.cc/2019/03/16/%E5%B7%A5%E4%BD%9C-x210-2019-03-16-uboot%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>http://greedyhao.cc/2019/03/16/工作-x210-2019-03-16-uboot链接脚本分析/</id>
    <published>2019-03-16T13:22:28.000Z</published>
    <updated>2019-03-16T13:27:40.683Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇uboot主编译脚本分析的<a href="http://greedyhao.cc/2019/03/15/uboot%E4%B8%BB%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0">编译选项参数</a>中提到了链接脚本这么个东西</p><p>我也是写到这里才开始了解链接脚本(Linker command scripts)，之前只是大概知道有这么一个东西</p><a id="more"></a><p>先从参考资料中的内容开始说起，充当预备知识</p><blockquote><p>总的来说，脚本定义了四个内存空间(memory regions)为vect、rom、ram and cache，五个段(output sections)为vect、text、bss、init、stack</p></blockquote><h1 id="从参考资料中的范例入手">从参考资料中的范例入手</h1><p>下面是范例中提供的一个简单的链接脚本，简单而健全，先完整的贴上来，然后结合uboot的链接脚本慢慢介绍其中涉及到的OUTPUT_FORMAT、MEMORY等命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/* 要链接的文件列表</span><br><span class="line">(其他的可以在命令行上提供) */</span><br><span class="line">INPUT(libc.a libg.a libgcc.a libc.a libgcc.a)</span><br><span class="line"></span><br><span class="line">/* 输出格式</span><br><span class="line">(可以在命令行上被重写) */</span><br><span class="line">OUTPUT_FORMAT(&quot;coff-sh&quot;)</span><br><span class="line"></span><br><span class="line">/* 输出文件名</span><br><span class="line">(可以在命令行上被重写) */</span><br><span class="line">OUTPUT_FILENAME(&quot;main.out&quot;)</span><br><span class="line"></span><br><span class="line">/* 我们的程序的入口点;</span><br><span class="line">除了确保S7记录是正确的外，没有什么用处，</span><br><span class="line">因为复位向量(reset vector)实际上</span><br><span class="line">定义了大多数嵌入式系统中的“入口点” */</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">/* 内存段的列表 */</span><br><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">    vect : o = 0, l = 1k</span><br><span class="line">    rom : o = 0x400, l = 127k</span><br><span class="line">    ram : o = 0x400000, l = 128k</span><br><span class="line">    cache : o = 0xfffff000, l = 4k</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 组织每个模块中的内存段的方式 */</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    /* 中断向量表 */</span><br><span class="line">    .vect :</span><br><span class="line">    &#123;</span><br><span class="line">        __vect_start = .;</span><br><span class="line">        *(.vect);</span><br><span class="line">        __vect_end = .;</span><br><span class="line">    &#125; &gt; vect</span><br><span class="line"></span><br><span class="line">    /* 代码和常量 */</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        __text_start = .;</span><br><span class="line">        *(.text)</span><br><span class="line">        *(.strings)</span><br><span class="line">        __text_end = .;</span><br><span class="line">    &#125; &gt; rom</span><br><span class="line"></span><br><span class="line">    /* 未初始化的数据 */</span><br><span class="line">    .bss :</span><br><span class="line">    &#123;</span><br><span class="line">        __bss_start = . ;</span><br><span class="line">        *(.bss)</span><br><span class="line">        *(COMMON)</span><br><span class="line">        __bss_end = . ;</span><br><span class="line">    &#125; &gt; ram</span><br><span class="line"></span><br><span class="line">    /* 已初始化的数据 */</span><br><span class="line">    .init : AT (__text_end)</span><br><span class="line">    &#123;</span><br><span class="line">        __data_start = .;</span><br><span class="line">        *(.data)</span><br><span class="line">        __data_end = .;</span><br><span class="line">    &#125; &gt; ram</span><br><span class="line"></span><br><span class="line">    /* 应用程序栈 */</span><br><span class="line">    .stack :</span><br><span class="line">    &#123;</span><br><span class="line">        __stack_start = .;</span><br><span class="line">        *(.stack)</span><br><span class="line">        __stack_end = .;</span><br><span class="line">    &#125; &gt; ram</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="output_format命令">OUTPUT_FORMAT命令</h2><p>这条命令控制输出文件的的格式。</p><p>在x210的uboot脚本中，也是有这个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;)</span><br></pre></td></tr></table></figure><p>这条命令的使用方式为<em>OUTPUT_FORMAT(bfdname), OUTPUT_FORMAT(default, big, little)</em>，上面的例子是第一种使用方式，而uboot中的是第二种方式</p><h2 id="memory命令">MEMORY命令</h2><p>链接器的默认配置允许分配所有可用内存，你可以使用MEMORY命令来覆盖它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MEMORY &#123;</span><br><span class="line">    name [(attr)] : ORIGIN = origin, LENGTH = len</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我记得我以前使用stm32驱动显示器的时候遇到过sram不够用的情况，当时也是通过在链接脚本中添加一个段地址指向外部扩展的ddr，然后让显存地址指向这这个段解决的</p><h2 id="sections命令">SECTIONS命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text :</span><br><span class="line">&#123;</span><br><span class="line">    __text_start = .;</span><br><span class="line">    *(.text)</span><br><span class="line">    *(.strings)</span><br><span class="line">    __text_end = .;</span><br><span class="line">&#125; &gt; rom</span><br></pre></td></tr></table></figure><p>在例子中，定义了一个<strong>.text</strong> 段，并将所有输入文件中的 <strong>.text</strong> and <strong>.strings</strong> 段放入这个段中</p><p>在我们的uboot链接脚本中，还出现了一些其他的东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:</span><br><span class="line">&#123;</span><br><span class="line">    cpu/s5pc11x/start.o(.text)</span><br><span class="line">    ...</span><br><span class="line">    *(.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从脚本中看出，链接不仅仅只是能直接<strong>*(.text)</strong>操作同一类的所有输入段，还能以文件定义的方式添加到输出文件的某个SECTIONS中，以文件定义的方式可以确定不同文件的链接顺序，以免产生依赖缺失的问题</p><h2 id="at指令">AT指令</h2><p>AT指令告诉链接器将一个节的数据加载到它所在的地址之外的其他位置。使用这个指令可以将需要使用的数据存储在ROM中，在使用前将数据从ROM中提前读取到RAM中。</p><h1 id="objdump反汇编验证uboot链接脚本">objdump反汇编验证uboot链接脚本</h1><p>本uboot链接脚本如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;)</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">.text      :</span><br><span class="line">&#123;</span><br><span class="line">  cpu/s5pc11x/start.o(.text)</span><br><span class="line">  ...</span><br><span class="line">  *(.text)</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对编译后生成的elf文件进行反汇编</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ arm-linux-gnueabihf-objdump -f u-boot</span><br><span class="line"></span><br><span class="line">u-boot:     file format elf32-littlearm</span><br><span class="line">architecture: arm, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0xc3e00010</span><br></pre></td></tr></table></figure><p>前面两行就是<strong>OUTPUT_FORMAT</strong>和<strong>OUTPUT_ARCH</strong>对应内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ arm-linux-gnueabihf-objdump -h u-boot</span><br><span class="line"></span><br><span class="line">u-boot:     file format elf32-littlearm</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         0002a0b0  c3e00000  c3e00000  00008000  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>这里的<strong>.text</strong>地址也符合<a href="http://greedyhao.cc/2019/03/15/uboot%E4%B8%BB%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/#%E9%85%8D%E7%BD%AE%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE">主makefile</a>中定义的地址</p><h1 id="参考资料">参考资料</h1><ul><li><p><a href="https://gcc.gnu.org/wiki/Building_Cross_Toolchains_with_gcc?action=AttachFile&amp;do=get&amp;target=billgatliff-toolchains.pdf" target="_blank" rel="noopener">An Introduction to the GNU Compiler and Linker</a></p></li><li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/index.html" target="_blank" rel="noopener">Red Hat Enterprise Linux 4</a></p></li><li><p><a href="https://stackoverflow.com/questions/7182409/how-to-correctly-use-a-simple-linker-script-executable-gets-sigkill-when-run" target="_blank" rel="noopener">How to correctly use a simple linker script? Executable gets SIGKILL when run</a></p></li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇uboot主编译脚本分析的&lt;a href=&quot;http://greedyhao.cc/2019/03/15/uboot%E4%B8%BB%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0&quot;&gt;编译选项参数&lt;/a&gt;中提到了链接脚本这么个东西&lt;/p&gt;
&lt;p&gt;我也是写到这里才开始了解链接脚本(Linker command scripts)，之前只是大概知道有这么一个东西&lt;/p&gt;
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>uboot主编译脚本分析</title>
    <link href="http://greedyhao.cc/2019/03/15/%E5%B7%A5%E4%BD%9C-x210-2019-03-15-uboot%E4%B8%BB%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>http://greedyhao.cc/2019/03/15/工作-x210-2019-03-15-uboot主编译脚本分析/</id>
    <published>2019-03-15T05:24:59.000Z</published>
    <updated>2019-03-16T05:10:18.724Z</updated>
    
    <content type="html"><![CDATA[<p>这里是对uboot的Makefile做的一个比较详细的分析</p><a id="more"></a><h2 id="生成版本信息">生成版本信息</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VERSION = 1</span><br><span class="line">...</span><br><span class="line">U_BOOT_VERSION = <span class="variable">$(VERSION)</span>.<span class="variable">$(PATCHLEVEL)</span>.<span class="variable">$(SUBLEVEL)</span><span class="variable">$(EXTRAVERSION)</span></span><br><span class="line">VERSION_FILE = <span class="variable">$(obj)</span><span class="keyword">include</span>/version_autogenerated.h</span><br></pre></td></tr></table></figure><p>软件都是有不同版本的，uboot也不例外，在makefile开头几行就定义了版本信息，并导出到一个头文件中</p><h2 id="导出架构信息">导出架构信息</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HOSTARCH := <span class="variable">$(<span class="built_in">shell</span> uname -m | \</span></span><br><span class="line"><span class="variable">sed -e s/i.86/i386/ \</span></span><br><span class="line"><span class="variable">    ...</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable">HOSTOS := $(<span class="built_in">shell</span> uname -s | tr '[:upper:]' '[:lower:]' | \</span></span><br><span class="line"><span class="variable">    sed -e 's/\(cygwin\)</span>.*/cygwin/')</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span>HOSTARCH HOSTOS</span><br></pre></td></tr></table></figure><p>获得当前主机的架构和系统，导出到环境变量备用</p><h2 id="静默安装">静默安装</h2><p>静默安装原理很简单，只不过是把<em>echo</em>替换成了<em>:</em></p><p>静默安装时脚本就不会输出那么多没用信息了</p><h2 id="uboot链接文件产生位置">uboot链接文件产生位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># U-boot build supports producing a object files to the separate external</span><br><span class="line"># directory. Two use cases are supported:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>和其他大型的项目类似，uboot也可以把链接文件输出位置重定义到某个位置</p><p>而且uboot提供了两种方式重定义输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1) Add O= to the make command line</span><br><span class="line"># &apos;make O=/tmp/build all&apos;</span><br><span class="line">#</span><br><span class="line"># 2) Set environement variable BUILD_DIR to point to the desired location</span><br><span class="line"># &apos;export BUILD_DIR=/tmp/build&apos;</span><br><span class="line"># &apos;make&apos;</span><br></pre></td></tr></table></figure><h3 id="实现的过程">实现的过程</h3><p>这部分看看脚本就会明白，这里大概说一下</p><p>先判断定义的是O还是直接定义的<strong>BUILD_DIR</strong>，定义的是O的话就把O的值赋给<strong>BUILD_DIR</strong>(非空)</p><p>接下来就定义并导出了<strong>OBJTREE</strong>(BUILD_DIR设置过来的链接文件的位置) <strong>SRCTREE</strong>(当前目录设置来的源码目录) <strong>TOPDIR</strong>(当前目录设置为顶层) <strong>LNDIR</strong>(OBJTREE保存为链接文件位置)</p><p>定义并导出<strong>MKCONFIG</strong>(SRCTREE下的mkconfig脚本，用于配置uboot)</p><p>如果<strong>OBJTREE</strong>和<strong>SRCTREE</strong>不等就定义并导出<strong>REMOTE_BUILD</strong>，并<em>obj := $(OBJTREE) src := $(SRCTREE)</em></p><h2 id="配置交叉编译工具链">配置交叉编译工具链</h2><p>从<em>$(obj)include/config.mk</em>导入<strong>ARCH CPU BOARD VENDOR SOC</strong>这几个变量，<strong>config.mk</strong>这个文件是<em>make x210_sd_config</em>产生的，<strong>x210_sd_config</strong>在Makefile的最后一部分有定义，这是为了确保Makefile的通用性</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x210_sd_config :unconfig</span><br><span class="line">@<span class="variable">$(MKCONFIG)</span> $(@:_config=) arm s5pc11x x210 samsung s5pc110</span><br><span class="line">@echo <span class="string">"TEXT_BASE = 0xc3e00000"</span> &gt; <span class="variable">$(obj)</span>board/samsung/x210/config.mk</span><br></pre></td></tr></table></figure><p>之后就是通过判断<strong>ARCH</strong>的不同，使用不同的<strong>CROSS_COMPILE</strong></p><p>然后就是导入<em>$(TOPDIR)/config.mk</em>中的其他配置</p><h2 id="topdirconfig.mk">$(TOPDIR)/config.mk</h2><p>大概看了下，这个文件提供了编译选项和变量</p><h3 id="导入make变量">导入make变量</h3><p>定义的<strong>CROSS_COMPILE</strong>会在<em>$(TOPDIR)/config.mk</em>中使用</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AS= <span class="variable">$(CROSS_COMPILE)</span>as</span><br><span class="line">LD= <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">CC= <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="导入自动生成配置">导入自动生成配置</h3><p>然后导入*<span class="math inline">\((OBJTREE)/include/autoconf.mk*，这是一个根据开发板自动生成(根据\)</span>(TOPDIR)/include/configs/x210_sd.h定义生成)的脚本，里面定义了一些硬件相关的配置</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_CMD_FAT=y</span><br><span class="line">CONFIG_USB_OHCI=y</span><br><span class="line">CONFIG_SYS_CLK_FREQ=24000000</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再根据<strong>ARCH</strong>等变量，导入对应的config脚本</p><h3 id="编译选项参数">编译选项参数</h3><p>这一部分定义了一堆的FLAGS</p><p><strong>LDSCRIPT</strong>定义链接脚本是否使用nand版</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> LDSCRIPT</span><br><span class="line"><span class="comment">#LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds.debug</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_NAND_U_BOOT)</span>,y)</span><br><span class="line">LDSCRIPT := <span class="variable">$(TOPDIR)</span>/board/<span class="variable">$(BOARDDIR)</span>/u-boot-nand.lds</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LDSCRIPT := <span class="variable">$(TOPDIR)</span>/board/<span class="variable">$(BOARDDIR)</span>/u-boot.lds</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p><strong>TEXT_BASE</strong>是在Makefile中定义的uboot链接地址，上面的<a href="#配置交叉编译工具链">配置交叉编译工具链</a>里就有写</p><p>这里的地址是虚拟地址，物理地址取决于uboot中的地址映射</p><h2 id="uboot链接对象">uboot链接对象</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># U-Boot objects....order is important (i.e. start must be first)</span></span><br><span class="line"></span><br><span class="line">OBJS  = cpu/<span class="variable">$(CPU)</span>/start.o</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CPU)</span>,i386)</span><br><span class="line">OBJS += cpu/<span class="variable">$(CPU)</span>/start16.o</span><br><span class="line">OBJS += cpu/<span class="variable">$(CPU)</span>/reset.o</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这一部分是链接一些必要的库和.o文件</p><h2 id="all标签">ALL标签</h2><p>当我们在命令行使用<em>make</em>时，就会执行这一部分的脚本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALL += <span class="variable">$(obj)</span>u-boot.srec <span class="variable">$(obj)</span>u-boot.bin <span class="variable">$(obj)</span>System.map <span class="variable">$(U_BOOT_NAND)</span> <span class="variable">$(U_BOOT_ONENAND)</span> <span class="variable">$(obj)</span>u-boot.dis</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(ARCH)</span>,blackfin)</span><br><span class="line">ALL += <span class="variable">$(obj)</span>u-boot.ldr</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:<span class="variable">$(ALL)</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在make编译后，我们也能看到这些对象</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ ls | grep u-boot</span></span><br><span class="line">u-boot</span><br><span class="line">u-boot.bin</span><br><span class="line">u-boot.dis</span><br><span class="line">u-boot.map</span><br><span class="line">u-boot.srec</span><br></pre></td></tr></table></figure><h2 id="unconfig">unconfig</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">unconfig:</span></span><br><span class="line">@rm -f <span class="variable">$(obj)</span><span class="keyword">include</span>/config.h <span class="variable">$(obj)</span><span class="keyword">include</span>/config.mk \</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意到上面<a href="#配置交叉编译工具链">配置交叉编译工具链</a>中的<strong>x210_sd_config</strong>和这里的<strong>unconfig</strong>有关，现在再对<strong>x210_sd_config</strong>的这段脚本做进一步的探讨</p><p>$(@:_config=)会把<strong>x210_sd_config</strong>匹配成<strong>x210_sd</strong>，从而使得mkconfig得到了6个参数<strong>x210_sd arm s5pc11x x210 samsung s5pc110</strong></p><h3 id="mkconfig">mkconfig</h3><p>接下来就进入到mkconfig</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span> -gt 0 ] ; <span class="keyword">do</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">--) <span class="built_in">shift</span> ; <span class="built_in">break</span> ;;</span><br><span class="line">-a) <span class="built_in">shift</span> ; APPEND=yes ;;</span><br><span class="line">-n) <span class="built_in">shift</span> ; BOARD_NAME=<span class="string">"<span class="variable">$&#123;1%%_config&#125;</span>"</span> ; <span class="built_in">shift</span> ;;</span><br><span class="line">*)  <span class="built_in">break</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这段脚本的作用就是对传入的第一个参数<strong>$1</strong>进行匹配，<strong>x210_sd</strong>只能匹配上*</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">"<span class="variable">$&#123;BOARD_NAME&#125;</span>"</span> ] || BOARD_NAME=<span class="string">"<span class="variable">$1</span>"</span></span><br></pre></td></tr></table></figure><p>这里就将参数1的值赋给了<strong>BOARD_NAME</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="variable">$#</span> -lt 4 ] &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">[ <span class="variable">$#</span> -gt 6 ] &amp;&amp; <span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>这里是为了避免参数的数量不正确</p><p>之后就是为架构的指定头文件创建符号链接，这是为了可移植性，通过判断传入的<strong>ARCH CPU BOARD</strong>这几个参数，链接不同的头文件</p><h2 id="各种适配">各种适配</h2><p>再接下来的内容就是各种系统下的适配，<a href="#配置交叉编译工具链">配置交叉编译工具链</a>的脚本也是这部分的内容</p><h2 id="make的其他选项">make的其他选项</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">@rm -f <span class="variable">$(obj)</span>examples/82559_eeprom <span class="variable">$(obj)</span>examples/eepro100_eeprom \</span><br><span class="line">...</span><br><span class="line"><span class="section">clobber:clean</span></span><br><span class="line">...</span><br><span class="line"><span class="section">distclean:clobber unconfig</span></span><br><span class="line">    ...</span><br><span class="line"><span class="section">backup:</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是对uboot的Makefile做的一个比较详细的分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>uboot源码目录分析</title>
    <link href="http://greedyhao.cc/2019/03/13/%E5%B7%A5%E4%BD%9C-x210-2019-03-13-uboot%E6%BA%90%E7%A0%81%E6%9E%84%E6%88%90%E5%88%86%E6%9E%90/"/>
    <id>http://greedyhao.cc/2019/03/13/工作-x210-2019-03-13-uboot源码构成分析/</id>
    <published>2019-03-13T04:44:00.000Z</published>
    <updated>2019-03-13T04:49:52.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="uboot源码简单分析">uboot源码简单分析</h1><p>这里只是对uboot源码目录下的内容做一个简单的分析而已，具体的学习会在之后，先来一个整体的了解。</p><a id="more"></a><h1 id="脚本文件分析">脚本文件分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ tree -FL 1 | grep -v /$</span><br><span class="line">.</span><br><span class="line">├── arm_config.mk</span><br><span class="line">├── CHANGELOG</span><br><span class="line">├── CHANGELOG-before-U-Boot-1.1.5</span><br><span class="line">├── Changelog_Samsung</span><br><span class="line">├── config.mk</span><br><span class="line">├── COPYING</span><br><span class="line">├── CREDITS</span><br><span class="line">├── image_split*</span><br><span class="line">├── MAINTAINERS</span><br><span class="line">├── MAKEALL*</span><br><span class="line">├── Makefile</span><br><span class="line">├── mk*</span><br><span class="line">├── mkconfig*</span><br><span class="line">├── mkmovi*</span><br><span class="line">├── README</span><br><span class="line">├── rules.mk</span><br><span class="line">├── System.map</span><br><span class="line">├── u-boot*</span><br><span class="line">├── u-boot.bin*</span><br><span class="line">├── u-boot.dis</span><br><span class="line">├── u-boot.map</span><br><span class="line">└── u-boot.srec*</span><br></pre></td></tr></table></figure><p>常见的类似git、changelog、copyright就略过吧</p><h2 id="image_split">image_split</h2><p>用于分割uboot到BL1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ cat image_split </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script split u-boot binary for secure boot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># spiliting u-boot for BL1 (8KB -128 Byte)</span></span><br><span class="line">rm bl2*</span><br><span class="line">split -b 8064 u-boot.bin bl2.bin</span><br></pre></td></tr></table></figure><h2 id="makeall-makefile-mk">MAKEALL Makefile mk</h2><p>这三个是用来编译uboot的脚本</p><p>MAKEALL大概是用来设置如何编译的，因为看了脚本的前面一部分，是判断如何MAKE、LOG位置、BUILD位置的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;CROSS_COMPILE&#125;</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">MAKE=<span class="string">"make CROSS_COMPILE=<span class="variable">$&#123;CROSS_COMPILE&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">MAKE=make</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;MAKEALL_LOGDIR&#125;</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">LOG_DIR=<span class="variable">$&#123;MAKEALL_LOGDIR&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LOG_DIR=<span class="string">"LOG"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="string">"<span class="variable">$&#123;BUILD_DIR&#125;</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">BUILD_DIR=<span class="string">"."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">[ -d <span class="variable">$&#123;LOG_DIR&#125;</span> ] || mkdir <span class="variable">$&#123;LOG_DIR&#125;</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line">LIST=<span class="string">""</span></span><br></pre></td></tr></table></figure><p>Makefile就是主编译脚本了，用来管理整个uboot的编译，脚本有3千多行，暂时先放一边</p><p>至于mk就是一种类似与一键编译的东西，就把原先编译时需要手动输入的命令放到脚本里，直接执行脚本就可以编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make distclean</span><br><span class="line">make x210_sd_config</span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure><h2 id="mkconfig">mkconfig</h2><p>这个是uboot的主要配置脚本，它会为指定的开发板生成配置需要的头文件和链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh -e</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Script to create header files and links to configure</span></span><br><span class="line"><span class="comment"># U-Boot for a specific board.</span></span><br></pre></td></tr></table></figure><h2 id="mkmovi">mkmovi</h2><p>这个脚本和inand/SD卡启动有关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script will create a u-boot binary for movinand/mmc boot</span></span><br></pre></td></tr></table></figure><h2 id="rules.mk">rules.mk</h2><p>uboot的Makefile使用规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_depend:$(obj).depend</span><br><span class="line"></span><br><span class="line">$(obj).depend:$(src)Makefile $(TOPDIR)/config.mk $(SRCS)</span><br><span class="line">@rm -f <span class="variable">$@</span></span><br><span class="line">@<span class="keyword">for</span> f <span class="keyword">in</span> $(SRCS); <span class="keyword">do</span> \</span><br><span class="line">g=`basename $<span class="variable">$f</span> | sed -e <span class="string">'s/\(.*\)\.\w/\1.o/'</span>`; \</span><br><span class="line">$(CC) -M $(HOST_CFLAGS) $(CPPFLAGS) -MQ $(obj)$<span class="variable">$g</span> $<span class="variable">$f</span> &gt;&gt; <span class="variable">$@</span> ; \</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="其他目录分析">其他目录分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ tree -d -L 1</span><br><span class="line">.</span><br><span class="line">├── api</span><br><span class="line">├── api_examples</span><br><span class="line">├── board</span><br><span class="line">├── common</span><br><span class="line">├── cpu</span><br><span class="line">├── disk</span><br><span class="line">├── doc</span><br><span class="line">├── drivers</span><br><span class="line">├── examples</span><br><span class="line">├── fs</span><br><span class="line">├── include</span><br><span class="line">├── lib_arm</span><br><span class="line">├── libfdt</span><br><span class="line">├── lib_generic</span><br><span class="line">├── nand_spl</span><br><span class="line">├── net</span><br><span class="line">├── onenand_bl1</span><br><span class="line">├── onenand_ipl</span><br><span class="line">├── post</span><br><span class="line">├── sd_fusing</span><br><span class="line">└── tools</span><br></pre></td></tr></table></figure><h2 id="api-api_examples">api api_examples</h2><p>api提供了一系列的系统调用</p><p>api_examples则提供了api的使用例程</p><h2 id="board">board</h2><p>为特定开发板提供移植的文件放在这个文件夹中</p><h2 id="common">common</h2><p>通用代码，与处理器架构无关代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot/common$ ls</span><br><span class="line">ace_sha1.c        cmd_dcr.c       cmd_immap.c      cmd_onenand.c   cmd_vfd.c        env_nowhere.c  miiphybb.c</span><br><span class="line">ACEX1K.c          cmd_df.c        cmd_itest.c      cmd_otp.c       cmd_ximg.c       env_nvram.c    miiphyutil.c</span><br><span class="line">altera.c          cmd_diag.c      cmd_jffs2.c      cmd_pci.c       command.c        env_onenand.c  secure_boot.c</span><br><span class="line">bedbug.c          cmd_display.c   cmd_load.c       cmd_pcmcia.c    console.c        env_sf.c       serial.c</span><br><span class="line">circbuf.c         cmd_doc.c       cmd_log.c        cmd_portio.c    crc16.c          exports.c      soft_i2c.c</span><br><span class="line">cmd_ambapp.c      cmd_dtt.c       cmd_mac.c        cmd_reginfo.c   cyclon2.c        fdt_support.c  soft_spi.c</span><br><span class="line">cmd_android.c     cmd_eeprom.c    cmd_mem.c        cmd_reiser.c    devices.c        flash.c        spartan2.c</span><br><span class="line">cmd_autoscript.c  cmd_elf.c       cmd_mfsl.c       cmd_sata.c      dlmalloc.c       fpga.c         spartan3.c</span><br><span class="line">cmd_bdinfo.c      cmd_ext2.c      cmd_mii.c        cmd_scsi.c      dlmalloc.src     gunzip.c       s_record.c</span><br><span class="line">cmd_bedbug.c      cmd_fastboot.c  cmd_misc.c       cmd_setexpr.c   docecc.c         hush.c         stratixII.c</span><br><span class="line">cmd_bmp.c         cmd_fat.c       cmd_mmc.c        cmd_sf.c        env_auto.c       image.c        usb.c</span><br><span class="line">cmd_boot.c        cmd_fdc.c       cmd_mmc_fdisk.c  cmd_spi.c       env_common.c     kgdb.c         usb_kbd.c</span><br><span class="line">cmd_bootldr.c     cmd_fdos.c      cmd_movi.c       cmd_strings.c   env_dataflash.c  lcd.c          usb_storage.c</span><br><span class="line">cmd_bootm.c       cmd_fdt.c       cmd_mp.c         cmd_terminal.c  env_eeprom.c     lists.c        virtex2.c</span><br><span class="line">cmd_cache.c       cmd_flash.c     cmd_mtdparts.c   cmd_ubi.c       env_flash.c      lynxkdi.c      xilinx.c</span><br><span class="line">cmd_console.c     cmd_fpga.c      cmd_nand.c       cmd_universe.c  environment.c    main.c         xyzModem.c</span><br><span class="line">cmd_cplbinfo.c    cmd_i2c.c       cmd_net.c        cmd_usb.c       env_movi.c       Makefile</span><br><span class="line">cmd_date.c        cmd_ide.c       cmd_nvedit.c     cmd_usbd.c      env_nand.c       memsize.c</span><br></pre></td></tr></table></figure><p>从上面的输出可以看出有三大类的文件 + cmd开头的文件是实现uboot命令的 + env开头的文件是实现环境变量的 + 其他文件是实现一些其他功能如加密算法、驱动框架等等</p><h2 id="cpu">cpu</h2><p>处理器相关的初始化和控制代码</p><p>基本不需要修改</p><h2 id="disk">disk</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot/disk$ ls</span><br><span class="line">Makefile  part_amiga.c  part_amiga.h  part.c  part_dos.c  part_dos.h  part_iso.c  part_iso.h  part_mac.c  part_mac.h</span><br></pre></td></tr></table></figure><p>这个目录下放的是各种系统的分区表，感觉像是用来在不同系统下获取分区信息的</p><h2 id="doc">doc</h2><p>uboot相关文档，不过感觉很乱，架构、算法、存储器、命令等等都混在一起，看起来不怎么方便</p><h2 id="drivers">drivers</h2><p>从linux中移植来的驱动</p><h2 id="examples">examples</h2><p>示例代码</p><h2 id="fs">fs</h2><p>文件系统</p><h2 id="include">include</h2><p>头文件目录</p><h2 id="lib_arm-lib_generic">lib_arm lib_generic</h2><p>架构相关的库文件</p><h2 id="libfdt">libfdt</h2><p>设备树相关</p><h2 id="net">net</h2><p>网络相关代码的简单实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot/net$ ls</span><br><span class="line">bootp.c  bootp.h  eth.c  Makefile  net.c  nfs.c  nfs.h  rarp.c  rarp.h  sntp.c  sntp.h  tftp.c  tftp.h</span><br></pre></td></tr></table></figure><h2 id="onenand-onenan相关代码">onenand* onenan相关代码</h2><h2 id="sd_fusing">sd_fusing</h2><p>SD卡烧写代码</p><h2 id="tools">tools</h2><p>在这个目录下可以看到一些熟悉的名词像crc gdb md5等，这里就是一个工具的集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot/tools$ lsbddb        </span><br><span class="line">envcrc.c       fdt_rw.c        image.c            logos           mkimage.h        sha1.c</span><br><span class="line">bmp_logo.c  environment.c  fdt_strerror.c  img2brec.sh        Makefile        mpc86x_clk.c     ubsha1.c</span><br><span class="line">crc32.c     fdt.c          fdt_wip.c       img2srec.c         Makefile.win32  ncb.c            updater</span><br><span class="line">easylogo    fdt_host.h     gdb             inca-swap-bytes.c  md5.c           scripts          zlib.h</span><br><span class="line">env         fdt_ro.c       gen_eth_addr.c  libfdt_internal.h  mkimage.c       setlocalversion</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;uboot源码简单分析&quot;&gt;uboot源码简单分析&lt;/h1&gt;
&lt;p&gt;这里只是对uboot源码目录下的内容做一个简单的分析而已，具体的学习会在之后，先来一个整体的了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>uboot编译体验</title>
    <link href="http://greedyhao.cc/2019/03/11/%E5%B7%A5%E4%BD%9C-x210-2019-03-11-uboot%E7%BC%96%E8%AF%91%E4%BD%93%E9%AA%8C/"/>
    <id>http://greedyhao.cc/2019/03/11/工作-x210-2019-03-11-uboot编译体验/</id>
    <published>2019-03-11T14:15:37.000Z</published>
    <updated>2019-03-11T14:16:05.846Z</updated>
    
    <content type="html"><![CDATA[<p>想玩玩zynq，但是发现需要linux方面的知识配合会更加合适，因为zynq有arm的硬核，有的时候可能会需要用上linux</p><a id="more"></a><p>正好买了朱有鹏视频，就拿来学习一下</p><p>看了看学习的进程大概是这样的 + 安装编译工具，编译uboot + 分析uboot源码和makefile</p><h1 id="安装交叉编译工具链">安装交叉编译工具链</h1><p>本人使用的开发部是s5pv210，需要安装的交叉编译工具链是<em>arm-2019q3</em></p><p>遵循默认规则，将工具链解压安装到了<em>/usr/local/arm</em>下</p><p>添加到了PATH中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ARM Cross Complier PATH</span><br><span class="line">export PATH=/usr/local/arm/arm-2009q3/bin:$PATH</span><br></pre></td></tr></table></figure><p>测试工具链是否正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:~$ arm-none-linux-gnueabi-gcc --version</span><br><span class="line">arm-none-linux-gnueabi-gcc (Sourcery G++ Lite 2009q3-67) 4.4.1</span><br><span class="line">Copyright (C) 2009 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><h1 id="编译uboot">编译uboot</h1><p>毕竟是有课程学习，有提供做好的uboot源码，可以体验一下编译的感觉，氪金了还真是不一样</p><p>首先是先找到需要编译的bsp,QT4.8版本，并解压出来</p><h2 id="配置">配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ make x210_sd_config </span><br><span class="line">Configuring for x210_sd board...</span><br></pre></td></tr></table></figure><p>如果出现了上面的信息就说明配置成功</p><p>检查Makefile中的编译链位置是否正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-</span><br></pre></td></tr></table></figure><p>查看编译结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ du u-boot*</span><br><span class="line">936u-boot</span><br><span class="line">384u-boot.bin</span><br><span class="line">1780u-boot.dis</span><br><span class="line">184u-boot.map</span><br><span class="line">1156u-boot.srec</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想玩玩zynq，但是发现需要linux方面的知识配合会更加合适，因为zynq有arm的硬核，有的时候可能会需要用上linux&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://greedyhao.cc/tags/Linux/"/>
    
      <category term="x210" scheme="http://greedyhao.cc/tags/x210/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo需要配置的东西</title>
    <link href="http://greedyhao.cc/2019/03/08/%E5%B7%A5%E4%BD%9C-hexo-2019-03-08-%E4%BD%BF%E7%94%A8hexo%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    <id>http://greedyhao.cc/2019/03/08/工作-hexo-2019-03-08-使用hexo需要配置的东西/</id>
    <published>2019-03-08T06:27:14.000Z</published>
    <updated>2019-03-08T06:29:28.659Z</updated>
    
    <content type="html"><![CDATA[<p>每次重装电脑后都要重新部署hexo，每次要配置的东西都要重新去网上找，现在在这里整合以下，免得麻烦</p><a id="more"></a><h1 id="npm">npm</h1><p>先确定npm位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure><p>如果是在<em>/usr/local</em>下，就输入下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R `whoami` &lt;directory&gt; <span class="comment"># directory为你的node_modules位置</span></span><br></pre></td></tr></table></figure><p>如果是在<em>/usr</em>下，可以选择创建一个目录用来安装npm包</p><p>个人是放在<em>/usr/local/lib/node_modules</em>下，然后和上面一样，更改用户组</p><h1 id="hexo安装">hexo安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><h1 id="使用ssh">使用ssh</h1><p>按照下面的命令就可以了，没有的文件就创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"hao_kr@163.com"</span> -f <span class="string">"id_rsa_github"</span> <span class="comment"># 中间一直按回车就好</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"hao_kr@163.com"</span> -f <span class="string">"id_rsa_gitee"</span></span><br></pre></td></tr></table></figure><p>创建一个config文件配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim config</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># gitee</span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_gitee</span><br><span class="line"></span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure><p>最后测试是否成功，如果输出<em>Hi,..</em>就表示成功 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><h1 id="hexo-deploy卡住问题">hexo deploy卡住问题</h1><p>我翻看了很多人写的笔记，给git设置了proxy，使用ssh，但是都没有解决问题</p><p>最后没有办法，只能手动push了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .deploy_git</span><br><span class="line">git remote add git@github.com:xxxx/xxxx.github.io.git</span><br><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><p>这句命令可能会产生一些冲突信息，不用理会</p><p>然后重新生成一下静态页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>回到deploy目录，手动push，第一次push需要设置upstream <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd .deploy_git</span><br><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure></p><p>在这之后我又试了一次<em>hexo d</em>，发现可以成功deploy了，可能之前deploy失败和hexo没有把git的remote设置好有关吧，手动设置remote后就正常了</p><h1 id="markdown渲染">markdown渲染</h1><p>更换mathjax渲染引擎，使用<em>hexo-renderer-pandoc</em>渲染</p><p>首先需要安装pandoc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install pandoc</span><br></pre></td></tr></table></figure><p>之后来到你的hexo的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次重装电脑后都要重新部署hexo，每次要配置的东西都要重新去网上找，现在在这里整合以下，免得麻烦&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://greedyhao.cc/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>体验deepin系统</title>
    <link href="http://greedyhao.cc/2019/03/04/%E5%B7%A5%E4%BD%9C-Linux-2019-03-04-%E4%BD%93%E9%AA%8Cdeepin%E7%B3%BB%E7%BB%9F/"/>
    <id>http://greedyhao.cc/2019/03/04/工作-Linux-2019-03-04-体验deepin系统/</id>
    <published>2019-03-04T15:42:25.000Z</published>
    <updated>2019-03-08T06:22:28.598Z</updated>
    
    <content type="html"><![CDATA[<p>之前体验了<a href="http://mp.weixin.qq.com/s?__biz=MzU0OTAyODAzMg==&amp;mid=100000323&amp;idx=1&amp;sn=7d889a7a8488e70c2ba32a97c7054672&amp;chksm=7bb76bec4cc0e2faeead09d5423fa334110b882d54dd104e790d2691d2d95f5ed0e6cd714d22#rd" target="_blank" rel="noopener">Ubuntu18.04</a>，在使用了几个月后，还是放弃了</p><a id="more"></a><p>主要是Ubuntu18.04有一些很难接受的问题如下: + 双屏体验很差。每次重启后会将笔记本的屏幕设置为主屏幕；从双屏转为单屏时，被关闭屏幕的图标不会自动移动到另一个屏幕。 + 会出现莫名奇妙的BUG</p><p>偶然间了解到了deepin这个系统，看了看他的演示视频，觉得真心不错。很顺畅，界面也好看。</p><p>先上一张启动器的图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/deepin/launcher.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="前期工作">前期工作</h1><p>可以参考一下官方的文档中说的<a href="https://www.deepin.org/installation/" target="_blank" rel="noopener">如何安装</a></p><h2 id="备份">备份</h2><p>如果当前电脑硬盘是MBR格式的话，在安装系统的时候会提示说无法安装，因为需要GPT格式的硬盘才支持安装。</p><p>如果是参考之前的<a href="http://mp.weixin.qq.com/s?__biz=MzU0OTAyODAzMg==&amp;mid=100000323&amp;idx=1&amp;sn=7d889a7a8488e70c2ba32a97c7054672&amp;chksm=7bb76bec4cc0e2faeead09d5423fa334110b882d54dd104e790d2691d2d95f5ed0e6cd714d22#rd" target="_blank" rel="noopener">Ubuntu18.04+win10双系统</a>安装的系统，可能是需要备份一下再安装，安装时会自动帮你转换硬盘格式</p><h2 id="制作启动盘">制作启动盘</h2><p>制作启动盘的方法可以参考官方的文档<a href="https://wiki.deepin.org/wiki/%E5%8E%9F%E7%94%9F%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">原生安装</a></p><p>制作启动盘推荐使用官方制作工具<a href="https://www.deepin.org/original/deepin-boot-maker/" target="_blank" rel="noopener">深度启动盘制作工具</a>，我试过了软碟通制作的启动盘是无法使用的</p><h2 id="选择文件格式挂载点分配空间">选择文件格式、挂载点、分配空间</h2><p>以下配置推荐来自<a href="https://www.deepin.org/installation/" target="_blank" rel="noopener">官方推荐</a>，如果是安装双系统的话需要boot分区</p><table><thead><tr class="header"><th style="text-align: left;">挂载点</th><th style="text-align: left;">挂载点中文名</th><th style="text-align: left;">文件系统</th><th style="text-align: left;">大小</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">/</td><td style="text-align: left;">根分区（必选）</td><td style="text-align: left;">EXT4（推荐）</td><td style="text-align: left;">最少10G</td></tr><tr class="even"><td style="text-align: left;">/boot</td><td style="text-align: left;">引导盘（可选）</td><td style="text-align: left;">EXT4（推荐）</td><td style="text-align: left;">最少800M</td></tr><tr class="odd"><td style="text-align: left;">/home</td><td style="text-align: left;">家目录（推荐）</td><td style="text-align: left;">EXT4（推荐）</td><td style="text-align: left;">最少10G</td></tr><tr class="even"><td style="text-align: left;">swap</td><td style="text-align: left;">交换分区（可选）</td><td style="text-align: left;">不设置</td><td style="text-align: left;">4G内存以下分配2G，4G以上可不分配</td></tr></tbody></table><h1 id="后期工作">后期工作</h1><h2 id="切换显卡驱动">切换显卡驱动</h2><p>进入到启动器搜索gpu，找到打开<strong>显卡驱动管理</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/deepin/gpu_driver_m.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>需要使用双屏的需要选择<strong>NV-PRIME</strong>，单屏的话可以选择<strong>小黄蜂</strong></p><p>有时候切换驱动会失败，一般再试下就可以切换成功了</p><h2 id="系统更新">系统更新</h2><p>在使用前最好更新下系统，因为有些旧版软件有BUG</p><p>在命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade -y</span><br></pre></td></tr></table></figure><h2 id="添加桌面快捷方式">添加桌面快捷方式</h2><p>一些常用软件可以在桌面添加一个快捷方式，这样启动起来比在命令行中启动方便</p><p>可以参考<a href="https://wiki.deepin.org/wiki/Desktop_Entry_%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">Desktop Entry 文件</a>这个文档</p><p>这里简单的说说</p><p>一般个人软件就放在<em>~/.local/share/applications</em>下，Desktop Entry 文件格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry] #每个desktop文件都以这个标签开始，说明这是一个Desktop Entry文件</span><br><span class="line">Version = 1.0 #标明Desktop Entry的版本（可选）</span><br><span class="line">Name = Firefox #程序名称（必须），这里以创建一个Firefox的快捷方式为例</span><br><span class="line">GenericName = Web Browser #程序通用名称（可选）</span><br><span class="line">Comment = A Web Browser #程序描述（可选）</span><br><span class="line">Exec = firefox %u #程序的启动命令（必选），可以带参数运行,当下面的Type为Application，此项有效</span><br><span class="line">Icon = firefox #设置快捷方式的图标（可选）</span><br><span class="line">Terminal = false #是否在终端中运行（可选），当Type为Application，此项有效</span><br><span class="line">Type = Application #desktop的类型（必选），常见值有“Application”和“Link”</span><br><span class="line">Categories = GNOME;Application;Network; #注明在菜单栏中显示的类别（可选）</span><br></pre></td></tr></table></figure><p>以我个人的配置作为示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name = STM32CubeMX</span><br><span class="line">Version = 5.1.0</span><br><span class="line">GenericName = STM32CubeMX</span><br><span class="line">Exec = /usr/local/STM32CubeMX/STM32CubeMX</span><br><span class="line">Icon = /usr/local/STM32CubeMX/help/STM32CubeMX.ico</span><br><span class="line">Path = /usr/local/STM32CubeMX</span><br><span class="line">Terminal = false </span><br><span class="line">Type = Application </span><br><span class="line">Categories = Development</span><br></pre></td></tr></table></figure><p>创建完这个文件就可以在启动器中看见这个软件了，右键即可添加到桌面</p><h1 id="事后感言">事后感言</h1><p>deepin团队修改完善了内核的一些方面，也开发了一些优秀的软件包方便使用deepin，基本的软件如QQ 微信 chrome都已经预装，开箱即用很方便</p><p><strong>双屏体验</strong>在deepin上得到了优化，不仅仅只是可以设置外接显示屏为主显示器，而且可以将外接显示器与自带显示器位置互换，并在重启后自定义位置不会重置，还可以将这个设置保存为一个自定义选项，方便从双屏与单屏之间的切换。截屏的功能在双屏下可以正常使用，不过录屏的功能无法录制扩展屏，暂时还不清楚是什么原因</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/deepin/launcher.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>deepin-wine</strong>无法安装LOL。<strong>steam</strong>下的porton效果也不是太好，目前发现无法运行PUBG，主要是无法启动battleye服务</p><p>安装应用不要使用root权限，可以通过修改文件夹所有用户组安装，具体步骤下次说</p><p>希望这个系统的新鲜感保质期能久一点</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前体验了&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0OTAyODAzMg==&amp;amp;mid=100000323&amp;amp;idx=1&amp;amp;sn=7d889a7a8488e70c2ba32a97c7054672&amp;amp;chksm=7bb76bec4cc0e2faeead09d5423fa334110b882d54dd104e790d2691d2d95f5ed0e6cd714d22#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu18.04&lt;/a&gt;，在使用了几个月后，还是放弃了&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://greedyhao.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何移植RT-Thread的BSP</title>
    <link href="http://greedyhao.cc/2018/12/12/%E5%B7%A5%E4%BD%9C-rt-thread-2018-12-12-%E5%A6%82%E4%BD%95%E7%A7%BB%E6%A4%8DRT-Thread%E7%9A%84BSP/"/>
    <id>http://greedyhao.cc/2018/12/12/工作-rt-thread-2018-12-12-如何移植RT-Thread的BSP/</id>
    <published>2018-12-12T09:00:02.000Z</published>
    <updated>2018-12-12T09:07:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近RT-Thread重构了stm32的BSP，看了一下，感觉很思路很清晰</p><a id="more"></a><table><thead><tr class="header"><th style="text-align: left;">目录</th><th style="text-align: left;">简介</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">bsp32</td><td style="text-align: left;">重构BSP的介绍文档</td></tr><tr class="even"><td style="text-align: left;">bsp32</td><td style="text-align: left;">各系列的stm32的HAL库</td></tr><tr class="odd"><td style="text-align: left;">bsp32_Drivers</td><td style="text-align: left;">基于HAL库的设备驱动</td></tr><tr class="even"><td style="text-align: left;">bsp32_Drivers</td><td style="text-align: left;">外设驱动的配置文件</td></tr><tr class="odd"><td style="text-align: left;">bsp32_Drivers_flash</td><td style="text-align: left;">flash的配置文件</td></tr><tr class="even"><td style="text-align: left;">bsp32</td><td style="text-align: left;">移植BSP的模板</td></tr><tr class="odd"><td style="text-align: left;">bsp3232fxxx-xxx-xxx</td><td style="text-align: left;">各开发板的适配工程</td></tr></tbody></table><p>我觉得这就是我想要的，于是就开始移植重构后的BSP</p><h1 id="移植流程">移植流程</h1><ul><li>复制一个与自己开发板系列相近的BSP</li><li>修改Scons脚本文件</li><li>修改驱动文件</li><li>规范BSP</li></ul><h1 id="复制一个与自己开发板系列相近的bsp">复制一个与自己开发板系列相近的BSP</h1><p>先找一个和自己开发板MCU类似的BSP，例如我的开发板的MCU是stm32f767，所以我复制了这个目录下的工程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger</span><br></pre></td></tr></table></figure><p>修改名字为你的开发板名字，例如我的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f767-fire-challenger</span><br></pre></td></tr></table></figure><p>然后，在libraries目录下加入你使用的MCU系列的HAL库文件，比如我的f7系列就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\STM32F7xx_HAL</span><br></pre></td></tr></table></figure><p>HAL库文件可以从<a href="https://www.st.com/zh/development-tools/stm32cubemx.html" target="_blank" rel="noopener">STM32CubeFx</a>中解压得到</p><p>然后参照着已经有的HAL库文件夹的情况，将一些使用不到的文件删除，特别是以下文件需要删除，否则会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\STM32F7xx_HAL\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_msp_template.c</span><br><span class="line">bsp\stm32\libraries\STM32F7xx_HAL\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_timebase_rtc_alarm_template.c</span><br><span class="line">bsp\stm32\libraries\STM32F7xx_HAL\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_timebase_rtc_wakeup_template.c</span><br><span class="line">bsp\stm32\libraries\STM32F7xx_HAL\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_timebase_tim_template.c</span><br></pre></td></tr></table></figure><p><strong>在移植完成后</strong>，将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f767-fire-challenger</span><br></pre></td></tr></table></figure><p>复制到下面这个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates</span><br></pre></td></tr></table></figure><p>将名字更改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f7xx</span><br></pre></td></tr></table></figure><h1 id="修改scons脚本文件">修改Scons脚本文件</h1><p>需要修改的脚本文件有点多，不过不急，慢慢来</p><p>可以从<a href="https://github.com/RT-Thread/rt-thread/pull/2058/files" target="_blank" rel="noopener">我提交的pr</a>中看到我修改过的脚本文件，我将他们全部列出来，免得有人遗漏了需要修改的地方</p><ul><li>bsp/stm32/libraries/HAL_Drivers/SConscript</li><li>bsp/stm32/libraries/HAL_Drivers/drv_config.h</li><li>bsp/stm32/libraries/Kconfig</li><li>bsp/stm32/libraries/STM32F7xx_HAL/SConscript</li><li>bsp/stm32/stm32f767-fire-challenger/Kconfig</li><li>bsp/stm32/stm32f767-fire-challenger/SConscript</li><li>bsp/stm32/stm32f767-fire-challenger/SConstruct</li><li>bsp/stm32/stm32f767-fire-challenger/applications/SConscript</li><li>bsp/stm32/stm32f767-fire-challenger/board/Kconfig</li><li>bsp/stm32/stm32f767-fire-challenger/board/SConscript</li><li>bsp/stm32/stm32f767-fire-challenger/rtconfig.py</li><li>bsp/stm32/libraries/templates/stm32f7xx/Kconfig</li><li>bsp/stm32/libraries/templates/stm32f7xx/SConscript</li><li>bsp/stm32/libraries/templates/stm32f7xx/SConstruct</li><li>bsp/stm32/libraries/templates/stm32f7xx/applications/SConscript</li><li>bsp/stm32/libraries/templates/stm32f7xx/board/Kconfig</li><li>bsp/stm32/libraries/templates/stm32f7xx/board/SConscript</li><li>bsp/stm32/libraries/templates/stm32f7xx/rtconfig.py</li></ul><p>看着脚本文件很多，其实也不是太麻烦，只要参考已有的模板，该起来很容易的，那么接下来一个个来讲解吧</p><h2 id="bspstm32librarieshal_driverssconscript">bsp/stm32/libraries/HAL_Drivers/SConscript</h2><p>需要在这个文件中加入你的soc系列，按顺序排好，如图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librarieshal_driversdrv_config.h">bsp/stm32/libraries/HAL_Drivers/drv_config.h</h2><p>同上，加入你的soc系列</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librarieskconfig">bsp/stm32/libraries/Kconfig</h2><p>同上，加入你的soc系列</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librariesstm32f7xx_halsconscript">bsp/stm32/libraries/STM32F7xx_HAL/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\STM32F4xx_HAL\SConscript</span><br></pre></td></tr></table></figure><p>然后修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32stm32f767-fire-challengerkconfig">bsp/stm32/stm32f767-fire-challenger/Kconfig</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\Kconfig</span><br></pre></td></tr></table></figure><h2 id="bspstm32stm32f767-fire-challengersconscript">bsp/stm32/stm32f767-fire-challenger/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\SConscript</span><br></pre></td></tr></table></figure><h2 id="bspstm32stm32f767-fire-challengersconstruct">bsp/stm32/stm32f767-fire-challenger/SConstruct</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\SConstruct</span><br></pre></td></tr></table></figure><h2 id="bspstm32stm32f767-fire-challengerapplicationssconscript">bsp/stm32/stm32f767-fire-challenger/applications/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\applications\SConscript</span><br></pre></td></tr></table></figure><h2 id="bspstm32stm32f767-fire-challengerboardkconfig">bsp/stm32/stm32f767-fire-challenger/board/Kconfig</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\board\Kconfig</span><br></pre></td></tr></table></figure><p>不过需要修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32stm32f767-fire-challengerboardsconscript">bsp/stm32/stm32f767-fire-challenger/board/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\board\SConscript</span><br></pre></td></tr></table></figure><p>不过需要修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32stm32f767-fire-challengerrtconfig.py">bsp/stm32/stm32f767-fire-challenger/rtconfig.py</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32f7-disco\rtconfig.py</span><br></pre></td></tr></table></figure><p>我是从旧版BSP中找的，你也可以找找你对应型号的旧版BSP中的这个脚本</p><h2 id="之后这个templates中的脚本修改内容和前面基本一样的">之后这个<strong>templates</strong>中的脚本修改内容和前面基本一样的</h2><h2 id="bspstm32librariestemplatesstm32f7xxkconfig">bsp/stm32/libraries/templates/stm32f7xx/Kconfig</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\Kconfig</span><br></pre></td></tr></table></figure><h2 id="bspstm32librariestemplatesstm32f7xxsconscript">bsp/stm32/libraries/templates/stm32f7xx/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\SConscript</span><br></pre></td></tr></table></figure><h2 id="bspstm32librariestemplatesstm32f7xxsconstruct">bsp/stm32/libraries/templates/stm32f7xx/SConstruct</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\SConstruct</span><br></pre></td></tr></table></figure><h2 id="bspstm32librariestemplatesstm32f7xxapplicationssconscript">bsp/stm32/libraries/templates/stm32f7xx/applications/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\applications\SConscript</span><br></pre></td></tr></table></figure><h2 id="bspstm32librariestemplatesstm32f7xxboardkconfig">bsp/stm32/libraries/templates/stm32f7xx/board/Kconfig</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\board\Kconfig</span><br></pre></td></tr></table></figure><p>不过需要修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librariestemplatesstm32f7xxboardsconscript">bsp/stm32/libraries/templates/stm32f7xx/board/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\board\SConscript</span><br></pre></td></tr></table></figure><p>不过需要修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librariestemplatesstm32f7xxrtconfig.py">bsp/stm32/libraries/templates/stm32f7xx/rtconfig.py</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32f7-disco\rtconfig.py</span><br></pre></td></tr></table></figure><h1 id="修改驱动文件">修改驱动文件</h1><p>驱动文件分为：<strong>实现</strong>和<strong>配置</strong></p><p>实现是下面这个目录下的.c文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\HAL_Drivers</span><br></pre></td></tr></table></figure><p>配置是以下目录下的.h和部分.c文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\HAL_Drivers\config\fx</span><br><span class="line">bsp\stm32\libraries\HAL_Drivers\drv_flash</span><br><span class="line">bsp\stm32\stm32f767-fire-challenger\board\ports</span><br></pre></td></tr></table></figure><p>我们需要做的事就是根据开发板实际情况进行修改</p><h2 id="下面以移植uart为例子">下面以移植uart为例子</h2><p>先确认config文件是否符合开发板实际情况，同一个系列的MCU的移植不需要修改config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\HAL_Drivers\config\f7\uart_config.h</span><br></pre></td></tr></table></figure><p>根据HAL库的情况修改以下文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\HAL_Drivers\drv_usart.c</span><br></pre></td></tr></table></figure></p><p>例如f7系列，参照stm32f7xx_hal_uart.h，看看什么drv_usart.c中使用到的API是stm32f7xx_hal_uart.h中没有的，改为stm32f7xx_hal_uart.h有的接口，可以参考下面的方式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>还要注意一些寄存器是某些系列的产品特有的，要用宏定义区分，例如</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其他需要修改的地方都是差不多的，可以参考一下我的修改</p><p>在移植完驱动后，需要使用Cubemx启动外设，这部分请参考<a href="https://github.com/RT-Thread/rt-thread/blob/master/bsp/stm32/docs/BSP%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md#%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%89%87%E4%B8%8A%E8%B5%84%E6%BA%90%E9%80%89%E9%A1%B9" target="_blank" rel="noopener">如何添加更多的片上资源选项</a></p><p>不过串口1默认是开启的</p><h1 id="规范bsp">规范BSP</h1><p>这部分请参考<a href="https://github.com/RT-Thread/rt-thread/blob/master/bsp/stm32/docs/STM32%E7%B3%BB%E5%88%97BSP%E5%88%B6%E4%BD%9C%E8%A7%84%E8%8C%83.md" target="_blank" rel="noopener">STM32 系列 BSP 制作规范</a></p><p>移植到此结束，欢迎尝试</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近RT-Thread重构了stm32的BSP，看了一下，感觉很思路很清晰&lt;/p&gt;
    
    </summary>
    
    
      <category term="rt-thread" scheme="http://greedyhao.cc/tags/rt-thread/"/>
    
      <category term="stm32" scheme="http://greedyhao.cc/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>通信原理角度调制</title>
    <link href="http://greedyhao.cc/2018/12/08/%E5%B7%A5%E4%BD%9C-wireless-2018-12-08-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E8%A7%92%E5%BA%A6%E8%B0%83%E5%88%B6/"/>
    <id>http://greedyhao.cc/2018/12/08/工作-wireless-2018-12-08-通信原理角度调制/</id>
    <published>2018-12-08T15:32:39.000Z</published>
    <updated>2018-12-08T15:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="角度调制的两种方法">角度调制的两种方法</h1><a id="more"></a><p>一般表达式为</p><p><span class="math display">\[s(t)=A_c\cos[2\pi f_c t+\theta(t)]  \tag{1}\]</span></p><h2 id="fm与pm的表达式">FM与PM的表达式</h2><p>PM: 消息直接放在相位上</p><p><span class="math display">\[\begin{aligned}\theta(t) &amp;= K_p m(t) \\s_{PM}(t) &amp;= A_c\cos\left[2\pi f_c t + k_{PM} m(t)\right] \end{aligned} \tag{2}\]</span></p><p>FM: 消息直接放在角频率上</p><p><span class="math display">\[\begin{aligned}\frac{d\theta(t)}{dt} &amp;= K_f m(t)  \\\theta(t) &amp;= K_f\int m(t)dt  \\s_{FM}(t) &amp;= A_c\cos\left[2\pi f_c t + 2\pi k_{FM}\int m(t)dt\right]\end{aligned} \tag{3}\]</span></p><h2 id="fm与pm之间的联系">FM与PM之间的联系</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看出来，PM和FM是存在某种联系的，他们是相对的、关联的。</p><p>这是由于频率与相位之间存在微分与积分的关系，FM和PM之间是可以互相转换的。</p><ul><li>消息信号经过积分器再进入PM调制器可以得到FM信号</li><li>消息信号经过微分器再进入FM调制器可以得到PM信号</li></ul><h2 id="角度调制的优势">角度调制的优势</h2><p>他是恒幅波，不怕非线性失真，这解决了大功率放大器的非线性失真问题</p><h1 id="角度调制的基本参数">角度调制的基本参数</h1><h2 id="调制程度">调制程度</h2><p><strong>最大相偏</strong></p><p>联合(1)(2)(3)式，我们可以得到最大相偏<span class="math inline">\(\Delta \theta_{max}\)</span></p><p><span class="math display">\[\begin{aligned}&amp;PM:\ \ k_{PM}|m(t)|_{max} \\&amp;FM:\ \ 2\pi k_{FM}\left| \int m(t)dt\right|_{max}\end{aligned}\]</span></p><p><strong>最大频偏</strong></p><p>根据(3)式可以知道频率与相位之间存在微分积分的关系，因此我们可以得到角度调制的频率变化函数</p><p><span class="math display">\[PM:\ \ f_i (t) = f_c + \frac{1}{2\pi} \frac{d}{dt} \theta(t) \\FM:\ \ f_i (t) = f_c + k_{FM} m(t)\]</span></p><p>因此可以得到最大频偏<span class="math inline">\(\Delta f_{max}\)</span></p><p><span class="math display">\[\begin{aligned}&amp;PM:\ \ \frac{1}{2\pi} k_{PM}|m\prime (t)|_{max} \\&amp;FM:\ \ k_{FM}\left| m(t)dt\right|_{max}\end{aligned}\]</span></p><p>从上面的分析中，我们可以发现最大频偏/相偏正比于调制系数与消息信号的最大幅度</p><h2 id="正弦消息特例与调制指数">正弦消息特例与调制指数</h2><p>令消息信号m(t)如下</p><p><span class="math display">\[m(t) = a\cos(2\pi f_m t)\]</span></p><p>角度调制公式则如下</p><p><span class="math display">\[PM:\ \  s_{PM}(t) =  A_c\cos\left[2\pi f_c t +\beta \cos(2\pi f_m t) \right] \\\theta_{max} = k_{PM}a \\ \Delta f_{max} = f_m k_{PM}a  \\ \beta_{PM} = \Delta \theta_{max} \\FM:\ \  s_{FM}(t) = A_c\cos\left[2\pi f_c t + \beta \sin(2\pi f_m t) \right] \\\Delta f_{max} = k_{FM}a  \\ \beta_{FM} = \frac{\Delta f_{max}}{f_m} \\\]</span></p><p>调制指数是角度调制的基本参数之一，所以很重要，对于一般信号的定义如下</p><p><span class="math display">\[\beta = \frac{\Delta f_{max}}{B}\]</span></p><p>式中B为消息信号的带宽</p><h2 id="角度调制的信号带宽">角度调制的信号带宽</h2><h2 id="信号带宽">信号带宽</h2><p>角度调制信号的频谱无法用公式表示，不过他的带宽可以使用Carson公式计算得到，这个公式是通过对角度调制信号傅里叶系数分解得到的</p><p><span class="math display">\[B_T = 2\Delta f_{max} + 2B = 2(D+1)B\\D = \frac{\Delta f_{max}}{B}\]</span></p><p>式中的D为频偏比，也就是调制指数</p><h2 id="频谱特点">频谱特点</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从单音调频信号的频谱也再次验证了角度调制是非线性调制。而且也看得出FM调制会占用很宽的频带，但也正是因此，FM信号抗干扰、高质量。</p><p>实际生活中 + 宽带调频应用广泛 + 窄带调频应用较少</p><h1 id="角度调制的产生与接收">角度调制的产生与接收</h1><p>简单的说，角度调制就是将信号幅度上的变化转变为频率相位上的变化</p><h2 id="直接调频">直接调频</h2><p>直接调频是通过前文提到过的压控振荡器(VCO)实现的，VCO的振荡频率正比于输入控制电压</p><p><span class="math display">\[f_i (t) = f_c + k_{FM} m(t)\]</span></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>VCO可以通过LC振荡器实现，目前常用的电抗元件是变容二极管。但是这种直接调频的方法频率稳定性不好，不过可以通过使用PLL电路优化。因此，在早期的时候，直接调频的方法并不好用，主要使用的是间接调频的方法。</p><h2 id="间接调频">间接调频</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>间接调频使用的是阿姆斯特朗(Armstrong)法，它是先将消息信号积分，然后对载波调相，得到窄带调频(NBFM)信号，经过倍频得到宽带调频(WBFM)信号。上图就是他是系统框图</p><p>下面来解释他的原理</p><p>当<span class="math inline">\(\theta (t)\)</span>远小于1时，<span class="math inline">\(\cos\theta(t)\)</span>接近于1，<span class="math inline">\(\sin\theta(t)\)</span>接近于<span class="math inline">\(\theta(t)\)</span>；因为<span class="math inline">\(\theta(t)\)</span>很小，所以调制指数<span class="math inline">\(\beta=\Delta\theta_{max}\)</span>也就很小，因此这是一个<strong>窄带调频信号</strong>。</p><p>从系统框图我们可以看出，这个信号的产生是将消息信号m(t)通过积分器得到<span class="math inline">\(\theta(t)\)</span>，并将<span class="math inline">\(\theta(t)\)</span>控制得很小，再乘以cos信号反相得到的sin信号，最后再加上这个cos信号就得到了NBFM信号；由于这个NBFM信号不是理想的，所以还存在起伏，通过限幅器减小这种畸变；再经过倍频器和贷带通滤波器，得到WBFM。</p><h2 id="角度调制信号解调">角度调制信号解调</h2><p>解调是用和调制相反的方法，也就是将调制信号的疏密(频率相位)转换为幅度</p><p>先从数学上分析解调过程</p><p><span class="math display">\[s_{FM}(t) = A_c\cos\left[2\pi f_c t + K_f\int m(t)dt\right]\]</span></p><p>将其对t求微分</p><p><span class="math display">\[\frac{d s_{FM}(t)}{dt} = -A_c[2\pi f_c t + K_f m(t)]\sin\left[2\pi f_c t + K_f\int m(t)dt\right]\]</span></p><p>联系在AM中解调的方法，将包络提取出来，再去掉直流信号与高频载波信号，就得到m(t)信号了。</p><p>下面是解调的系统框图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在包络检波时，如果使用单调谐回路存在线性度差、线性范围较小的问题，而且还存在直流分量，虽然可以使用电容隔离直流，但是也有可能对低频信号产生损失；为了改进包络检波的电路，可以使用双调谐互补电路，在线性度好的同时，还没有直流成分的存在。</p><h2 id="篇外话">篇外话</h2><p>无论是发送还是接收，现代流行的技术方案都是采用基带处理与正交调制相结合的方案。</p><p>基带处理可以用DSP FPGA方便灵活实现各种调制方案</p><h1 id="噪声分析">噪声分析</h1><p>无论什么系统，在通过信道传输后总会被噪声干扰，只有了解噪声才能降低噪声的干扰，下面开始对噪声的分析</p><ul><li>如何分析</li><li>解调增益 系统增益</li><li>各种调制方法性能</li></ul><h2 id="噪声分析方法">噪声分析方法</h2><p><strong>基带传输中的噪声</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一般情况下，噪声都可以简化为高斯白噪声信号</p><p>去除噪声的方法就是使用一个和调制信号带宽相同的理想滤波器滤除噪声，不过调制信号带宽内的噪声无法去除</p><p>我们使用信噪比(SNR)来度量消息的质量</p><p>高斯白噪声是平坦的，通过低通滤波器后还是平坦的，因此噪声信号功率可以通过噪声信号的面积得到</p><p><span class="math display">\[SNR_o = \frac{P_m}{P_{n_o}} = \frac{\overline{m^2(t)}}{N_o B}\]</span></p><p><strong>频带传输中的噪声</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在频带分析中会涉及到调制解调，解调可能会使得消息信号发生变化，所以无法得知调制信号和残留噪声的具体值，因此SNR的分析就不是那么简单了，就需要更细致的分析</p><ul><li>针对具体解调方法分析</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>ENV指包络的意思</p><ul><li>将具体信号带入分析</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="解调增益和系统增益">解调增益和系统增益</h2><p><strong>解调增益</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个表中有列举几种调制的解调增益，输入SNR比较容易获得，我们可以通过解调增益和输入SNR求得输出SNR</p><p><strong>系统增益</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将基带传输信噪比与频带传输信噪比对比，得到系统增益，通过系统增益衡量频带传输系统的好坏</p><p>通过推导可以得到系统增益与解调增益之间的关系如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>下面这个表列举了几种调制的系统增益</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过系统增益可以直接比较不同系统的性能</p><h2 id="各种调制性能比较">各种调制性能比较</h2><p><strong>模拟调制性能指标</strong></p><ul><li>可靠性 输出信号的信噪比</li><li>有效性 占用的带宽</li></ul><p><strong>各种调制系统的性能比较</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>比较结论</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="参考资料">参考资料：</h1><ul><li><a href="http://www.icourse163.org/learn/UESTC-238011?tid=1003260003#/learn/content" target="_blank" rel="noopener">通信原理 电子科技大学 中国大学MOOC</a></li><li><a href="http://wzzjzxx.com:8081/Media/2011/05/09/49b31ce5-8019-49cb-8a06-6a7a279f151b/65c0473b-61d1-4ccf-9c93-5bd89de4bb87.doc" target="_blank" rel="noopener">模拟调制系统</a></li><li><a href="http://101.96.10.63/www.eie.polyu.edu.hk/~em/cf03pdf/9%20FM2.pdf" target="_blank" rel="noopener">FM – Generation and Detection</a></li><li><a href="https://www.tutorialspoint.com/analog_communication/analog_communication_fm_modulators.htm" target="_blank" rel="noopener">Analog Communication FM Modulators - Tutorialspoint</a></li><li><a href="https://www.radio-electronics.com/info/rf-technology-design/fm-reception/fm-demodulation-detection-overview.php" target="_blank" rel="noopener">FM Demodulation / Detection Tutorial</a></li><li><a href="http://www.chinabaike.com/t/35816/2014/0623/2536846.html" target="_blank" rel="noopener">微分法鉴频器原理电路知识</a></li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;角度调制的两种方法&quot;&gt;角度调制的两种方法&lt;/h1&gt;
    
    </summary>
    
    
      <category term="wireless" scheme="http://greedyhao.cc/tags/wireless/"/>
    
  </entry>
  
  <entry>
    <title>通信原理线性调制</title>
    <link href="http://greedyhao.cc/2018/11/29/%E5%B7%A5%E4%BD%9C-wireless-2018-11-29-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%BA%BF%E6%80%A7%E8%B0%83%E5%88%B6/"/>
    <id>http://greedyhao.cc/2018/11/29/工作-wireless-2018-11-29-通信原理线性调制/</id>
    <published>2018-11-29T14:41:19.000Z</published>
    <updated>2018-12-08T15:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模拟线性调制">模拟线性调制</h1><a id="more"></a><h2 id="常规调幅-am">常规调幅 AM</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/am_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>AM 调制是一种线性调制，它的作用是将基带信号转变为调制信号。之所以调制的原因在上一篇文章说了，天线的长度要不短于信号的波长的1/10，这是为了阻抗匹配，具体原因在电磁波相关的书籍有介绍。</p><p>从图中不难看出，AM调制是一个很简单的调制方式，简单的只需要一个乘法器和一个加法器就可以完成。</p><p><strong>频谱特点</strong></p><ol type="1"><li>频带信号：位于载频fc，带宽BT = 2B</li><li>上下两个边带</li><li>+-fc处有两个冲激，有纯载波</li></ol><p><strong>波形特点</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/am_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>消息突显在载波包络上</p><p>通过调节消息信号的幅度，可以调节调幅指数，从而调节调制强度。调幅指数的定义如下</p><p><span class="math display">\[\begin {aligned}\beta_{AM} &amp;= \frac{max[s_{AM}(t)]-A_c}{A_c} \\&amp;= max|m(t)|\end {aligned}\]</span></p><p>不过调幅指数不能大于1，否则会发生上图中的过调制情况；过调制会导致承载消息的已调波变形，使得消息错误。</p><p><strong>发送与接收</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/am_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>发送使用的是一个乘法器与一个加法器的组合</p><p>接收端使用的是包络检波器，基本原理是：正弦波上升时，二极管正向导通给电容充电，正弦波下降时二极管截止，电容放电；通过电容的充放电就可以展示出消息信号的波形。</p><p>包络检波器的R C选值需要考虑输入信号的频率和载波的频率</p><p><strong>功率与效率</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/am_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>功率就是已调信号的平方的平均值</p><p>效率就是消息信号的功率比上总功率。使用正弦信号时，峰均功率比PARPm(t)最低，效率也只有33.3%，由此可以看出AM调制效率的低。</p><h2 id="抑制载波双边带调幅-dsb">抑制载波双边带调幅 DSB</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/dsb_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>DSB调制和AM调制信号很类似，频域上的特性基本相同，不过在fc处没有了冲激，而且DSB调制信号在时域上有一个反向点。</p><p>DSB调制效率为1</p><p><strong>接收方法</strong></p><p>包络没有直接直接呈现消息信号，所以无法使用包络检波器</p><p>可以通过乘以同频同相正弦函数调制回基频</p><p><span class="math display">\[\begin {aligned}&amp;S_{DSB} \times \cos 2\pi f_c t \\&amp;= A_c m(t) \cos^2 2\pi f_c t \\&amp;= A_c m(t) \frac{1+\cos 4\pi f_c t}{2}\end {aligned}\]</span></p><p>分析公式可以知道，乘以一个同频同相正弦信号的结果就是会产生基频信号和4倍基频信号，再同过一个低通滤波器就可以得到我们想要的原信号了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/dsb_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>乘法解调器的示意图如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/dsb_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>同步问题</strong></p><p>前面说了使用乘法解调器需要同频同相的正弦波，但是发射端和接收端一般都有一定的距离，很难保证频率相同。</p><p>为了保证接收端的本振和发射端的震荡频率相同，使用锁相环(PLL)做一个可控振荡器，通过比较接收到的DSB信号的频率来产生相同的频率</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/dsb_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="单边带调制-ssb">单边带调制 SSB</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>傅里叶变换的性质，信号的共轭等于原信号的频域信号的取反。而实信号的共轭等于它本身，因此可以推导出信号的频域共轭对称</p><p>因此可以去掉DSB调制的一半的带宽，但是自然界中只存在实信号，也就是说+-fc处都要有频带，因此只有两种单边带调制方式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>接收方法</strong></p><p>接收方法可以通过相干解调，解调过程图示如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>SSB调制信号的时域公式比较复杂，先搁置</p><p>SSB调制信号还可以通过增加载波分量的方法，可以实现包络检波</p><h2 id="残留边带调幅-vsb">残留边带调幅 VSB</h2><p>前面讲的SSB是理想情况下的，实现SSB需要非常陡峭的滤波器，这在显示中是不存在的；因此，为了能够实现这个滤波器，就加大了滤波器的过渡带，不过过渡带形状必须要对称互补</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/vsb_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="相移法生成单边带">相移法生成单边带</h2><p>前文讲的SSB VSB都是在频域进行滤波生成的单边带，接下来讲一个在现代使用的更多的相移法，尤其是在生成高频率的单边带时。</p><p>相移法是在时域处理的，所以需要在时域讨论SSB</p><p>目前我们知道的是，DSB的时域表达式</p><p>设调制信号为</p><p><span class="math display">\[m(t) = A_m\cos\omega_m t\]</span></p><p>载波为</p><p><span class="math display">\[c(t) = \cos\omega_c t\]</span></p><p>则DSB表达式为</p><p><span class="math display">\[\begin {aligned}s_{DSB}(t) &amp;= A_m \cos\omega_m t\cos\omega_c t \\&amp;= \frac{1}{2} A_m \cos (\omega_c+\omega_m)t + \frac{1}{2} A_m \cos (\omega_c-\omega_m)t\end {aligned}\]</span></p><p>保留上边带则有</p><p><span class="math display">\[\begin {aligned}s_{USB}(t) &amp;= \frac{1}{2} A_m \cos (\omega_c+\omega_m)t \\&amp;= \frac{1}{2}A_m \cos\omega_m t\cos\omega_c t-\frac{1}{2}A_m \sin\omega_m t\sin\omega_c t\end {aligned}\]</span></p><p>保留下边带则有</p><p><span class="math display">\[\begin {aligned}s_{LSB}(t) &amp;= \frac{1}{2} A_m \cos (\omega_c-\omega_m)t \\&amp;= \frac{1}{2}A_m \cos\omega_m t\cos\omega_c t+\frac{1}{2}A_m \sin\omega_m t\sin\omega_c t\end {aligned}\]</span></p><p>综合起来</p><p><span class="math display">\[\begin {aligned}s_{SSB}(t) &amp;= \frac{1}{2}m(t)\cos\omega_c t-\frac{1}{2}\hat{m}(t)\sin\omega_c t\end {aligned}\]</span></p><p>式中<span class="math inline">\(\hat{m}(t)\)</span>为希尔伯特变换，相当于正弦信号相移pi/2</p><p>为了验证SSB时域表达式的正确性，我们可以从频域进行分析</p><p><span class="math display">\[\begin {aligned}S_{SSB}(f) &amp;= \frac{M(f-f_c)+M(f+f_c)}{2} - \frac{-j\hat{M}(f-f_c)-j\hat{M}(f+f_c)}{2}\end {aligned}\]</span></p><p>希尔伯特变换的相关信息如下</p><p><span class="math display">\[\begin {aligned}&amp;\hat{m}(t) = m(t)*\frac{1}{\pi t} \\&amp;\hat{M}(f) = M(f)x[-j sgn(f)]\\&amp;j\hat{M}(f) = -j^2 M(f)sgn(f)\\\end {aligned}\]</span></p><p>在频域中，做希尔伯特变换相当于乘以了一个符号函数，SSB过程图示如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>接下来就是根据时域表达式实现相移法</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模拟线性调制&quot;&gt;模拟线性调制&lt;/h1&gt;
    
    </summary>
    
    
      <category term="wireless" scheme="http://greedyhao.cc/tags/wireless/"/>
    
  </entry>
  
  <entry>
    <title>51总线方式获取adc0809数值</title>
    <link href="http://greedyhao.cc/2018/11/27/%E5%B7%A5%E4%BD%9C-mcu-51-2018-11-27-51%E6%80%BB%E7%BA%BF%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96adc0809%E6%95%B0%E5%80%BC/"/>
    <id>http://greedyhao.cc/2018/11/27/工作-mcu-51-2018-11-27-51总线方式获取adc0809数值/</id>
    <published>2018-11-27T13:32:55.000Z</published>
    <updated>2018-11-27T13:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近单片机有一个实验挺有意思的，使用51单片机以总线的方式读取adc0809的数据</p><p>先补充点关于单片机总线的预备知识，我一开始不了解总线的时候做这个实验也是很懵逼的。</p><h1 id="单片机的三总线结构">单片机的三总线结构</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/51/51bus_arch.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>51单片机有三条总线：数据总线、地址总线、控制总线</p><p>从图中可以看出，8位数据总线由P0组成，16位地址总线由P0和P2组成，控制总线由P3和相关引脚组成</p><p>采用总线的方式可以简化编程，节省I/O口，便于外设扩展</p><p>但是数据口和地址口在P0是怎么复用的呢，这就需要看到时序了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/51/51bus_seq.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看出，P0口是数据/地址分时复用的，这是P0口内部的复用结构完成的</p><h1 id="实操练习">实操练习</h1><p>51单片机与adc0809接线原理图如下 <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/51/51bus_sch.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="解释电路">解释电路</h2><p>P2.7口用作adc0809的选择线</p><p>P0.0~P0.2所接的A B C是adc0809的IN0通道选择线</p><p>接下来就是计算adc0809的地址了</p><p>P2 P0</p><p>0xxx xxxx xxxx x000</p><p>因此地址为0x7ff8</p><h2 id="遇到的问题">遇到的问题</h2><p>本来应该显示5v的位置只显示1.144v，而且在电阻增大的过程中，显示的值先减小后增大又减小，具体情况如图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/51/51bus_err_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/51/51bus_err_1.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>实在没有办法的情况下，借别的同学的代码来看，没发现自己的程序在时序、地址上的错误。</p><p>琢磨了单片机的数值变换的现象后，突然觉得是不是保存ad转换数值的变量溢出了，然后就发现我的变量类型是int，而别人的变量类型是long int</p><p>在将保存ad转换的变量类型修改过后，程序就运行正常了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/51/51bus_err_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="程序代码">程序代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;absacc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> uint16;</span><br><span class="line"></span><br><span class="line">uchar led_mod[] = &#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="comment">//!&lt; 数码管编码</span></span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line"><span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AD_IN0 XBYTE [0x7ff8]</span></span><br><span class="line"></span><br><span class="line">sbit EOC = P3^<span class="number">5</span>;</span><br><span class="line">sbit CLK = P3^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">sbit seg1 = P2^<span class="number">0</span>;</span><br><span class="line">sbit seg2 = P2^<span class="number">1</span>;</span><br><span class="line">sbit seg3 = P2^<span class="number">2</span>;</span><br><span class="line">sbit seg4 = P2^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">uint16 adc_data = <span class="number">0</span>;    <span class="comment">//&gt; 保存ad转换结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 延迟函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_ms</span><span class="params">(uint8 time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint8 j;</span><br><span class="line">    <span class="keyword">for</span> (; time&gt;<span class="number">0</span>; time--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">114</span>; j&gt;<span class="number">0</span>; j--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器初始化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TMOD |= <span class="number">0x02</span>;</span><br><span class="line">TH0 = <span class="number">200</span>;<span class="comment">//&gt; 产生方波周期2us</span></span><br><span class="line">TL0 = <span class="number">200</span>;</span><br><span class="line">                                       </span><br><span class="line">ET0 = <span class="number">1</span>;                                      </span><br><span class="line">TR0 = <span class="number">1</span>;                                      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 数码管动态显示函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">adc_data = adc_data*<span class="number">1000</span>/<span class="number">51</span>;<span class="comment">//&gt; 分辨率为5/256约为1/51</span></span><br><span class="line">P1 = <span class="number">0x00</span>;</span><br><span class="line">P1 = led_mod[adc_data/<span class="number">1000</span>]|<span class="number">0x80</span>;</span><br><span class="line">seg1 = <span class="number">0</span>;</span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line">seg1 = <span class="number">1</span>;</span><br><span class="line">P1 = <span class="number">0x00</span>;</span><br><span class="line">P1 = led_mod[(adc_data%<span class="number">1000</span>)/<span class="number">100</span>];</span><br><span class="line">seg2 = <span class="number">0</span>;</span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line">seg2 = <span class="number">1</span>;</span><br><span class="line">P1 = <span class="number">0x00</span>;</span><br><span class="line">P1 = led_mod[(adc_data%<span class="number">100</span>)/<span class="number">10</span>];</span><br><span class="line">seg3 = <span class="number">0</span>;</span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line">seg3 = <span class="number">1</span>;</span><br><span class="line">P1 = <span class="number">0x00</span>;</span><br><span class="line">P1 = led_mod[adc_data%<span class="number">10</span>];</span><br><span class="line">seg4 = <span class="number">0</span>;</span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line">seg4 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">timer_init();</span><br><span class="line">EA = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">AD_IN0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(EOC == <span class="number">0</span>);</span><br><span class="line">adc_data = AD_IN0;</span><br><span class="line">display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 产生时钟周期</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0</span><span class="params">()</span> interrupt 1                   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CLK = ~CLK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近单片机有一个实验挺有意思的，使用51单片机以总线的方式读取adc0809的数据&lt;/p&gt;
&lt;p&gt;先补充点关于单片机总线的预备知识，我一开始不了解总线的时候做这个实验也是很懵逼的。&lt;/p&gt;
&lt;h1 id=&quot;单片机的三总线结构&quot;&gt;单片机的三总线结构&lt;/h1&gt;
&lt;figure 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rt-thread内核移植</title>
    <link href="http://greedyhao.cc/2018/11/25/%E5%B7%A5%E4%BD%9C-rt-thread-2018-11-25-rt-thread%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D/"/>
    <id>http://greedyhao.cc/2018/11/25/工作-rt-thread-2018-11-25-rt-thread内核移植/</id>
    <published>2018-11-25T12:07:37.000Z</published>
    <updated>2018-11-25T12:19:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享一下我参加rtt培训的内容吧</p><a id="more"></a><h1 id="rt-thread-nano版移植">rt-thread nano版移植</h1><h2 id="让内核运转起来">让内核运转起来</h2><p>移植选用的是rt-thread nano版，这次的移植的乞丐版，rt-thread的组件都没有移植，只有最基本的内核。</p><p>为了简单，参考了rtt提供的模板移植。我这块板是stm32f767的，和提供的模板使用的m4不一样，所以要做一些修改。</p><p>首先是创建工程，按照模板添加工程文件，配置好魔法棒中的c/c++参数，之后就开始移植了。</p><ol type="1"><li>将下载好的rt-thread nano版的src添加到工程中，由于这里不使用rtt的组件，所以rt-thread</li><li>修改时钟，找到SystemClock_Config的实现，按照自己板子的实际情况对时钟进行修改，这里的需要用到uasrt1，所以我就在这里初始化了uasrt1的时钟。</li><li>按照板子的实际情况，在board.c中实现led、uart的bsp</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/porting_rtt_1_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/porting_rtt_1_2.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="实现os-tick">实现OS Tick</h2><p>此时main中使用的delay还是通过空循环实现的，为了使用内核的rt_thread_delay，还需要实现OS Tick来给RTOS提供时间节拍，ARM Cortex-M提供了一个定时器Systick，这个定时器的时钟来源于系统时钟，会周期性的溢出，一般RTOS都是使用Systick来提供OS Tick</p><ol type="1"><li>实现SysTick_Handler，让mcu在Systick定时器溢出时给os tick的值加1，在加os tick时需要关闭中断</li><li>rt_hw_board_init中给Systick初始化</li><li>更换main.c中的_delay为rt_thread_delay</li></ol><p>效果和前面相同</p><h2 id="实现控制台打印">实现控制台打印</h2><p>调试设备少不了串口打印设备信息，rt-thread中提供了rt_kprintf来打印设备信息。进入到rt_kprintf的实现中看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_kprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_DEVICE</span></span><br><span class="line">    …</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    rt_hw_console_output(rt_log_buf);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出rt_kprintf的实现有分情况的，如果有显示设备就在显示设备上输出，没有就通过rt_hw_console_output在控制台输出</p><p>rt_thread的rt_hw_console_output是弱定义，所以需要用户自己实现</p><p>前面实现了串口输出，因此可以直接使用bsp_uart_send作为控制台输出</p><p>此时效果如下: <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/porting_rtt_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="实现动态内存">实现动态内存</h2><p>线程的创建是需要动态内存的，rt-thread使用rtconfig.h来控制RTOS的各个功能的开关；要想使用动态内存首先需要在rtconfig.h中打开动态内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_USING_HEAP </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_USING_SMALL_MEM</span></span><br></pre></td></tr></table></figure><p>然后需要在rt_hw_board_init中使用rt_system_heap_init对动态内存堆初始化</p><p>在main.c中创建一个线程测试rt_kprintf</p><p>效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/porting_rtt_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><a href="https://github.com/greedyhao/rt-thread/tree/master/stm32f767-rt-thread-nano" target="_blank" rel="noopener">此工程的代码地址</a></p><h1 id="使用env">使用env</h1><p>我的板子是stm32f767，在bsp中找到了一个stm32f7-disco的移植，就拿来用了。修改了一下工程配置，发现串口管脚都相同，就关掉sdram直接用了</p><p>效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/porting_rtt_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><a href="https://github.com/greedyhao/rt-thread/tree/master/stm32f767-fire" target="_blank" rel="noopener">此工程的代码地址</a></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享一下我参加rtt培训的内容吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="rt-thread" scheme="http://greedyhao.cc/tags/rt-thread/"/>
    
      <category term="stm32" scheme="http://greedyhao.cc/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>通信原理导学</title>
    <link href="http://greedyhao.cc/2018/11/25/%E5%B7%A5%E4%BD%9C-wireless-2018-11-25-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AF%BC%E5%AD%A6/"/>
    <id>http://greedyhao.cc/2018/11/25/工作-wireless-2018-11-25-通信原理导学/</id>
    <published>2018-11-25T11:02:18.000Z</published>
    <updated>2018-11-25T12:15:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下是我在中国大学mooc学习通信原理所做笔记</p><a id="more"></a><h1 id="通信系统主要指标">通信系统主要指标</h1><table><tbody><tr class="odd"><td>信息</td><td>内涵</td></tr><tr class="even"><td>消息</td><td>信息的载体</td></tr><tr class="odd"><td>信号</td><td>消息的载体</td></tr></tbody></table><p>消息分为数字消息、模拟消息</p><p>数字消息的基本指标： + N元 + RB码元传输速率 Rb信息传输速率</p><p>细节描述： + 符号集 + 概率</p><p>数字通信系统的基本指标 + 传输效率 Rb + 传输质量 误码率Pe 误信率Pb</p><p>模拟消息的基本指标 + 频谱带宽</p><h1 id="信道">信道</h1><h2 id="基本问题">基本问题</h2><ul><li>信号衰减 导线电阻</li><li>加性噪声 热噪声</li></ul><h2 id="其他问题">其他问题</h2><ul><li>外来干扰</li><li>信号畸变 信道特性不理想导致信号通过后变形</li></ul><p>信号畸变的例子：电话线过长，寄生电容变大，高频信号衰减，影响语音信号</p><h1 id="信道问题">信道问题</h1><p>加性噪声主要是热噪声，热噪声主要是高斯白噪声 + 时域上 随机性服从高斯分布 + 频域上 噪声均匀分布在所有频率上</p><p>AWGN信道模型——加性高斯白噪声信道模型</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="AWGN.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="电磁波">电磁波</h1><p>天线不短于电磁波波长的1/10</p><p>波长——电波在一次震荡里行进的距离</p><p>波长=光速/频率</p><h1 id="电磁波传输途径">电磁波传输途径</h1><ul><li>地波 1-2MHz 传输几十公里 主要用于AM、海事广播</li><li>天波 3-30MHz 长距离传输 被电离层反射 短波信道是时变的</li><li>视距 高于30MHz 穿透电离层 需要中继</li></ul><h1 id="电磁波管理">电磁波管理</h1><p>频分复用/频分多址(FDN/FDMA) + 频分复用 有线通信中多个话音&quot;错开频率&quot;共用一条电线传输 + 频分多址 多个无线用户&quot;使用各自频率&quot;同时接入通信系统 + 频分双工 每个用户&quot;采用不同频率&quot;接收与发送，两个方向同时传输</p><h1 id="基带与频带传输">基带与频带传输</h1><ul><li>基带信号 零频率附近</li><li>频带信号 某高频附近</li></ul><h2 id="模拟通信系统">模拟通信系统</h2><p>主要使用频带传输</p><p>核心为 + 调制 + 解调</p><p>调制</p><p>用正弦波(载波)携带消息 + 幅度调制 + 角度调制</p><h2 id="数字通信系统">数字通信系统</h2><p>基本功能 + 格式化 规范化的数字符号序列 + 基带调制 新成合适的电信号，基带信号通常是用脉冲生成 + 频带调制 转换为频带信号 + 同步</p><p>高级功能 + 信源编码 压缩编码 + 加密 + 信道编码 加入特殊数据位(奇偶校验位)，以便接收端发现与纠错 + 复用 + 多址接入 + 频谱扩展</p><h1 id="数字相对于模拟通信系统的优势">数字相对于模拟通信系统的优势</h1><ul><li>抗噪性 数字信号不容易被噪声干扰，长距离传输可以通过中继的方式避免噪声干扰</li><li>标准性<ul><li>各种消息可以混杂 复用、多媒体</li><li>消息汇集与中转 多址接入、路由与交换、互联网</li><li>消息与通信系统分离</li></ul></li><li>实现性</li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是我在中国大学mooc学习通信原理所做笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="wireless" scheme="http://greedyhao.cc/tags/wireless/"/>
    
  </entry>
  
  <entry>
    <title>另一种模拟傅里叶变换的方式</title>
    <link href="http://greedyhao.cc/2018/11/24/%E5%B7%A5%E4%BD%9C-dsp-2018-11-24-%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://greedyhao.cc/2018/11/24/工作-dsp-2018-11-24-另一种模拟傅里叶变换的方式/</id>
    <published>2018-11-24T14:02:50.000Z</published>
    <updated>2018-11-24T14:08:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是好久之前写的，忘记发了，另一种模拟傅里叶变换的方式。相关阅读：<a href="http://greedyhao.cc/2018/10/21/%E5%B7%A5%E4%BD%9C-dsp-2018-10-21-Matlab%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/">Matlab模拟傅里叶变换</a></p><a id="more"></a><h1 id="前言">前言</h1><p><a href="http://greedyhao.cc/2018/10/21/%E5%B7%A5%E4%BD%9C-dsp-2018-10-21-Matlab%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/">前文</a>进行了傅里叶变换的分析，以及在Matlab上模拟傅里叶变换，但是使用的是矩阵向乘法，这里提供另外一种模拟的方法。</p><h1 id="解决方法">解决方法</h1><p>我就是在<a href="https://www.csun.edu/~skatz/ece460/matlab_tut_two.pdf" target="_blank" rel="noopener">Evaluating Fourier Transforms with MATLAB</a>这篇文章中找到答案的。</p><p>我发现在这篇文章中，使用了一个Matlab built-in function---trapz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">help</span> trapz</span><br><span class="line"> trapz  Trapezoidal numerical integration.</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>简单来说，这个函数的作用是做积分，之前没有使用这个函数的时候，使用的就是求和的方法，也不知道之前的方法对复指数信号不适合的原因是不是求和导致了信息丢失。</p><p>下面进入主题</p><h1 id="分析与实现">分析与实现</h1><p>首先还是看到傅里叶变换上来</p><p><span class="math display">\[X_a(j\Omega)=\int x_a(t)e^{-j\Omega t}dt\]</span></p><p>思路很清晰，就是对<span class="math inline">\(x_a(t)e^{-j2\pi ft}\)</span>积分而已</p><p>我们需要使用到的trapz的更详细的描述如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q = trapz(X,Y) 根据 X 指定的坐标或标量间距对 Y 进行积分。</span><br><span class="line">如果 X 是坐标向量，则 length(X) 必须等于 Y 的大小不等于 1 的第一个维度的大小。</span><br><span class="line">如果 X 是标量间距，则 trapz(X,Y) 等于 X*trapz(Y)。</span><br></pre></td></tr></table></figure><p>根据文档，使用trapz(X,Y)时，让X为t，Y为积分部分就行</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trapz(t,x.*<span class="built_in">exp</span>(-<span class="built_in">j</span>*<span class="number">2</span>*<span class="built_in">pi</span>*f*t))</span><br></pre></td></tr></table></figure><h2 id="一个简单的trapz例子">一个简单的trapz例子</h2><p>接下来就使用trapz来做一个简单的函数的变换</p><p><span class="math display">\[X(jf)=\int^2_2 1e^{-j2\pi f} dt\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">t=<span class="number">-2</span>:<span class="number">.01</span>:<span class="number">2</span>;</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> f=<span class="number">-5</span>:<span class="number">.01</span>:<span class="number">5</span></span><br><span class="line">    k=k+<span class="number">1</span>;</span><br><span class="line">    X(k)=trapz(t,<span class="built_in">exp</span>(-<span class="built_in">j</span>*<span class="number">2</span>*<span class="built_in">pi</span>*f*t));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f=<span class="number">-5</span>:<span class="number">.01</span>:<span class="number">5</span>;</span><br><span class="line"><span class="built_in">plot</span>(f,X)</span><br></pre></td></tr></table></figure><p>效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/ctft_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这是对一个非周期脉宽信号的变换，得到的结果是我们很熟悉的sinc信号，而且结果是符合理论的。</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是好久之前写的，忘记发了，另一种模拟傅里叶变换的方式。相关阅读：&lt;a href=&quot;http://greedyhao.cc/2018/10/21/%E5%B7%A5%E4%BD%9C-dsp-2018-10-21-Matlab%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/&quot;&gt;Matlab模拟傅里叶变换&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="DSP" scheme="http://greedyhao.cc/tags/DSP/"/>
    
      <category term="Matlab" scheme="http://greedyhao.cc/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>18年11月总结</title>
    <link href="http://greedyhao.cc/2018/11/24/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2018-11-24-18%E5%B9%B411%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>http://greedyhao.cc/2018/11/24/学习总结-2018-11-24-18年11月总结/</id>
    <published>2018-11-24T14:02:13.000Z</published>
    <updated>2018-11-24T14:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有点飘，尝试了一下小说，没想到会难以自拔，准备重新改变看小说这个习惯中。</p><p>表面上小说好像带来了一些冷门的知识，但事实上浪费的时间比想象中的多，搞到我连博客都不想写了，所以还是得改。</p><p>下面进入主题，介绍一下最近接触的东西。</p><h1 id="rt-thread">RT-Thread</h1><p>之前报名参加了rtt的大学生培训活动，目前已经进行到了内核移植阶段。</p><p>培训内容是从熟悉内核开始的，先后学习了线程的创建启动、各种线程间通信同步的方式。我看了看野火的rtt的书，从目录来看，两者的教程很相似，由于对两者的接触很浅，所以具体的异同还要细看后才好说。</p><p>就我目前见识到的，各种操作系统的基本功能都差不多，都有对线程的操作、线程间通信、内存管理等功能，不过具体实现各有特点。</p><h1 id="dsp">DSP</h1><p>幅值、相位、实部、虚部是不一样的，可惜我学了很久直到不就前才注意到，之前在画频谱时，只知道要用abs取绝对值，但不知道为什么；不过后来慢慢知道频域中一般研究的是幅值和相位，实部和虚部的研究在时域中出现的比较多。</p><h1 id="通信原理">通信原理</h1><p>通信原理是我目前最头疼的一门学科了，这个月感觉根本没有学到什么...不过这也主要和我这个月态度太差了有关，既然之前没有学好，只能现在开始补了</p><h1 id="对下个月的打算">对下个月的打算</h1><p>首先是会尽快将这周的rtt培训任务完成，任务需要将rtt内核移植到自己的开发板上，我准备先使用rtt nano版的移植，再做env的移植。目前还没有对rtt在linux上的编译链接了解太多，准备到时候使用Truestudio开发吧。</p><p>然后自然就是学习数字信号处理和通信原理了，毕竟专业学科不能落下，这两门学科学起来还是不容易。</p><p>接下来我会改变目前的状态，只要有点所得就写下发出来，就当是给自己动力把。</p><h1 id="专业词汇">专业词汇</h1><ul><li>Finite-duration impulse response (FIR)</li><li>Infinite-duration impulse response (FIR)</li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有点飘，尝试了一下小说，没想到会难以自拔，准备重新改变看小说这个习惯中。&lt;/p&gt;
&lt;p&gt;表面上小说好像带来了一些冷门的知识，但事实上浪费的时间比想象中的多，搞到我连博客都不想写了，所以还是得改。&lt;/p&gt;
&lt;p&gt;下面进入主题，介绍一下最近接触的东西。&lt;/p&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="总结" scheme="http://greedyhao.cc/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Matlab模拟傅里叶变换</title>
    <link href="http://greedyhao.cc/2018/10/21/%E5%B7%A5%E4%BD%9C-dsp-2018-10-21-Matlab%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <id>http://greedyhao.cc/2018/10/21/工作-dsp-2018-10-21-Matlab模拟傅里叶变换/</id>
    <published>2018-10-21T07:45:09.000Z</published>
    <updated>2018-11-22T07:55:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>傅里叶变换是我们最早开始接触的时频域变换方法，虽然经常使用，知道怎么用纸笔计算，但是还从来没有在电脑中模拟过，正好现在开始学习数字信号处理，借着这个机会再学习如何在电脑上模拟傅里叶变换。</p><a id="more"></a><blockquote><p>以下大部分内容来自<em>Digital Signal Processing Using Matlab</em>和<em>数字信号处理教程 程佩青</em></p></blockquote><p>此次选择的软件平台为Matlab。</p><p>由于Matlab无法处理无限长序列，所以需要处理的信号必须是有限长的。</p><h1 id="连续时间傅里叶变换">连续时间傅里叶变换</h1><p>傅里叶变换的公式为：</p><p><span class="math display">\[X_a(j\Omega)=\int x_a(t)e^{-j\Omega t}dt\]</span></p><p>为了在计算机中模拟傅里叶变换，我们将积分变为求和的方式，上下限也从正无穷到负无穷变为一段长度M，dt需要尽可能小</p><p><span class="math display">\[X_a(j\Omega) = \sum_m x_a(m\Delta t)e^{-j\Omega m\Delta t}\Delta t\]</span></p><p>在Matlab中，函数的自变量因变量的集合都是使用矩阵来存储的，从矩阵的角度来看傅里叶变换的公式如下：</p><p><span class="math display">\[[X_a(0)\ X_a(1)\ X_a(2)\ ..] = [x_a(0)\ x_a(1)\ x_a(2)\ ..]\left[\begin{matrix} e^{-j\omega_0 t_0} &amp; e^{-j\omega_1 t_0} &amp; \cdots &amp; e^{-j\omega_K t_0}      \\ e^{-j\omega_0 t_1} &amp; e^{-j\omega_1 t_1} &amp; \cdots &amp; e^{-j\omega_K t_1}      \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ e^{-j\omega_0 t_N} &amp; e^{-j\omega_1 t_N} &amp; \cdots &amp; e^{-j\omega_K t_N}      \\\end{matrix}\right]\]</span></p><p>角频率向量定义为<span class="math inline">\(\omega=[\omega_0\ \omega_1\ ...\ \omega_K]\)</span></p><p>时间向量定义为<span class="math inline">\(t=[t_0 :\Delta t: t_N]\)</span></p><p>因此矩阵指数可写为<span class="math inline">\(-j*t&#39;*\omega\)</span></p><p>整个傅里叶变换可写为 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xa = xa * <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">j</span>*t'*W) * Dt;</span><br></pre></td></tr></table></figure></p><h2 id="具体实现">具体实现</h2><p>其实下面这个例子是<em>Digital Signal Processing Using Matlab</em>中的，来自P64页，不过想到都看到这里了还要读者翻书不太好，就一起放上来了。</p><p>定义<span class="math inline">\(x_a(t) = e^{-1000|t|}\)</span></p><p>先进行数学上的分析，</p><p><span class="math display">\[\begin {aligned}X_a(j \Omega) &amp;= \int^\infty_{-\infty}x_a(t)e^{-j\Omega t}dt \\&amp;= \int^0_{-\infty}e^{1000t}e^{-j\Omega t}dt + \int^\infty_0 e^{-1000t}e^{-j\Omega t}dt \\&amp;= \frac{0.002}{1+(\frac{\Omega}{1000})^2}\end {aligned}\]</span></p><p>MATLAB实现如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Analog Signal</span></span><br><span class="line">Dt = <span class="number">0.00005</span>;</span><br><span class="line">t = <span class="number">-0.005</span>:Dt:<span class="number">0.005</span>;</span><br><span class="line">xa = <span class="built_in">exp</span>(<span class="number">-1000</span>*<span class="built_in">abs</span>(t));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Continuous-time Fourier Transform</span></span><br><span class="line">Wmax = <span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">2000</span>;</span><br><span class="line">K = <span class="number">500</span>;</span><br><span class="line">k = <span class="number">0</span>:<span class="number">1</span>:K;</span><br><span class="line">W = k*Wmax/K;</span><br><span class="line"></span><br><span class="line">Xa = xa * <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">j</span>*t'*W) * Dt;</span><br><span class="line">Xa = <span class="built_in">abs</span>(Xa);</span><br><span class="line"></span><br><span class="line">W = [-<span class="built_in">fliplr</span>(W), W(<span class="number">2</span>:<span class="number">501</span>)];</span><br><span class="line">Xa = [<span class="built_in">fliplr</span>(Xa), Xa(<span class="number">2</span>:<span class="number">501</span>)];</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>); </span><br><span class="line"><span class="built_in">plot</span>(t*<span class="number">1000</span>,xa);</span><br><span class="line">xlabel(<span class="string">'t in msec.'</span>); </span><br><span class="line">ylabel(<span class="string">'xa(t)'</span>);</span><br><span class="line">title(<span class="string">'Analog Signal'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>); </span><br><span class="line"><span class="built_in">plot</span>(W/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">1000</span>),Xa*<span class="number">1000</span>);</span><br><span class="line">xlabel(<span class="string">'Frequency in KHz'</span>); ylabel(<span class="string">'Xa(jW)*1000'</span>);</span><br><span class="line">title(<span class="string">'Continuous-time Fourier Transform'</span>);</span><br></pre></td></tr></table></figure><p>运行效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/ctft_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果想确认变换的正确性，可以在运行完上面这个脚本后，在命令行输入</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(W/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">1000</span>),(<span class="number">0.002</span>./(<span class="number">1</span>+(W./<span class="number">1000</span>).^<span class="number">2</span>))*<span class="number">1000</span>);</span><br><span class="line">xlabel(<span class="string">'Frequency in KHz'</span>); ylabel(<span class="string">'Xa(jW)*1000'</span>);</span><br></pre></td></tr></table></figure><p>运行效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/source/dsp/ctft_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这时会发现，根据上面推导的变换公式直接plot出的图形和变换后得到的图形是一样的，这样可以确定变换的正确性。</p><h2 id="存在问题">存在问题</h2><p>目前存在的问题是，对于复函数的变换结果不正确。我想了很多天都找不出问题所在，只能暂时放弃，等以后有机会再研究。</p><h1 id="离散时间傅里叶变换">离散时间傅里叶变换</h1><p>下面是对上一个例子中的模拟输入信号做离散化，然后再进行离散傅里叶变换。</p><p>为了体现Nyquist定理，将使用两种不同的采样频率 1. 使用Fs=5000sam/sec采样来获得x1(n) 2. 使用Fs=1000sam/sec采样来获得x2(n)</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Analog Signal</span></span><br><span class="line">Dt = <span class="number">0.00005</span>;</span><br><span class="line">t = <span class="number">-0.005</span>:Dt:<span class="number">0.005</span>;</span><br><span class="line">xa = <span class="built_in">exp</span>(<span class="number">-1000</span>*<span class="built_in">abs</span>(t));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Discrete-time Signal </span></span><br><span class="line">Ts = <span class="number">0.0002</span>;</span><br><span class="line">n = <span class="number">-25</span>:<span class="number">1</span>:<span class="number">25</span>;</span><br><span class="line">x = <span class="built_in">exp</span>(<span class="number">-1000</span>*<span class="built_in">abs</span>(n*Ts));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Discrete-time Fourier transform</span></span><br><span class="line">K = <span class="number">500</span>;</span><br><span class="line">k = <span class="number">0</span>:<span class="number">1</span>:K;</span><br><span class="line">w = <span class="built_in">pi</span>*k/K;</span><br><span class="line"></span><br><span class="line">X = x*<span class="built_in">exp</span>(-<span class="built_in">j</span>*n'*w); X = <span class="built_in">real</span>(X);</span><br><span class="line"></span><br><span class="line">w = [-<span class="built_in">fliplr</span>(w), w(<span class="number">2</span>:K+<span class="number">1</span>)];</span><br><span class="line">X = [<span class="built_in">fliplr</span>(X), X(<span class="number">2</span>:K+<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="built_in">plot</span>(t*<span class="number">1000</span>,xa);</span><br><span class="line">xlabel(<span class="string">'t in msec.'</span>); </span><br><span class="line">ylabel(<span class="string">'x1(n)'</span>);</span><br><span class="line">title(<span class="string">'Discrete Signal'</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">stem(n*Ts*<span class="number">1000</span>,<span class="built_in">real</span>(x));gtext(<span class="string">'Ts=0.2 msec'</span>);<span class="built_in">hold</span> off;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);<span class="built_in">plot</span>(w/<span class="built_in">pi</span>,X);</span><br><span class="line">xlabel(<span class="string">'Frequency in pi units'</span>);ylabel(<span class="string">'X1(w)'</span>);</span><br><span class="line">title(<span class="string">'Discrete-time Fourier Transform'</span>);</span><br></pre></td></tr></table></figure><h2 id="fs5000samsec">Fs=5000sam/sec</h2><p>xa(t)的频率为2KHz，因此它的Nyquist频率为4KHz，而它的采样频率为5KHz，所以是满足Nyquist采样定律的，此时不会发生混叠。</p><p>运行效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/dtft_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="fs1000samsec">Fs=1000sam/sec</h2><p>这里使用的采样频率为1KHz，不满足Nyquist条件，因此会发生混叠。观察一下就会发生，1KHz采样得到的序列的频域波形和前面的频域波形不同，这就是混叠导致的，而且过低的采样率采集的信号的变换的不可逆的。</p><p>运行效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/dtft_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;傅里叶变换是我们最早开始接触的时频域变换方法，虽然经常使用，知道怎么用纸笔计算，但是还从来没有在电脑中模拟过，正好现在开始学习数字信号处理，借着这个机会再学习如何在电脑上模拟傅里叶变换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DSP" scheme="http://greedyhao.cc/tags/DSP/"/>
    
      <category term="Matlab" scheme="http://greedyhao.cc/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>c语言scanf输入问题</title>
    <link href="http://greedyhao.cc/2018/10/17/%E5%B7%A5%E4%BD%9C-c-language-2018-10-17-c%E8%AF%AD%E8%A8%80scanf%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://greedyhao.cc/2018/10/17/工作-c-language-2018-10-17-c语言scanf输入问题/</id>
    <published>2018-10-17T10:28:22.000Z</published>
    <updated>2018-10-17T10:28:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>经常有学弟学妹问到一个max函数(从两个数中找出最大的数)的问题，现在统一作答。</p><a id="more"></a><p>我将他们的代码放出来 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d,%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    c = max(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max=%d\n"</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) z = x;</span><br><span class="line">    <span class="keyword">else</span> z = y;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后输出结果 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ gcc error.c </span><br><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ ./a.out </span><br><span class="line">1，8</span><br><span class="line">max=1</span><br></pre></td></tr></table></figure></p><p>这里输出结果视编译器不同而不同。</p><p>之所以出现这样的问题，是因为输入数据的时候，格式化使用的逗号是中文导致的问题，重新使用英文逗号尝试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ ./a.out </span><br><span class="line">1,8</span><br><span class="line">max=8</span><br></pre></td></tr></table></figure><p>会发现程序运行正常了</p><p>在这里建议各位，在scanf格式化的时候，别使用逗号做分隔符，使用空格就可以避免类似的问题了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scanf("%d,%d",&amp;a,&amp;b);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br></pre></td></tr></table></figure><p>修改后的程序使用示例 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ gcc error.c </span><br><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ ./a.out </span><br><span class="line">1 8</span><br><span class="line">max=8</span><br></pre></td></tr></table></figure></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常有学弟学妹问到一个max函数(从两个数中找出最大的数)的问题，现在统一作答。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c语言" scheme="http://greedyhao.cc/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Sysgen-license-checkout-failed</title>
    <link href="http://greedyhao.cc/2018/10/11/%E5%B7%A5%E4%BD%9C-fpga-2018-10-11-Sysgen-license-checkout-failed/"/>
    <id>http://greedyhao.cc/2018/10/11/工作-fpga-2018-10-11-Sysgen-license-checkout-failed/</id>
    <published>2018-10-11T09:00:45.000Z</published>
    <updated>2018-10-11T09:00:48.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reported by:</span><br><span class="line">Unspecified</span><br><span class="line"></span><br><span class="line">Details:</span><br><span class="line">Sysgen license checkout failed.</span><br><span class="line">XILINXD_LICENSE_FILE = C:/Xilinx/Vivado/2016.1/data/sysgen/hwcosim_compiler/pp_ethernet</span><br><span class="line">Environment variable LM_LICENSE_FILE is not set.</span><br><span class="line">License search path: C:\.Xilinx;C:\Xilinx\Vivado\2016.1\data\sysgen\hwcosim_compiler\pp_ethernet;C:\Xilinx\Vivado\2016.1\data\ipcore_licenses</span><br></pre></td></tr></table></figure><p>这个错误是由于找不到license导致的</p><p>由于我无法复原错误了，所以就去网上找了一个差不多的出错信息</p><p>这个错误信息是windows下的，我的系统是ubuntu18.04，不过操作过程是差不多的</p><p>在错误信息中，可以看见<strong>XILINXD_LICENSE_FILE</strong>的位置，cd到这个位置，把自己的license复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x *.lic</span><br></pre></td></tr></table></figure><p>再次运行Sysgen会发现，没有再报错了</p><h1 id="windows下操作">windows下操作</h1><p>找到你的<strong>XILINXD_LICENSE_FILE</strong>位置，然后找到你的vivado的license位置，把这个license复制到<strong>XILINXD_LICENSE_FILE</strong>位置</p><h1 id="license下载">license下载</h1><p>虽然说是支持正版，不过这种软件一般的个人还是负担不起的，主要还是靠公司买单。</p><p>没钱的穷孩子可以下载<a href="https://github.com/greedyhao/some_useful_files/tree/master/vivado-license" target="_blank" rel="noopener">vivado-license全部功能破解</a></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
  </entry>
  
</feed>
