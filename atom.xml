<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhuhao&#39;s Blog</title>
  
  <subtitle>I am the captain of my ship and the master of my fate.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://greedyhao.cc/"/>
  <updated>2019-10-11T03:46:34.138Z</updated>
  <id>http://greedyhao.cc/</id>
  
  <author>
    <name>Greedyhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>制作usb转串口固件</title>
    <link href="http://greedyhao.cc/2019/10/11/%E5%B7%A5%E4%BD%9C-usb-2019-10-11-%E5%88%B6%E4%BD%9Cusb%E8%BD%AC%E4%B8%B2%E5%8F%A3%E5%9B%BA%E4%BB%B6/"/>
    <id>http://greedyhao.cc/2019/10/11/工作-usb-2019-10-11-制作usb转串口固件/</id>
    <published>2019-10-11T03:41:51.000Z</published>
    <updated>2019-10-11T03:46:34.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定时器相关">定时器相关</h1><p>最近在用 ch552 芯片做 usb 转串口的调试板</p><p>串口需要设置波特率，在 ch552 上需要给串口提供设定的波特率，这里使用定时器产生</p><h2 id="初值计算问题">初值计算问题</h2><p>一般使用定时器的模式2，8位自动重装，使用 TL 计数，使用 TH 重装</p><p>波特率初值的计算公式如下</p><p>THn = TLn = 256 - fsys/12/16/波特率/2</p><p>ch552 有 1T 的模式，所以可以不用除以 12，还可以设置波特率倍频，也不用除以 2，这样的话，计算公式改为</p><p>THn = TLn = 256 - fsys/16/波特率</p><p>这里顺便提一下除以 16 的原因。在51单片机内置的串口模块中，他采取的方式是把一位信号采集16次，然后把第7、8、9次取出来，如果这三次中其中有两次是高电平的话，就认定这一位数据是1，如果两次数据是低电平，就认为是0。这样可以提高通信的容错率。<a href="https://www.cnblogs.com/qsyll0916/p/7788475.html" target="_blank" rel="noopener">【参考来源】</a> (PS:STC12C5A60S2 的 datasheet 8.2.2 节有更详细的介绍)</p><h2 id="波特率误差问题">波特率误差问题</h2><p>异步串口有起始和停止位，再加校验位，8位字节最多可有12位。51单片机的串口模块通常在位中间采样，如此12位偏差50%就可能采样错误造成通信失败，对应通信双方波特率偏差约50%/12=4%。</p><p>串口通信误码率与通信双方波特率高低无关，不过波特率和通信距离的乘积有上限。<a href="http://bbs.21ic.com/icview-45920-1-1.html" target="_blank" rel="noopener">【参考来源】</a></p><p>本文中使用的 ch552 ，系统时钟为 16M，下面对是使用的常见的波特率进行误差分析。因为 ch552 不支持浮点波特率，所以对于小数部分进行截断</p><table><thead><tr class="header"><th>波特率</th><th>THn</th><th>误差</th><th>THn</th><th>误差</th></tr></thead><tbody><tr class="odd"><td>2400</td><td>416</td><td>0.16%</td><td>417</td><td>0.08%</td></tr><tr class="even"><td>9600</td><td>104</td><td>0.16%</td><td>105</td><td>0.79%</td></tr><tr class="odd"><td>19200</td><td>52</td><td>0.16%</td><td>53</td><td>1.73%</td></tr><tr class="even"><td>38400</td><td>26</td><td>0.16%</td><td>27</td><td>3.55%</td></tr><tr class="odd"><td>43000</td><td>23</td><td>1.11%</td><td>24</td><td>3.1%</td></tr><tr class="even"><td>56000</td><td>17</td><td>5%</td><td>18</td><td>0.79%</td></tr><tr class="odd"><td>57600</td><td>17</td><td>2.12%</td><td>18</td><td>3.55%</td></tr><tr class="even"><td>115200</td><td>8</td><td>8.5%</td><td>9</td><td>3.55%</td></tr><tr class="odd"><td>128000</td><td>7</td><td>11.6%</td><td>8</td><td>2.3%</td></tr></tbody></table><p>虽然说理论上 5% 的误差对于异步串口通信来说都是可以容忍的，但是可能存在收发双方都存在偏差的情况，所以需要控制偏差在 2.5% 以下。</p><p>本次实验中使用发现，表中误差达到 3.55% 的波特率，在接收数据的时候都会乱码</p><h1 id="usb-相关">usb 相关</h1><p>既然 ch552 上的串口波特率需要定时器的支持，那在 host 设备上设置波特率的时候，如何将 host 设备上对于波特率的需求传达给 ch552 呢</p><p>ch552 的 usb 驱动是 ftdi 的，通过对 ftdi 的 usb 驱动反汇编可以知道设置波特率的 usb 非标准请求编码(当然不是我反汇编的☺)，然后通过这个编码获取 usb 驱动送过来的一个 divisor 值。计算公式如下</p><p>divisor = 48M/16/波特率</p><p>这个计算是在 usb 驱动中完成的</p><p>在接收 host 端发送过来的 divisor 时要注意，自己的串口在什么接口，需要进行判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(UsbSetupBuf-&gt;wIndexL == <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// inf1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// inf2</span></span><br></pre></td></tr></table></figure><p>由于 ch552 不支持浮点波特率，因此可以忽略 host 端传送过来的 divisor 的小数部分， divisor 的低 14 位是整数部分，高两位是小数部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">divisor = UsbSetupBuf-&gt;wValueL |</span><br><span class="line">        (UsbSetupBuf-&gt;wValueH &lt;&lt; <span class="number">8</span>);</span><br><span class="line">divisor &amp;= <span class="number">0x3fff</span>;</span><br></pre></td></tr></table></figure><p>在接收到 divisor 后，还需要对这个数进行处理。因为 ftdi 驱动中使用的是 48M 的时钟进行波特率的计算的，这里我们需要转换成自己的系统时钟，然后再进行定时器的 THn 进行设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">divisor = divisor / <span class="number">3</span>; <span class="comment">// 16M CPU时钟</span></span><br><span class="line"><span class="keyword">if</span>(UsbSetupBuf-&gt;wIndexL == <span class="number">1</span>) <span class="comment">// 串口位于接口1</span></span><br><span class="line">    TH1 = <span class="number">0</span> - divisor;</span><br></pre></td></tr></table></figure><hr><p><a href="https://www.zhihu.com/people/shen-ye-de-kuang-xiang-qu/activities" target="_blank" rel="noopener">知乎链接</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定时器相关&quot;&gt;定时器相关&lt;/h1&gt;
&lt;p&gt;最近在用 ch552 芯片做 usb 转串口的调试板&lt;/p&gt;
&lt;p&gt;串口需要设置波特率，在 ch552 上需要给串口提供设定的波特率，这里使用定时器产生&lt;/p&gt;
&lt;h2 id=&quot;初值计算问题&quot;&gt;初值计算问题&lt;/h2&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="usb" scheme="http://greedyhao.cc/tags/usb/"/>
    
  </entry>
  
  <entry>
    <title>linux内核依赖问题汇总</title>
    <link href="http://greedyhao.cc/2019/08/09/%E5%B7%A5%E4%BD%9C-Linux-2019-08-09-linux%E5%86%85%E6%A0%B8%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://greedyhao.cc/2019/08/09/工作-Linux-2019-08-09-linux内核依赖问题汇总/</id>
    <published>2019-08-09T07:19:13.000Z</published>
    <updated>2019-08-09T07:19:50.093Z</updated>
    
    <content type="html"><![CDATA[<p>编译后的内核，可以正常启动了，不过时常还是会遇到一些依赖问题</p><p>之前遇到的时候没有注意，没有记录下来，后面都会记录，免得忘记</p><h1 id="rfkill-cannot-open-rfkill-control-device">rfkill: Cannot open RFKILL control device</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># wpa_supplicant -iwlan0 -B  -c /etc/wpa_supplicant.conf</span><br><span class="line">Successfully initialized wpa_supplicant</span><br><span class="line">rfkill: Cannot open RFKILL control device</span><br></pre></td></tr></table></figure><p>使用无线网卡连接 WiFi 的时候，发现会报这个错误信息，虽然无线网卡连接还是正常的，不过还是想找找是什么原因</p><p><a href="https://www.cnblogs.com/tid-think/p/10905056.html" target="_blank" rel="noopener">wpa_supplicant启动出错rfkill: Cannot open RFKILL control device</a> 这篇文章提到了这个问题</p><p>这是由于内核编译的时候没有打开 RFKILL 导致的</p><p>进入 Linux 的 menuconfig ，按 <code>/</code> 搜索 RFKILL ，找到这个配置并打开，重新编译后就正常了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编译后的内核，可以正常启动了，不过时常还是会遇到一些依赖问题&lt;/p&gt;
&lt;p&gt;之前遇到的时候没有注意，没有记录下来，后面都会记录，免得忘记&lt;/p&gt;
&lt;h1 id=&quot;rfkill-cannot-open-rfkill-control-device&quot;&gt;rfkill: Cannot
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://greedyhao.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何查看arm可执行文件的依赖</title>
    <link href="http://greedyhao.cc/2019/08/07/%E5%B7%A5%E4%BD%9C-Linux-2019-08-07-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Barm%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E4%BE%9D%E8%B5%96/"/>
    <id>http://greedyhao.cc/2019/08/07/工作-Linux-2019-08-07-如何查看arm可执行文件的依赖/</id>
    <published>2019-08-07T06:58:52.000Z</published>
    <updated>2019-08-09T07:19:02.100Z</updated>
    
    <content type="html"><![CDATA[<p>在 arm 设备上执行可执行程序时报错，缺少库文件，类似如下报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fswebcam: error while loading shared libraries: libgd.so.3: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>担心复制 libgd.so.3 库文件到文件系统后还有其他的依赖缺失，决定先确定可执行文件的动态库依赖</p><p>在网上搜索到可以使用 ldd 进行查看，然而交叉编译工具链并没有提供 ldd 这么一个东西</p><p>最后在网上看到一篇文章提到了这个问题<a href="https://codeday.me/bug/20171129/101157.html" target="_blank" rel="noopener">交叉编译 – 交叉编译ldd</a></p><p>将下面这段程序保存为脚本，执行后就可以查看可执行程序的依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">arm-none-linux-gnueabi-readelf -a <span class="variable">$1</span> | grep <span class="string">"Shared library:"</span></span><br></pre></td></tr></table></figure><p>以本人用到的 fswebcam 这个文件为例，命令执行后，输出所有的库的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-readelf -a fswebcam |  grep &quot;Shared library:&quot;</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libgd.so.3]</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 arm 设备上执行可执行程序时报错，缺少库文件，类似如下报错&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://greedyhao.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>uboot移植nor-flash</title>
    <link href="http://greedyhao.cc/2019/08/01/%E5%B7%A5%E4%BD%9C-uboot-2019-08-01-uboot%E7%A7%BB%E6%A4%8Dnor-flash/"/>
    <id>http://greedyhao.cc/2019/08/01/工作-uboot-2019-08-01-uboot移植nor-flash/</id>
    <published>2019-08-01T08:26:17.000Z</published>
    <updated>2019-08-01T08:27:10.352Z</updated>
    
    <content type="html"><![CDATA[<p>首先确认硬件是否正常，flash有无虚焊</p><p>开发板使用一个已经可以正常启动的 uboot 镜像，直接进入 uboot 的命令行，输入 <code>sf probe</code></p><p>这时 uboot 会去读取 flash 的 id ，如果 uboot 中没有对应 flahs 的 id 号，就会报以下的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SF: unrecognized JEDEC id bytes: 0b, 40, 18 // 0b, 40, 18 是 flash 的 id</span><br></pre></td></tr></table></figure><p>移植一个新的 flash 需要做的事情很简单，将 flash 对应的 id 和一些特性加入到 uboot 中就可以了</p><p>本人需要移植的 flash 为 xt25f128b，经过查询数据手册，发现和 winbond w25qxxx 系列的 flash 兼容性很高，硬件特性、指令基本一样</p><p>于是觉得基于 w25qxxx 系列进行移植</p><h2 id="定位问题">定位问题</h2><p>在代码中搜索报错的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct spi_flash_info *<span class="title">spi_flash_read_id</span><span class="params">(struct spi_flash *flash)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">tmp = spi_flash_cmd(flash-&gt;spi, CMD_READ_ID, id, SPI_FLASH_MAX_ID_LEN);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">info = spi_flash_ids;</span><br><span class="line"><span class="keyword">for</span> (; info-&gt;name != <span class="literal">NULL</span>; info++) &#123;</span><br><span class="line"><span class="keyword">if</span> (info-&gt;id_len) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span>(info-&gt;id, id, info-&gt;id_len))</span><br><span class="line"><span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"SF: unrecognized JEDEC id bytes: %02x, %02x, %02x\n"</span>,</span><br><span class="line">       id[<span class="number">0</span>], id[<span class="number">1</span>], id[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，这段程序试图在 spi_flash_ids 这个数组中查找是否有和板载 flash 对应的 id</p><p>然后是找到这个数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_flash_info</span> <span class="title">spi_flash_ids</span>[] = &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#123;<span class="string">"w25q128fw"</span>,   INFO(<span class="number">0xef6018</span>, <span class="number">0x0</span>,<span class="number">64</span> * <span class="number">1024</span>,   <span class="number">256</span>, RD_FULL | WR_QPP | SECT_4K) &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中使用到了一个 INFO 的宏定义，该宏定义的声明如下，通过声明我们就可以知道 spi_flash_ids 中定义着 flash 相关的特性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Used when the "_ext_id" is two bytes at most */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)\</span></span><br><span class="line">.id = &#123;\</span><br><span class="line">            ...</span><br><span class="line">.id_len = (!(_jedec_id) ? <span class="number">0</span> : (<span class="number">3</span> + ((_ext_id) ? <span class="number">2</span> : <span class="number">0</span>))),\</span><br><span class="line">.sector_size = (_sector_size),\</span><br><span class="line">.n_sectors = (_n_sectors),\</span><br><span class="line">.page_size = <span class="number">256</span>,\</span><br><span class="line">.flags = (_flags),</span><br></pre></td></tr></table></figure><p>由于需要移植的 flash 芯片特性和 w25qxxx 系列的 flash 相似，所以可以直接复制过来，修改后如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_flash_info</span> <span class="title">spi_flash_ids</span>[] = &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#123;<span class="string">"w25q128fw"</span>,   INFO(<span class="number">0xef6018</span>, <span class="number">0x0</span>,<span class="number">64</span> * <span class="number">1024</span>,   <span class="number">256</span>, RD_FULL | WR_QPP | SECT_4K) &#125;,</span><br><span class="line">&#123;<span class="string">"xt25f128b"</span>,   INFO(<span class="number">0x0b4018</span>, <span class="number">0x0</span>,<span class="number">64</span> * <span class="number">1024</span>,   <span class="number">256</span>, RD_FULL | WR_QPP | SECT_4K) &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改设备树中的 flash 相关的声明，添加上新增加的 flash 型号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&amp;spi0 &#123;</span><br><span class="line">...</span><br><span class="line">flash@0 &#123;</span><br><span class="line">        ...</span><br><span class="line">compatible = &quot;winbond,xt25f128b&quot;, &quot;jedec,spi-nor&quot;;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上电测试，输出以下信息代表 nor-flash 移植成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; sf probe</span><br><span class="line">SF: Detected xt25f128b with page size 256 Bytes, erase size 4 KiB, total 16 MiB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先确认硬件是否正常，flash有无虚焊&lt;/p&gt;
&lt;p&gt;开发板使用一个已经可以正常启动的 uboot 镜像，直接进入 uboot 的命令行，输入 &lt;code&gt;sf probe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这时 uboot 会去读取 flash 的 id ，如果 uboot 
      
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>编译根文件系统遇到的问题</title>
    <link href="http://greedyhao.cc/2019/07/30/%E5%B7%A5%E4%BD%9C-Linux-2019-07-30-%E7%BC%96%E8%AF%91%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://greedyhao.cc/2019/07/30/工作-Linux-2019-07-30-编译根文件系统遇到的问题/</id>
    <published>2019-07-30T08:38:20.000Z</published>
    <updated>2019-07-30T08:38:39.703Z</updated>
    
    <content type="html"><![CDATA[<p>这里使用 buildroot 编译根文件系统</p><h1 id="编译出现错误">编译出现错误</h1><p>有时候 <code>make</code> 的时候会报一些奇怪的错误信息，这可能是由于之前的编译没有清理导致的</p><p>执行 <code>make clean</code> ，再重新 <code>make</code> ，一般就能过编译了</p><h1 id="cant-open-devconsole-permission-denied">can't open /dev/console: Permission denied</h1><p>解决这个问题很简单，进入 <code>/you-path-to-rootfs/bin</code> 下，执行 <code>chown root * -R</code></p><h1 id="qt.qpa.plugin-could-not-find-the-qt-platform-plugin">qt.qpa.plugin: Could not find the Qt platform plugin</h1><p>以下是报错信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qt.qpa.plugin: Could not find the Qt platform plugin &quot;eglfs&quot; in &quot;&quot;</span><br><span class="line">This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.</span><br><span class="line"></span><br><span class="line">Available platform plugins are: linuxfb, minimal, offscreen, vnc.</span><br><span class="line"></span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>为了解决这个问题，可以使用其他的插件，在运行命令后面指定插件，例子如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qrasterwindow -platform linuxfb</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里使用 buildroot 编译根文件系统&lt;/p&gt;
&lt;h1 id=&quot;编译出现错误&quot;&gt;编译出现错误&lt;/h1&gt;
&lt;p&gt;有时候 &lt;code&gt;make&lt;/code&gt; 的时候会报一些奇怪的错误信息，这可能是由于之前的编译没有清理导致的&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;make cl
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://greedyhao.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>终端翻墙方法记录</title>
    <link href="http://greedyhao.cc/2019/07/26/Others-2019-07-26-%E7%BB%88%E7%AB%AF%E7%BF%BB%E5%A2%99%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://greedyhao.cc/2019/07/26/Others-2019-07-26-终端翻墙方法记录/</id>
    <published>2019-07-26T10:09:45.000Z</published>
    <updated>2019-07-26T10:10:19.148Z</updated>
    
    <content type="html"><![CDATA[<p>这里使用的工具是 proxychains</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install proxychains4</span><br></pre></td></tr></table></figure><p>安装完成后需要修改配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/proxychains.conf</span><br></pre></td></tr></table></figure><p>在文件的末尾加上翻墙的端口号，比如我的是 1080，这里就写 1080</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socks5  127.0.0.1 1080</span><br></pre></td></tr></table></figure><p>使用很简单，直接 proxychains4 + 命令就可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 git clone xxxx</span><br></pre></td></tr></table></figure><p>如果运行发现</p><p><code>'libproxychains.so.3' from LD_PRELOAD cannot be preloaded</code></p><p>需要修改 /usr/bin/proxychains 文件</p><p>首先需要找到 proxychains 的动态库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find /usr/ -name libproxychains.so.3 -print</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libproxychains.so.3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>打开<code>/usr/bin/proxychains</code>，将 <code>export LD_PRELOAD=libproxychains.so.3</code> 改为 <code>/usr/lib/x86_64-linux-gnu/libproxychains.so.3</code></p><h1 id="参考资料">参考资料</h1><ul><li><a href="https://blog.csdn.net/jiezhi2013/article/details/50624561" target="_blank" rel="noopener">解决'libproxychains.so.3' from LD_PRELOAD cannot be preloaded问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里使用的工具是 proxychains&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>drm设备不工作</title>
    <link href="http://greedyhao.cc/2019/07/26/%E5%B7%A5%E4%BD%9C-Linux-2019-07-26-drm%E8%AE%BE%E5%A4%87%E4%B8%8D%E5%B7%A5%E4%BD%9C/"/>
    <id>http://greedyhao.cc/2019/07/26/工作-Linux-2019-07-26-drm设备不工作/</id>
    <published>2019-07-26T07:54:39.000Z</published>
    <updated>2019-07-26T07:54:52.276Z</updated>
    
    <content type="html"><![CDATA[<p>在设备升级新版内核后，发现没有 fb0 设备，开机没有打印 drm 相关的信息</p><p>首先是检查设备树，确认加入 panel 节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">panel: panel &#123;</span><br><span class="line">compatible = &quot;lg,lb070wv8”, “simple-panel&quot;;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;0&gt;;</span><br><span class="line">enable-gpios = &lt;&amp;pio 4 6 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line"></span><br><span class="line">port@0 &#123;</span><br><span class="line">reg = &lt;0&gt;;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">panel_input: endpoint@0 &#123;</span><br><span class="line">reg = &lt;0&gt;;</span><br><span class="line">remote-endpoint = &lt;&amp;tcon0_out_lcd&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其次是检查内核是否开启了相关的驱动，这里使用的是 lichepi nano，依赖的驱动是 SUN4I 系列的驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_DRM_SUN4I=y</span><br><span class="line">CONFIG_DRM_SUN4I_HDMI=y</span><br><span class="line">CONFIG_DRM_SUN4I_BACKEND=y</span><br></pre></td></tr></table></figure><p>不过在检查完上面两个地方没有问题后，还是没有解决问题</p><p>为了获取 drm 启动过程中的更多信息，在 uboot 的 bootargs 中加入 drm.debug=0x1f debug ，让内核打印 drm 的更多信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[    1.079849] [drm:drm_core_init] Initialized</span><br><span class="line">[    1.084524] [drm:sun4i_drv_probe] Adding component /soc/display-backend@1e60000</span><br><span class="line">[    1.092143] [drm:sun4i_drv_probe] Adding component /soc/lcd-controller@1c0c000</span><br><span class="line">[    1.099606] [drm:sun4i_drv_probe] Adding component /panel</span><br><span class="line">[    1.105025] [drm:sun4i_drv_traverse_endpoints] No output to bind on port 1</span><br><span class="line">[    1.124695] [drm:compare_of] Comparing of node /soc/lcd-controller@1c0c000 with /soc/display-backend@1e60000</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>发现内核尝试着挂载 /panel 节点，这个本来是不用挂载的</p><p>修改 suniv_quirks，加上 has_channel_0 的配置。缺少 has_channel_0 会让内核认为这个 TCON 没有 RGB 口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sun4i_tcon_quirks</span> <span class="title">suniv_quirks</span> = &#123;</span></span><br><span class="line">    .has_channel_0= <span class="literal">true</span>,</span><br><span class="line">.has_channel_1= <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重新编译烧录后，drm 的启动信息如下。内核没有再去挂载 /panel 节点了，不过 drm 的启动还是没有成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[    1.079943] [drm:drm_core_init] Initialized</span><br><span class="line">[    1.084616] [drm:sun4i_drv_probe] Adding component /soc/display-backend@1e60000</span><br><span class="line">[    1.092235] [drm:sun4i_drv_probe] Adding component /soc/lcd-controller@1c0c000</span><br><span class="line">[    1.099662] [drm:sun4i_drv_traverse_endpoints] Endpoint is our panel... skipping</span><br><span class="line">[    1.121843] [drm:compare_of] Comparing of node /soc/display-backend@1e60000 with /soc/display-backend@1e60000</span><br><span class="line">[    1.131931] [drm:compare_of] Comparing of node /soc/display-backend@1e60000 with /soc/lcd-controller@1c0c000</span><br></pre></td></tr></table></figure><p>后来在看到了<a href="https://github.com/Libunko/linux/commit/95f0749694112894c10dc931953fa02d96036a26#diff-f6d9b3f2f9db8d9369f3ab2e76473459" target="_blank" rel="noopener">这份 commit</a>中说的内容，将 .has_channel_1 屏蔽掉，drm 正常工作了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static const struct sun4i_tcon_quirks suniv_f1c100s_quirks = &#123;</span><br><span class="line">/*</span><br><span class="line"> * The F1C100s SoC has a second channel in TCON, but the clock input of</span><br><span class="line"> * it is not documented.</span><br><span class="line"> */</span><br><span class="line">.has_channel_0= true,</span><br><span class="line">/* .has_channel_1= true, */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="感谢">感谢</h1><p>非常感谢这两位大神给我的帮助</p><ul><li><a href="https://github.com/Icenowy" target="_blank" rel="noopener">Icenowy</a></li><li><a href="https://github.com/Libunko" target="_blank" rel="noopener">libunko</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在设备升级新版内核后，发现没有 fb0 设备，开机没有打印 drm 相关的信息&lt;/p&gt;
&lt;p&gt;首先是检查设备树，确认加入 panel 节点&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>升级内核遇到的问题汇总</title>
    <link href="http://greedyhao.cc/2019/07/23/%E5%B7%A5%E4%BD%9C-Linux-2019-07-23-%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://greedyhao.cc/2019/07/23/工作-Linux-2019-07-23-升级内核遇到的问题汇总/</id>
    <published>2019-07-23T00:51:05.000Z</published>
    <updated>2019-07-23T00:51:37.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卡在starting-kernel">卡在starting kernel</h1><p>注意一下设备树和自己的内核是不是匹配的</p><h1 id="waiting-for-root-device-devmmcblk0p2..">Waiting for root device /dev/mmcblk0p2..</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[    1.041445] platform regulatory.0: Direct firmware load for regulatory.db failed with error -2</span><br><span class="line">[    1.050235] cfg80211: failed to load regulatory.db</span><br><span class="line">[    1.055609] Waiting for root device /dev/mmcblk0p2...</span><br><span class="line">[    5.586971] random: fast init done</span><br></pre></td></tr></table></figure><p>重新编译根文件系统中</p><p>正常启动的启动信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">U-Boot 2018.01-05676-g00188782ee (Aug 09 2018 - 18:49:43 +0800) Allwinner Technology</span><br><span class="line">...</span><br><span class="line">## Flattened Device Tree blob at 80c00000</span><br><span class="line">   Booting using the fdt blob at 0x80c00000</span><br><span class="line">   Loading Device Tree to 80e60000, end 80e65160 ... OK</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line">[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 4.15.0-rc8-licheepi-nano+ (root@biglion-MRC-WX0) (gcc version 7.2.0 (Ubuntu/Linaro 7.2.0-6ubuntu1)) #69 Wed Apr 4 17:47:49 CST 2018</span><br><span class="line">...</span><br><span class="line">[    1.164113] mmc0: host does not support reading read-only switch, assuming write-enable</span><br><span class="line">[    1.181541] mmc0: new high speed SDXC card at address aaaa</span><br><span class="line">[    1.197164] mmcblk0: mmc0:aaaa SC64G 59.5 GiB</span><br><span class="line">[    1.212431]  mmcblk0: p1 p2</span><br><span class="line">...</span><br><span class="line">[    1.571650] platform regulatory.0: Direct firmware load for regulatory.db failed with error -2</span><br><span class="line">[    1.588783] cfg80211: failed to load regulatory.db</span><br><span class="line">[    1.606673] EXT4-fs (mmcblk0p2): couldn&apos;t mount as ext3 due to feature incompatibilities</span><br><span class="line">[    1.653887] EXT4-fs (mmcblk0p2): mounted filesystem with ordered data mode. Opts: (null)</span><br><span class="line">[    1.670848] VFS: Mounted root (ext4 filesystem) on device 179:2.</span><br><span class="line">[    1.688953] devtmpfs: mounted</span><br><span class="line">[    1.706149] Freeing unused kernel memory: 1024K</span><br><span class="line">[    1.869936] EXT4-fs (mmcblk0p2): re-mounted. Opts: data=ordered</span><br><span class="line">Starting logging: OK</span><br><span class="line">Initializing random number generator... done.</span><br><span class="line"></span><br><span class="line">Welcome to Lichee Pi</span><br><span class="line">Lichee login:</span><br></pre></td></tr></table></figure><p>错误启动时的信息 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line">[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 5.2.0-licheepi-nano (zhuhao@sipeed_ai) (gcc version 7.4.1 20181213 [linaro-7.4-2019.02 revision 56ec6f6b99cc167ff0c2f8e1a2eed33b1edc85d4] (Linaro GCC 7.4-2019.02)) #1 Tue Jul 16 08:26:30 UTC 2019</span><br><span class="line">...</span><br><span class="line">[    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1</span><br><span class="line">...</span><br><span class="line">[    1.046636] platform regulatory.0: Direct firmware load for regulatory.db failed with error -2</span><br><span class="line">[    1.055426] cfg80211: failed to load regulatory.db</span><br><span class="line">[    1.060972] Waiting for root device /dev/mmcblk0p2...</span><br><span class="line">[    5.617756] random: fast init done</span><br></pre></td></tr></table></figure></p><p>发现无法启动时的启动信息中缺少了 mmc 驱动加载的相关信息，怀疑可能没有加载 mmc 驱动导致设备无法读取根文件系统</p><p>最后发现还是设备树的问题，linux 5.2 主线中的设备树中没有添加 mmc 相关的配置，在添加 mmc 相关的配置后重新编译，设备替换为正确的设备数后，启动成功</p><p>以后移植内核的时候需要注意一下设备树文件</p><h1 id="spi-启动">spi 启动</h1><p>正常启动的打印信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 4.15.0-next-20180202-licheepi-nano+ (biglion@biglion-MRC-WX0) (gcc version 7.2.0 (Ubuntu/Linaro 7.2.0-6ubuntu1)) #107 Sat May 19 11:56:16 CST 2018</span><br><span class="line">...</span><br><span class="line">[    0.129219] jffs2: version 2.2. (NAND) © 2001-2006 Red Hat, Inc.</span><br><span class="line">...</span><br><span class="line">[    0.782259] m25p80 spi0.0: w25q128 (16384 Kbytes)</span><br><span class="line">...</span><br><span class="line">[    0.813807] Creating 4 MTD partitions on &quot;spi0.0&quot;:</span><br><span class="line">[    0.818652] 0x000000000000-0x000000100000 : &quot;u-boot&quot;</span><br><span class="line">[    0.825860] 0x000000100000-0x000000110000 : &quot;dtb&quot;</span><br><span class="line">[    0.833036] 0x000000110000-0x000000510000 : &quot;kernel&quot;</span><br><span class="line">[    0.840417] 0x000000510000-0x000001000000 : &quot;rootfs&quot;</span><br><span class="line">...</span><br><span class="line">[    0.915838] sun4i-drm display-engine: bound 1e60000.display-backend (ops 0xc0633630)</span><br><span class="line">[    0.923836] sun4i-tcon 1c0c000.lcd-controller: Missing LVDS properties, Please upgrade your DT</span><br><span class="line">[    0.932515] sun4i-tcon 1c0c000.lcd-controller: LVDS output disabled</span><br><span class="line">[    0.939657] sun4i-drm display-engine: bound 1c0c000.lcd-controller (ops 0xc0632848)</span><br><span class="line">[    0.947435] [drm] Supports vblank timestamp caching Rev 2 (21.10.2013).</span><br><span class="line">[    0.954034] [drm] No driver support for vblank timestamp query.</span><br><span class="line">[    1.093614] Console: switching to colour frame buffer device 100x30</span><br><span class="line">[    1.116657] sun4i-drm display-engine: fb0:  frame buffer device</span><br><span class="line">[    1.123722] [drm] Initialized sun4i-drm 1.0.0 20150629 for display-engine on minor 0</span><br><span class="line">...</span><br><span class="line">[    3.590404] VFS: Mounted root (jffs2 filesystem) on device 31:3.</span><br><span class="line">[    3.598132] devtmpfs: mounted</span><br><span class="line">[    3.607538] Freeing unused kernel memory: 1024K</span><br></pre></td></tr></table></figure><p>无法启动的打印信息 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 4.15.0-next-20180202-licheepi-nano+ (biglion@biglion-MRC-WX0) (gcc version 7.2.0 (Ubuntu/Linaro 7.2.0-6ubuntu1)) #107 Sat May 19 11:56:16 CST 2018</span><br><span class="line">...</span><br><span class="line">[    0.157377] jffs2: version 2.2. (NAND) © 2001-2006 Red Hat, Inc.</span><br><span class="line">...</span><br><span class="line">[    0.820678] m25p80 spi0.0: w25q128 (16384 Kbytes)</span><br><span class="line">...</span><br><span class="line">[    0.954065] Waiting for root device /dev/mtdblock3...</span><br></pre></td></tr></table></figure></p><p>之所以会卡在 <code>Waiting for root device /dev/mtdblock3</code> 是因为内核没有开启 MTD_BLOCK 的支持，在内核中开启后，重新编译烧录，启动成功</p><h1 id="vfs-cannot-open-root-device-mtdblock3-or-unknown-block313-error--19">VFS: Cannot open root device &quot;mtdblock3&quot; or unknown-block(31,3): error -19</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[    1.308757] VFS: Cannot open root device &quot;mtdblock3&quot; or unknown-block(31,3): error -19</span><br><span class="line">[    1.316804] Please append a correct &quot;root=&quot; boot option; here are the available partitions:</span><br><span class="line">[    1.325238] 1f00            1024 mtdblock0</span><br><span class="line">[    1.325248]  (driver?)</span><br><span class="line">[    1.331790] 1f01              64 mtdblock1</span><br><span class="line">[    1.331795]  (driver?)</span><br><span class="line">[    1.338392] 1f02            4160 mtdblock2</span><br><span class="line">[    1.338400]  (driver?)</span><br><span class="line">[    1.344983] 1f03           11136 mtdblock3</span><br><span class="line">[    1.344990]  (driver?)</span><br></pre></td></tr></table></figure><p>这种情况注意你的内核中对文件系统的支持，与实际的根目录格式是否一致</p><p>比如我的情况就是根目录是 jffs2 的格式，那么内核在配置的时候就要开启 jffs2 的支持</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;卡在starting-kernel&quot;&gt;卡在starting kernel&lt;/h1&gt;
&lt;p&gt;注意一下设备树和自己的内核是不是匹配的&lt;/p&gt;
&lt;h1 id=&quot;waiting-for-root-device-devmmcblk0p2..&quot;&gt;Waiting for roo
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://greedyhao.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>图像频域全白现象</title>
    <link href="http://greedyhao.cc/2019/06/25/%E5%B7%A5%E4%BD%9C-img-proc-2019-06-25-%E5%9B%BE%E5%83%8F%E9%A2%91%E5%9F%9F%E5%85%A8%E7%99%BD%E7%8E%B0%E8%B1%A1/"/>
    <id>http://greedyhao.cc/2019/06/25/工作-img-proc-2019-06-25-图像频域全白现象/</id>
    <published>2019-06-25T08:23:15.000Z</published>
    <updated>2019-06-25T08:26:20.504Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始图像处理的实验课了，一开始学习的是空间灰度变换与直方图变换，使用的软件是 MATLAB。一开始对图片进行傅里叶变换，查看它的频谱的时候发现，和理论上的不一样，居然全是白色的</p><a id="more"></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/img_proc/gray_scale_0.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在网上查到原因是，自己使用的是 rbg ，应该使用灰度值</p><p>在使用 rgb2gray 转换成灰度值后，图片的频谱就正常了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/img_proc/gray_scale_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><a href="https://ww2.mathworks.cn/matlabcentral/answers/261707-how-to-convert-an-image-to-frequency-domain-in-matlab" target="_blank" rel="noopener">How to convert an image to frequency domain in MATLAB?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始图像处理的实验课了，一开始学习的是空间灰度变换与直方图变换，使用的软件是 MATLAB。一开始对图片进行傅里叶变换，查看它的频谱的时候发现，和理论上的不一样，居然全是白色的&lt;/p&gt;
    
    </summary>
    
    
      <category term="image" scheme="http://greedyhao.cc/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>从三星uboot开始移植</title>
    <link href="http://greedyhao.cc/2019/06/22/%E5%B7%A5%E4%BD%9C-x210-2019-06-22-%E4%BB%8E%E4%B8%89%E6%98%9Fuboot%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8D/"/>
    <id>http://greedyhao.cc/2019/06/22/工作-x210-2019-06-22-从三星uboot开始移植/</id>
    <published>2019-06-22T15:37:22.000Z</published>
    <updated>2019-06-22T23:26:16.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移植前的准备">移植前的准备</h1><p>下载 android_uboot_smdkv210.tar.bz2 这个文件，找不到可以去公众号回复</p><a id="more"></a><p><strong>下载|三星uboot</strong></p><h1 id="开始移植">开始移植</h1><p>本人使用的开发板是九鼎的 x210，在三星 uboot 的主 Makefile 中找到了类似的 smdkv210 的相关配置，因为这些配置都差不多，就随便选择了 smdkv210single_config</p><p>在 make smdkv210single_config; make 执行之后进行 SD 卡烧录</p><p>源码中的 SD 卡烧录脚本 <strong>sd_fusing.sh</strong> 在本人的电脑上运行有问题，需要将 21 行开始的代码进行修改如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// line 19</span><br><span class="line">if [ $1 = $reader_type1 ]</span><br><span class="line">then </span><br><span class="line">    # partition1=&quot;$11&quot;</span><br><span class="line">    # partition2=&quot;$12&quot;</span><br><span class="line">    # partition3=&quot;$13&quot;</span><br><span class="line">    # partition4=&quot;$14&quot;</span><br><span class="line">    partition1=&quot;$*1&quot;</span><br><span class="line">    partition2=&quot;$*2&quot;</span><br><span class="line">    partition3=&quot;$*3&quot;</span><br><span class="line">    partition4=&quot;$*4&quot;</span><br></pre></td></tr></table></figure><p>在烧录后发现，串口没有信息输出，但是开发板供电锁存成功</p><p>开发板供电锁存是在 lowlevel_init.S 中进行的</p><p>可以判定 lowlevel_init.S 中有问题，需要进行修改</p><h2 id="启动第一阶段">启动第一阶段</h2><p>在 lowlevel_init.S 中发现了一段代码对开发板上不存在的 PMIC 的初始化，在注释后串口成功打印 'OK'</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* init PMIC chip */</span><br><span class="line">// bl PMIC_InitIp</span><br></pre></td></tr></table></figure><p>uboot 开始进入启动第二阶段，通过串口输出信息可以看出，虽然 uboot 启动成功，但是很多配置信息是错误的</p><h2 id="时钟配置">时钟配置</h2><p>系统时钟是通过 lowlevel_init.S 中的 system_clock_init 进行的</p><p>由于三星在移植 uboot 时已经设置好系统时钟了，相关的时钟配置也都以宏的方式定义在 smdkv210single.h 文件中了</p><p>所以时钟这一块不用自己操心</p><h2 id="ddr-配置">ddr 配置</h2><p>在 uboot 启动信息中发现串口输出的信息中，DRAM 大小和开发板的不符合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DRAM:    1 G</span><br></pre></td></tr></table></figure><p>在 smdkv210single.h 文件中找到 <strong>ddr 的相关的配置</strong></p><p>将 ddr 的地址更改为 0x30000000 (改了可以让两个 ddr 的地址连续)，更改 ddr 的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define MEMORY_BASE_ADDRESS0x20000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMORY_BASE_ADDRESS0x30000000</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_NR_DRAM_BANKS    2          <span class="comment">/* we have 2 bank of DRAM */</span></span></span><br><span class="line"><span class="comment">// #define SDRAM_BANK_SIZE         0x20000000    /* 512 MB */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDRAM_BANK_SIZE         0x10000000    <span class="comment">/* 256 MB */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_SDRAM_1            MEMORY_BASE_ADDRESS <span class="comment">/* SDRAM Bank #1 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_SDRAM_1_SIZE       SDRAM_BANK_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_SDRAM_2            (MEMORY_BASE_ADDRESS + SDRAM_BANK_SIZE) <span class="comment">/* SDRAM Bank #2 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_SDRAM_2_SIZE       SDRAM_BANK_SIZE</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后是<strong>修改 ddr 的初始化参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define DMC0_MEMCONFIG_00x20E01323// MemConfig0256MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMC0_MEMCONFIG_00x30F01323<span class="comment">// MemConfig0256MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed</span></span></span><br></pre></td></tr></table></figure><p>ddr 的相关寄存器配置可以参考 S5PV210_UM_REV1.1.pdf</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/smdkv_uport_0.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看到，[31:24] 控制 AXI 基地址，因为我们设置 ddr 的基地址为 0x30000000 ，所以这里设置为 0x30。[23:16] 控制 AXI 基地址掩码，置1时有效，可以使基地址范围变为 0x3000_0000 ~ 0x37FF_FFFF，所以这里设置为 0xF0</p><p><strong>修改虚拟地址到物理地址的映射</strong></p><p>修改 board/samsung/smdkc110/smdkc110.c 的 virt_to_phy_smdkc110 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ulong <span class="title">virt_to_phy_smdkc110</span><span class="params">(ulong addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0xc0000000</span> &lt;= addr) &amp;&amp; (addr &lt; <span class="number">0xd0000000</span>))</span><br><span class="line"><span class="comment">// return (addr - 0xc0000000 + 0x20000000);</span></span><br><span class="line"><span class="keyword">return</span> (addr - <span class="number">0xc0000000</span> + <span class="number">0x30000000</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sdmmc-配置">SD/MMC 配置</h2><p>在 uboot 打印信息中看不到 SD/MMC 的大小，报下面的错误</p><p><code>unrecognised EXT_CSD structure version 7</code></p><p>通过报错信息的搜索，可以将问题定位到 drivers/mmc/mmc.c 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (ext_csd_struct &gt; 5) &#123;</span></span><br><span class="line"><span class="keyword">if</span> (ext_csd_struct &gt; <span class="number">7</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"unrecognised EXT_CSD structure "</span></span><br><span class="line"><span class="string">"version %d\n"</span>, ext_csd_struct);</span><br><span class="line">err = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原先的判断 version 的版本改大点就可以了</p><p>为了通过 SD 卡启动，还需要将下面的代码修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mmc = find_mmc_device(0); // iNand</span></span><br><span class="line">mmc = find_mmc_device(<span class="number">1</span>); <span class="comment">// SD</span></span><br></pre></td></tr></table></figure><h2 id="网卡芯片配置">网卡芯片配置</h2><p>开发板使用的网卡芯片为 DM9000 ，通过总线结构与开发板 SOC 相连，通过 SOC 的 SROM 控制器进行控制</p><p>这样的好处是可以直接通过地址访问网卡芯片内部的寄存器。访问方式是通过网卡芯片的基地址加上网卡芯片内部寄存器的偏移地址完成的</p><p>通过原理图观察可以知道 DM9000 与 SOC 之间通信的总线是 16 位的。 DM9000 的 CMD 引脚接到了 SOC 的 ADDR2 上， DM9000 数据命令总线复用，通过 CMD 进行判断是数据还是命令</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/smdkv_uport_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>CS 片选引脚接到了 SOC 的 CSn1 上，代表者使用的是 SROM bank1，因此 DM9000 的总线基地址为 0x88000000</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/smdkv_uport_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我们需要做的配置也就是<strong>初始化网卡而已</strong>，驱动都是统一的</p><p>定位到板级初始化代码 board/samsung/smdkc110/smdkc110.c 中</p><p>dm9000_pre_init 进行了 DM9000 的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dm9000_pre_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DM9000_16BIT_DATA)</span></span><br><span class="line"><span class="comment">// SROM_BW_REG &amp;= ~(0xf &lt;&lt; 20);</span></span><br><span class="line"><span class="comment">// SROM_BW_REG |= (0&lt;&lt;23) | (0&lt;&lt;22) | (0&lt;&lt;21) | (1&lt;&lt;20);</span></span><br><span class="line">SROM_BW_REG &amp;= ~(<span class="number">0xf</span> &lt;&lt; <span class="number">4</span>); <span class="comment">// 更改为 SROM bank1 ，寄存器信息参考下图</span></span><br><span class="line">SROM_BW_REG |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">SROM_BW_REG &amp;= ~(<span class="number">0xf</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">SROM_BW_REG |= (<span class="number">0</span>&lt;&lt;<span class="number">19</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">18</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">16</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// SROM_BC5_REG = ((0&lt;&lt;28)|(1&lt;&lt;24)|(5&lt;&lt;16)|(1&lt;&lt;12)|(4&lt;&lt;8)|(6&lt;&lt;4)|(0&lt;&lt;0));</span></span><br><span class="line">SROM_BC1_REG = ((<span class="number">0</span>&lt;&lt;<span class="number">28</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">24</span>)|(<span class="number">5</span>&lt;&lt;<span class="number">16</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">12</span>)|(<span class="number">4</span>&lt;&lt;<span class="number">8</span>)|(<span class="number">6</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">0</span>)); <span class="comment">// SROM bank1 对应的 Bank Control Register</span></span><br><span class="line"></span><br><span class="line">tmp = MP01CON_REG; <span class="comment">// 更改片选引脚，寄存器信息参考下图</span></span><br><span class="line"><span class="comment">// tmp &amp;=~(0xf&lt;&lt;20);</span></span><br><span class="line"><span class="comment">// tmp |=(2&lt;&lt;20);</span></span><br><span class="line">tmp &amp;=~(<span class="number">0xf</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">tmp |=(<span class="number">2</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">MP01CON_REG = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是按照板上具体情况配置，下面两个图是上面修改的寄存器的信息</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/smdkv_uport_3.png" alt="SROM bank1" title>                </div>                <div class="image-caption">SROM bank1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/smdkv_uport_4.png" alt="CSn1" title>                </div>                <div class="image-caption">CSn1</div>            </figure><p><strong>基地址的配置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DRIVER_DM9000</span></span><br><span class="line"><span class="comment">// #define CONFIG_DM9000_BASE(0xA8000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_DM9000_BASE(0x88000300)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9000_IO(CONFIG_DM9000_BASE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DM9000_16BIT_DATA)</span></span><br><span class="line"><span class="comment">// #define DM9000_DATA(CONFIG_DM9000_BASE+2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9000_DATA(CONFIG_DM9000_BASE+4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9000_DATA(CONFIG_DM9000_BASE+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上面也有提到，不同的 SROM BANK ，它们的基地址都是不同的，这里需要配置</p><p>之所以这里的基地址需要增加一个 0x300 的偏移，看到朱有鹏说可能是新版的 DM9000C 内部寄存器存在 0x300 的偏移</p><p>移植到此结束</p><h1 id="移植后遇见的问题">移植后遇见的问题</h1><h2 id="uboot-tftp-下载失败">uboot tftp 下载失败</h2><p><code>TFTP error: 'File not found' (1)</code></p><p>在 uboot 中使用 tftp 下载镜像时，一直报上面的错误，但是在电脑上测试是可以正常下载的</p><p>后来在网上找到了原因，是 tftp 服务器是配置问题</p><p>按下面的步骤重新配置 tftp 服务器就可以正常下载了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// https://stackoverflow.com/questions/41616266/tftp-error-file-not-found</span><br><span class="line">1, try to install tftpd-hpa</span><br><span class="line"></span><br><span class="line">2, config tftpd-hpa</span><br><span class="line">$ sudo vi /etc/default/tftpd-hpa</span><br><span class="line"></span><br><span class="line">TFTP_USERNAME=&quot;tftp&quot;</span><br><span class="line">TFTP_DIRECTORY=&quot;/tftpboot&quot;</span><br><span class="line">TFTP_ADDRESS=&quot;0.0.0.0:69&quot;</span><br><span class="line">TFTP_OPTIONS=&quot;-l -c -s&quot;</span><br><span class="line"></span><br><span class="line">3, start tftp server</span><br><span class="line">$ sudo service tftpd-hpa restart</span><br></pre></td></tr></table></figure><h2 id="kernel-panic">Kernel panic</h2><p>Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</p><p>解决这个问题需要设置 bootargs，可以通过更改配置头文件中的 CONFIG_BOOTARGS 完成。我这块开发板的配置如下：</p><p><code>console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3</code></p><p>分别简单的介绍下这些参数的意义</p><p><strong>console=</strong></p><p>这个参数告诉内核将信息输出到什么地方。本开发板的配置为 串口2，波特率115200</p><p><strong>root=</strong></p><p>这告诉内核使用什么设备作为根文件系统。本开发板的配置为 SD 卡设备</p><p>如果需要通过 NFS 启动，可以这样设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root=/dev/nfs</span><br></pre></td></tr></table></figure><p><strong>rw</strong></p><p>这告诉内核将根文件系统挂载为读/写。</p><p><strong>init=</strong></p><p>这指定内核启动起来后，进入系统中运行的第一个脚本</p><p><strong>rootfstype=</strong></p><p>这用来指明文件系统的类型。</p><h1 id="参考资料">参考资料</h1><ul><li><a href="http://processors.wiki.ti.com/index.php/U-Boot_Usage#bootargs" target="_blank" rel="noopener">U-Boot Usage - TI</a></li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;移植前的准备&quot;&gt;移植前的准备&lt;/h1&gt;
&lt;p&gt;下载 android_uboot_smdkv210.tar.bz2 这个文件，找不到可以去公众号回复&lt;/p&gt;
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>uboot启动内核</title>
    <link href="http://greedyhao.cc/2019/06/11/%E5%B7%A5%E4%BD%9C-x210-2019-06-11-uboot%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/"/>
    <id>http://greedyhao.cc/2019/06/11/工作-x210-2019-06-11-uboot启动内核/</id>
    <published>2019-06-11T08:39:18.000Z</published>
    <updated>2019-06-11T08:41:42.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识-uboot-和-内核-之间不可不说的关系">认识 uboot 和 内核 之间不可不说的关系</h1><p>uboot 镜像为 uboot.bin，Linux 镜像为 zImage</p><p>嵌入式设备中的分区表是自己定义的，uboot 和内核中的分区表应一致</p><p>内核运行前必须加载到 ddr 中指定的地址处</p><p>uboot 需要提供内核必要的参数</p><h2 id="内核启动的方式">内核启动的方式</h2><p>uboot 启动内核有两种方式，一种是等待倒计时结束后直接启动内核，一种是在 uboot 命令行中使用 boot 命令启动内核</p><p>其代码分别如下</p><p>其中 parse_string_outer 的作用是解析 boot 参数并执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*------------------倒计时----------------------*/</span><br><span class="line">s = getenv (&quot;bootcmd&quot;);</span><br><span class="line"></span><br><span class="line">if (bootdelay &gt;= 0 &amp;&amp; s &amp;&amp; !abortboot (bootdelay)) &#123;</span><br><span class="line">...</span><br><span class="line">parse_string_outer(s, FLAG_PARSE_SEMICOLON |</span><br><span class="line">    FLAG_EXIT_FROM_LOOP);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">/*------------------命令行----------------------*/</span><br><span class="line">int do_bootd (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">if (parse_string_outer (getenv (&quot;bootcmd&quot;),</span><br><span class="line">FLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOP) != 0)</span><br><span class="line">rcode = 1;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">U_BOOT_CMD(</span><br><span class="line">boot,1,1,do_bootd,</span><br><span class="line">&quot;boot    - boot default, i.e., run &apos;bootcmd&apos;\n&quot;,</span><br><span class="line">NULL</span><br><span class="line">);</span><br><span class="line">/*-----------------相关宏定义----------------------*/</span><br><span class="line">#ifdefCONFIG_BOOTARGS</span><br><span class="line">&quot;bootargs=&quot;CONFIG_BOOTARGS&quot;\0&quot;</span><br><span class="line">#endif</span><br><span class="line">#ifdefCONFIG_BOOTCOMMAND</span><br><span class="line">&quot;bootcmd=&quot;CONFIG_BOOTCOMMAND&quot;\0&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define CONFIG_BOOTARGS    &quot;console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3&quot;</span><br><span class="line">#define CONFIG_BOOTCOMMAND&quot;movi read kernel 30008000; movi read rootfs 30B00000 300000; bootm 30008000 30B00000&quot;</span><br></pre></td></tr></table></figure><h2 id="加载内核到ddr中">加载内核到DDR中</h2><p>uboot 启动内核的步骤</p><ul><li>内核镜像从启动介质中加载到DDR中</li><li>去DDR中启动内核镜像</li></ul><p>本文使用的开发板 x210 将镜像存放在 SD 卡中，要加载到 ddr 中需要使用到 movi 指令</p><p>movi 提供了对 iNand/SD 卡的操作，movi read 用来读取 iNand/SD 卡中的内容到DDR中；movi write 用来将DDR中的内容写入到 iNand/SD 卡中</p><p>上面的代码中 bootcmd 中的命令就是用来加载 kernel rootfs 到 ddr</p><p>除了从 SD 卡加载，还可以通过 tftp nfs 等网络下载方式加载镜像</p><p>通过 <code>movi read kernel 30008000</code> 可以知道，内核加载到了 0x30008000 的位置</p><h2 id="内核的镜像生成">内核的镜像生成</h2><p>Linux 直接编译得到 elf 文件，叫 vmlinux 或 vmlinuz。这种文件会比较大，为了烧录方便，会使用 objcopy 工具制作成镜像文件，叫 Image(从78M精简成了7.5M)</p><p>早期使用的软盘比较小，Image 对与软盘来说还是太大了，放不下。Linux 对 Image 做进一步的压缩，并在压缩文件前端附加了一部分解压缩代码，形成 zImage</p><p>uboot 可以使用 mkimage 工具，在 zImage 前面加上64字节的uImage的头信息，形成 uImage</p><h1 id="加载启动内核">加载启动内核</h1><p>内核的加载启动是通过 do_bootm 完成的</p><p>前面介绍过，镜像文件分为两个部分，头部以及真正的内核</p><p>所以 do_bootm 会先对镜像进行头部信息的校验，然后再进行内核的启动</p><p>头部信息的结构体如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct image_header &#123;</span><br><span class="line">uint32_tih_magic;/* Image Header Magic Number*/</span><br><span class="line">uint32_tih_hcrc;/* Image Header CRC Checksum*/</span><br><span class="line">uint32_tih_time;/* Image Creation Timestamp*/</span><br><span class="line">uint32_tih_size;/* Image Data Size*/</span><br><span class="line">uint32_tih_load;/* Data Load  Address*/</span><br><span class="line">uint32_tih_ep;/* Entry Point Address*/</span><br><span class="line">uint32_tih_dcrc;/* Image Data CRC Checksum*/</span><br><span class="line">uint8_tih_os;/* Operating System*/</span><br><span class="line">uint8_tih_arch;/* CPU architecture*/</span><br><span class="line">uint8_tih_type;/* Image Type*/</span><br><span class="line">uint8_tih_comp;/* Compression Type*/</span><br><span class="line">uint8_tih_name[IH_NMLEN];/* Image Name*/</span><br><span class="line">&#125; image_header_t;</span><br></pre></td></tr></table></figure><p>在 do_bootm 中就是通过 ih_os 判断镜像的类型，然后使用相应的方法启动内核</p><p>这里的镜像是 Linux 镜像，所以使用的是 do_bootm_linux， do_bootm_linux 的参数大部分是通过 do_bootm 传递的</p><p>启动的参数 <code>bootm 30008000</code>，告诉 uboot 去 30008000 这个地址去找镜像文件</p><h2 id="内核启动">内核启动</h2><p>镜像的程序入口叫做 entrypoint ，在 do_bootm_linux 中使用 ep 保存，镜像的程序入口在头信息的 ih_ep 中，可以通过读取头信息得到</p><p>得到 ep 后，通过 <code>theKernel = (void (*)(int, int, uint))ep;</code> 将 ep 格式化后传递给 theKernel ，这样 theKernel 函数就指向了内存中加载的OS镜像的真正入口地址</p><p>前面也提到了，每个开发板在 uboot 中都有唯一的机器码，这个编码用来验证开发板与 uboot 是否匹配，这个机器码还会传到内核中再次验证。这个机器码获取的第一顺序备选是环境变量machid，第二顺序备选是gd-&gt;bd-&gt;bi_arch_num(x210_sd.h 中的 #define MACH_TYPE 2456)</p><p>接下来就是传参的过程。先看看 Linux 的 Documentation/arm/Booting 中对 CPU 寄存器设置的描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- CPU register settings</span><br><span class="line">  r0 = 0,</span><br><span class="line">  r1 = machine type number discovered in (3) above.</span><br><span class="line">  r2 = physical address of tagged list in system RAM, or</span><br><span class="line">       physical address of device tree block (dtb) in system RAM</span><br></pre></td></tr></table></figure><p>通过读取 r0 r1 r2 这三个寄存器的值来设置 CPU ，r0 固定为0，r1 为前面提到的机器码，r2 为存放启动参数 tag 结构体的首地址</p><p>所以在 do_bootm_linux 通过 <code>theKernel (0, machid, bd-&gt;bi_boot_params);</code> 完成传参的过程</p><p>传参是通过 struct tag 这个结构体完成的，获取参数就是获取一个个 tag 的过程。这些 tag 也有着规定的格式，do_bootm_linux 中通过 setup_start_tag 和 setup_end_tag 函数设置 tag 的开始和结束，这个函数的作用就是设置当前 tag 的类型为 ATAG_CORE 和 ATAG_NONE ，用作 tag 起始终止位置的判别</p><p>需要注意的是，传参是一个很重要的过程，内核启动不成功与传参错误有很大关系</p><h1 id="uboot-启动4步骤总结">uboot 启动4步骤总结</h1><p>第一步：将内核搬移到DDR中</p><p>第二步：校验内核格式、CRC等</p><p>第三步：准备传参</p><p>第四步：跳转执行内核</p><h1 id="参考资料">参考资料</h1><ul><li>朱有鹏视频</li><li><a href="https://blog.csdn.net/czg13548930186/article/details/76383153" target="_blank" rel="noopener">u-boot 启动内核解析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识-uboot-和-内核-之间不可不说的关系&quot;&gt;认识 uboot 和 内核 之间不可不说的关系&lt;/h1&gt;
&lt;p&gt;uboot 镜像为 uboot.bin，Linux 镜像为 zImage&lt;/p&gt;
&lt;p&gt;嵌入式设备中的分区表是自己定义的，uboot 和内核中的分区表
      
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>uboot启动第二阶段分析</title>
    <link href="http://greedyhao.cc/2019/06/10/%E5%B7%A5%E4%BD%9C-x210-2019-06-10-uboot%E5%90%AF%E5%8A%A8%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%88%86%E6%9E%90/"/>
    <id>http://greedyhao.cc/2019/06/10/工作-x210-2019-06-10-uboot启动第二阶段分析/</id>
    <published>2019-06-10T14:57:44.000Z</published>
    <updated>2019-06-10T14:58:35.515Z</updated>
    
    <content type="html"><![CDATA[<p>之前介绍了 uboot 启动第一阶段，现在介绍启动的第二阶段</p><a id="more"></a><h1 id="启动阶段的工作">启动阶段的工作</h1><p>启动第一阶段的主要工作是对处理器的内部资源(如时钟、串口)、内存(ddr)初始化，并进行 uboot 的重定位，并跳转到启动第二阶段</p><p>启动第二阶段的主要工作则是对处理器的外部资源(iNand、网卡芯片...)、uboot环境(uboot命令、环境变量..)等初始化，并等待命令输入</p><h2 id="工作流程">工作流程</h2><p>正常情况下，在 uboot 的初始化工作完毕后，会启动内核，在启动内核后结束 uboot 程序。</p><p>但是用户可以阻止 uboot 的结束，进入 uboot 的命令行模式，就是一个 uboot 中的死循环；uboot 在死循环中不断接受命令、解析命令、执行命令</p><h1 id="start_armboot">start_armboot</h1><p>如果说启动第一阶段主要工作是 lowlevel_init 完成的，那么启动第二阶段的主要工作是 start_armboot 完成的</p><h2 id="相关变量介绍">相关变量介绍</h2><p><strong>init_fnc_ptr</strong></p><p>它是一个 init_fnc_t 类型的函数指针数组，通过 <code>typedef int (init_fnc_t) (void);</code> 定义</p><p><strong>gd</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm (<span class="meta-string">"r8"</span>)</span></span><br></pre></td></tr></table></figure><p>gd 这个变量通过 DECLARE_GLOBAL_DATA_PTR 定义，这个变量的作用是用来存储 uboot 需要使用到的全局变量，这样可以减少全局变量的数量，方便他人阅读代码。具体的作用可以从结构体成员中得知</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span><span class="title">global_data</span> &#123;</span></span><br><span class="line"><span class="keyword">bd_t</span>*bd;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>baudrate;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>have_console;<span class="comment">/* serial_init() was called */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>reloc_off;<span class="comment">/* Relocation Offset */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>env_addr;<span class="comment">/* Address  of Environment struct */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>env_valid;<span class="comment">/* Checksum of Environment valid? */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>fb_base;<span class="comment">/* base address of frame buffer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VFD</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>vfd_type;<span class="comment">/* display type */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">void</span>**jt;<span class="comment">/* jump table */</span></span><br><span class="line">&#125; <span class="keyword">gd_t</span>;</span><br></pre></td></tr></table></figure><p>gd 变量的结构体成员的功能基本可以从名字和注释中得知，不过对第一个成员 bd 的描述很少，这里再从 bd_t 中获取信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bd_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>bi_baudrate;<span class="comment">/* serial console baudrate */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>bi_ip_addr;<span class="comment">/* IP Address */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>bi_enetaddr[<span class="number">6</span>]; <span class="comment">/* Ethernet adress */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">environment_s</span>       *<span class="title">bi_env</span>;</span></span><br><span class="line">    ulong        bi_arch_number;<span class="comment">/* unique id for this board */</span></span><br><span class="line">    ulong        bi_boot_params;<span class="comment">/* where this board expects params */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>/* <span class="title">RAM</span> <span class="title">configuration</span> */</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">ulong start;</span><br><span class="line">ulong size;</span><br><span class="line">    &#125;bi_dram[CONFIG_NR_DRAM_BANKS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAS_ETH1</span></span><br><span class="line">    <span class="comment">/* second onboard ethernet port */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   bi_enet1addr[<span class="number">6</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">bd_t</span>;</span><br></pre></td></tr></table></figure><p>从 bd_t 的定义可以看出， bd 这个成员变量的主要作用是用来保存一些和板级相关的信息，如波特率、ip 地址等</p><p>因为 gd 这个变量需要被频繁访问，所以使用了 volatile ，避免编译器做出不适当的优化；另外使用 register asm (&quot;r8&quot;) 加速访问</p><h2 id="内存排布">内存排布</h2><p>上面提到的 gd bd 指针变量只是声明，此时还不能使用，需要给他们分配内存空间</p><p>分配内存的原则就是够用、紧凑，所以首先需要做的是为 gd bd 分配基地址</p><p>在 uboot 中计算 gd 和 bd 的基地址的方式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">gd_t</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_USE_IRQ</span></span><br><span class="line">gd_base -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">gd-&gt;bd = (<span class="keyword">bd_t</span>*)((<span class="keyword">char</span>*)gd - <span class="keyword">sizeof</span>(<span class="keyword">bd_t</span>));</span><br></pre></td></tr></table></figure><p>其中 CFG_UBOOT_BASE=0x33e00000 CFG_UBOOT_SIZE=2MB CFG_MALLOC_LEN=912KB CFG_STACK_SIZE=512KB gd_t=36字节 bd_t≈44字节</p><p>从而可以得到内存分配如图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/bl1_0.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="部分外设初始化工作">部分外设初始化工作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*init_fnc_ptr)() != <span class="number">0</span>) &#123;</span><br><span class="line">hang ();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化工作是通过一个 for 循环完成的，使用先前定义的 init_fnc_ptr 变量去指向一个预先定义的函数指针数组 init_sequence ，在 init_sequence 中存储了用来初始化外设的函数指针。通过 for 循环依次执行每一个初始化函数，一旦返回的值不为0，就停止程序的运行并报错</p><p>init_sequence 的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init_fnc_t</span> *init_sequence[] = &#123;</span><br><span class="line">cpu_init,<span class="comment">/* basic cpu dependent setup */</span></span><br><span class="line">board_init,<span class="comment">/* basic board dependent setup */</span></span><br><span class="line">interrupt_init,<span class="comment">/* set up exceptions */</span></span><br><span class="line">env_init,<span class="comment">/* initialize environment */</span></span><br><span class="line">init_baudrate,<span class="comment">/* initialze baudrate settings */</span></span><br><span class="line">serial_init,<span class="comment">/* serial communications setup */</span></span><br><span class="line">console_init_f,<span class="comment">/* stage 1 init of console */</span></span><br><span class="line">display_banner,<span class="comment">/* say that we are here */</span></span><br><span class="line">#<span class="keyword">if</span> defined(CONFIG_DISPLAY_CPUINFO)</span><br><span class="line">print_cpuinfo,<span class="comment">/* display cpu info (and speed) */</span></span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> defined(CONFIG_DISPLAY_BOARDINFO)</span><br><span class="line">checkboard,<span class="comment">/* display board info */</span></span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)</span><br><span class="line">init_func_i2c,</span><br><span class="line">#endif</span><br><span class="line">dram_init,<span class="comment">/* configure available RAM banks */</span></span><br><span class="line">display_dram_config,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>cpu_init</strong></p><p>cpu_init 只有当允许了中断的情况下才会做中断栈的设置工作，因为我们 uboot 中没有允许中断，所以这里相当于什么都没做</p><p><strong>board_init</strong></p><p>这里进行了网卡的初始化，本人使用的开发板使用的网卡芯片是 dm9000 ，所以使用了 dm9000_pre_init 进行预初始化操作</p><p>网卡的驱动是不需要修改的，关键是移植，dm9000_pre_init 需要做的事就是移植相关，就像 stm32 一样，使用 GPIO 前，需要进行初始化的工作，这里就是做这些的工作</p><p>除了网卡的初始化，这里还在 bd 中添加了机器码和参数内存地址</p><p>机器码是用来软件和开发板之间配对用的，避免将软件下载到错误的开发板导致损失。机器码是唯一的，需要向 uboot 进行申请，当然学习 uboot 的时候可以随意填写，只要 uboot 中配置的机器码和 linux 内核中的机器码一致即可</p><p>这里的参数地址中存放的是需要想内核中传送的字符串参数(bootargs)的地址， uboot 启动的时候是通过 r0 r1 r2 来传递参数，其中一个寄存器放的就是 bd-&gt;bi_boot_params 中的值</p><p><strong>interrupt_init</strong></p><p>这里是对定时器4做的相关初始化，进行了10ms的定时</p><p><strong>env_init</strong></p><p>这里是环境变量的初始化，通过 x210_sd.h 中定义的宏 CFG_ENV_IS_IN_AUTO 分析可以知道，env_init 应该使用的是 env_auto.c 中定义的 env_init</p><p><strong>init_baudrate</strong></p><p>首先是从 uboot 环境变量中读取波特率，如果环境变量中没有定义波特率就使用 x210_sd.h 定义的波特率</p><p>uboot 环境变量可以在 uboot 中使用 print 查看</p><p><strong>serial_init</strong></p><p>串口初始化，主要工作在汇编中完成了，这里没有做什么事</p><p><strong>console_init_f</strong></p><p>控制台初始化第一阶段，一般第一阶段后缀为 _f，第二阶段后缀为 _r</p><p><strong>display_banner</strong></p><p>用来输出 uboot 的 logo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char version_string[] =</span><br><span class="line">U_BOOT_VERSION&quot; (&quot; __DATE__ &quot; - &quot; __TIME__ &quot;)&quot;CONFIG_IDENT_STRING;</span><br></pre></td></tr></table></figure><p>uboot 启动时输出的 version_string 是定义在主 Makefile 中的，在编译时自动生成的 include/version_autogenerated.h 就会包含 U_BOOT_VERSION 相关信息</p><p><strong>print_cpuinfo</strong></p><p>这里可以输出 CPU 的相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CPU:  S5PV210@1000MHz(OK)</span><br><span class="line">        APLL = 1000MHz, HclkMsys = 200MHz, PclkMsys = 100MHz</span><br><span class="line">        MPLL = 667MHz, EPLL = 96MHz</span><br><span class="line">                       HclkDsys = 166MHz, PclkDsys = 83MHz</span><br><span class="line">                       HclkPsys = 133MHz, PclkPsys = 66MHz</span><br><span class="line">                       SCLKA2M  = 200MHz</span><br></pre></td></tr></table></figure><p><strong>dram_init</strong></p><p>这里做的是 ddr 软件方面的初始化</p><p>因为嵌入式设备是定制性的，不像 PC 机都是标准化的，可以自动获取 ddr 的片数、大小</p><p>因此在 uboot 中，需要人为添加 ddr 的相关配置信息，相当于是将 ddr 的配置信息写入 gd-&gt;bd-&gt;bi_dram 这个数组中</p><p><strong>display_dram_config</strong></p><p>打印 dram 信息</p><h2 id="堆管理器初始化">堆管理器初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem_malloc_init (CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE);</span><br></pre></td></tr></table></figure><p>这样堆的地址如下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/bl1_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="开发板专有初始化">开发板专有初始化</h2><p>为了保证 uboot 的通用性，三星使用了宏来判断当前的开发板的型号，并做对应的初始化</p><p>这里的初始化是针对 MMC 的，通过 Makefile 中的脚本，配置开发板是 sd 还是 onenand 启动；然后对 MMC 的初始化根据宏做相应的处理</p><h2 id="环境变量重定位">环境变量重定位</h2><p>uboot 的环境变量需要重定位到 ddr 中才能使用</p><p>在 env_relocate 中，先是通过宏判读环境变量是否嵌入在代码段中；本人的开发板的环境变量在 SD 卡中，所以直接跳过，直接分配一个缓存准备用来存放环境变量</p><p>uboot 第一次启动时，因为没有烧录 env 分区，gd-&gt;env_valid 应当为0，这时候会使用 uboot 的默认系统变量，并写入到 SD 卡的 env 分区中</p><h2 id="控制台初始化">控制台初始化</h2><p>console_init_r 做的是控制台的第二阶段的初始化，主要是进行控制台的软件方面的配置</p><p>重定位了 stdin stdout stderr</p><h2 id="网卡芯片初始化">网卡芯片初始化</h2><p>eth_initialize 对网卡芯片本身进行初始化</p><h2 id="开机logo显示">开机logo显示</h2><p>x210_preboot_init 进行开发板启动前的初始化，开启 lcd 显示开机 logo</p><p>logo 一般是使用软件制作的数组</p><h2 id="通过sd卡烧录系统">通过sd卡烧录系统</h2><p>通过 check_menu_update_from_sd 会判断开发部的 left 按键是否按下，开发板会在按键按下的时候，进入更新模式，读取 SD 卡中的镜像烧录系统</p><p>使用 SD 卡烧录比 fastboot 的方式简单、高效，一般用于量产的场景</p><h2 id="死循环">死循环</h2><p>主要是有三个功能</p><ul><li>命令解析器</li><li>开机倒计时</li><li>命令补全</li></ul><h1 id="总结">总结</h1><p>以下来自朱老师总结的 uboot 的工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">init_sequence</span><br><span class="line">cpu_init空的</span><br><span class="line">board_init网卡、机器码、内存传参地址</span><br><span class="line">dm9000_pre_init网卡</span><br><span class="line">gd-&gt;bd-&gt;bi_arch_number机器码</span><br><span class="line">gd-&gt;bd-&gt;bi_boot_params内存传参地址</span><br><span class="line">interrupt_init定时器</span><br><span class="line">env_init</span><br><span class="line">init_baudrategd数据结构中波特率</span><br><span class="line">serial_init空的</span><br><span class="line">console_init_f空的</span><br><span class="line">display_banner打印启动信息</span><br><span class="line">print_cpuinfo打印CPU时钟设置信息</span><br><span class="line">checkboard检验开发板名字</span><br><span class="line">dram_initgd数据结构中DDR信息</span><br><span class="line">display_dram_config打印DDR配置信息表</span><br><span class="line">mem_malloc_init初始化uboot自己维护的堆管理器的内存</span><br><span class="line">mmc_initializeinand/SD卡的SoC控制器和卡的初始化</span><br><span class="line">env_relocate环境变量重定位</span><br><span class="line">gd-&gt;bd-&gt;bi_ip_addrgd数据结构赋值</span><br><span class="line">gd-&gt;bd-&gt;bi_enetaddrgd数据结构赋值</span><br><span class="line">devices_init空的</span><br><span class="line">jumptable_init不用关注的</span><br><span class="line">console_init_r真正的控制台初始化</span><br><span class="line">enable_interrupts空的</span><br><span class="line">loadaddr、bootfile 环境变量读出初始化全局变量</span><br><span class="line">board_late_init空的</span><br><span class="line">eth_initialize空的</span><br><span class="line">x210_preboot_initLCD初始化和显示logo</span><br><span class="line">check_menu_update_from_sd检查自动更新</span><br><span class="line">main_loop主循环</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前介绍了 uboot 启动第一阶段，现在介绍启动的第二阶段&lt;/p&gt;
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>uboot启动阶段分析三</title>
    <link href="http://greedyhao.cc/2019/06/04/%E5%B7%A5%E4%BD%9C-x210-2019-06-04-uboot%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E5%88%86%E6%9E%90%E4%B8%89/"/>
    <id>http://greedyhao.cc/2019/06/04/工作-x210-2019-06-04-uboot启动阶段分析三/</id>
    <published>2019-06-04T12:51:55.000Z</published>
    <updated>2019-06-04T13:05:54.480Z</updated>
    
    <content type="html"><![CDATA[<p>这里继续 lowlevel_init 中的内容</p><a id="more"></a><p>这个函数是为了进行底层的一些初始化</p><h1 id="lowlevel_init">lowlevel_init</h1><h2 id="预备环节">预备环节</h2><p><strong>检查复位状态</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/bl0_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>lowlevel_init 中会对控制复位的寄存器中的值的16位和18位进行检测，判断当前处理器处于 DEEP-IDLE 还是 SLEEP 状态</p><p>对于不同的复位状态，有不同的处理方式</p><p>好比刚上电需要初始化 ddr，而从睡眠中唤醒可以直接使用 ddr</p><p><strong>IO 恢复</strong></p><p><strong>关看门狗</strong></p><p>避免看门狗在初始化的过程中复位</p><p><strong>外部SRAM SROM初始化</strong></p><p><strong>供电锁存</strong></p><h2 id="判断运行在sram还是ddr中">判断运行在sram还是ddr中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* when we already run in ram, we don&apos;t need to relocate U-Boot.</span><br><span class="line"> * and actually, memory controller must be configured before U-Boot</span><br><span class="line"> * is running in ram.</span><br><span class="line"> */</span><br><span class="line">ldrr0, =0xff000fff</span><br><span class="line">bicr1, pc, r0/* r0 &lt;- current base addr of code */</span><br><span class="line">ldrr2, _TEXT_BASE/* r1 &lt;- original base addr in ram */</span><br><span class="line">bicr2, r2, r0/* r0 &lt;- current base addr of code */</span><br><span class="line">cmp     r1, r2                  /* compare r0, r1                  */</span><br><span class="line">beq     1f/* r0 == r1 then skip sdram init   */</span><br></pre></td></tr></table></figure><p>这段代码用来判断当前代码运行的位置，然后做不同的处理</p><p>前文也说到了，复位时有不同的情况，冷启动的时候需要初始化的外设如 ddr 是用不了的，这种情况需要做初始化；而休眠状态则不用</p><p>我们都知道 PC 中存储着下条指令的地址，通过获取 PC 的值，就可以知道当前的运行地址了</p><p>为了方便比较，将无关位清0。这里三星官方只留了[3:5]位进行比较</p><p>r1 中存储着 PC 清0后的值，r2 中存储着 ram 基地址清0后的值，当 r1 等于 r2 时说明代码还在 ram 中，需要对系统时钟、内存做初始化；不同就跳过初始化</p><p>系统时钟的初始化是硬件相关的，为了方便移植，大量使用了宏进行地址展开，通过对这些宏进行地址的设定就可以完成系统时钟的初始化</p><p>内存的初始化也是一样的方式，通过在配置文件中使用宏进行相关的地址定义来实现。uboot 中可用的物理地址范围为：0x30000000-0x4FFFFFFF一共512MB，其中0x30000000-0x3FFFFFFF为DM0，0x40000000-0x4FFFFFFF为DM1</p><p>之后就是串口的初始化，在串口初始化完成后会发送'O'</p><p>然后是对 TrustZone 初始化，TrustZone 是为消费电子产品构建一个安全框架来抵御各种可能的攻击的硬件架构</p><p>在检查完复位状态和关闭 ABB 后(ABB在网上也没搜出是什么东西)，就会在串口打印‘K'</p><p>整个 lowlevel_init 完成的标志就是串口会打印 'OK’</p><h1 id="回到-start.s-中">回到 start.s 中</h1><p>lowlevel_init 结束了，它主要的工作是：关看门狗、开发板供电锁存、系统时钟初始化、内存初始化、其他初始化、打印&quot;OK&quot;</p><h2 id="重新设置栈">重新设置栈</h2><p>之前设置栈是在进入 lowlevel_init 前，当时 ddr 还没有初始化，只能使用内部的 sram，所以能使用的空间非常有限</p><p>为了准备 c 的运行环境，同时也可以防止栈溢出，重新设置栈，将栈设置在 ddr 中</p><h2 id="再次检查运行位置">再次检查运行位置</h2><p>这里检查程序运行位置是为了判断是否需要将 uboot 重定位，冷启动的情况下，程序还运行在 ram 中，需要重定位到 ddr 中</p><p>uboot 启动分为两个部分，第一部分(16kb或8kb)在系统启动的时候，自动从启动介质中加载到处理器内部的 sram 中运行，但是第二部分还在启动介质中；第一部分的工作在 lowlevel_init 内基本完成了，在第一部分的启动程序结束前，需要将第二部分的代码加载到 ddr 中来</p><h2 id="uboot-重定位">uboot 重定位</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/bl0_4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>uboot 先将 0xD0037488 这个地址使用 ldr 装载到 r0 寄存器中，再将 r0 中的值与 0xEB200000 进行比较</p><p>0xD0037488 中存储着全局变量，通过硬件设置当前 uboot 的启动通道，如果是 SD0 就是 EB000000，SD1 就是 EB200000</p><p>这里是为了判断 uboot 的 BL1 部分是否已经拷贝</p><p>没有拷贝的话，下面还要进行启动方式的判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldrr0, =INF_REG_BASE</span><br><span class="line">ldrr1, [r0, #INF_REG3_OFFSET]</span><br></pre></td></tr></table></figure><p>这里判断使用的寄存器中的值，在上面判断判断启动方式的时候已经写入了。这里使用的是 SD 卡启动，所以会跳转到 mmcsd_boot 进行代码的重定位</p><p>在 mmcsd_boot 下可以看到，代码的重定位是靠 movi_bl2_copy 完成的</p><p>movi_bl2_copy 位于 uboot/cpu/s5pc11x/movi.c 中</p><h2 id="mmu-相关设置">MMU 相关设置</h2><p>MMU 可以实现虚拟地址和物理地址之间的映射</p><p>物理地址是设备在设计时赋予的地址，无法修改；虚拟地址是软件定义的地址</p><p>MMU 可以在物理地址与虚拟地址之间搭建桥梁，它有很多好处，比如可以控制物理内存的访问权限、给进程分配的内存总和能够大于物理内存大小等等</p><p>MMU 是一个硬件结构，全程是 memory management unit ，对它的控制可以通过对 CP15 寄存器的控制完成</p><p>下面开始介绍 MMU 启动的过程</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/bl0_5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>访问 CP15 的指令有 MCR MRC，CP15 内部共有16个寄存器，各部分功能如上图</p><p>MMU 的启动有以下几个步骤</p><p>通过对 c3 寄存器的控制，获取域访问权限</p><p>设置 TTB(translation table base) ，通过 TTB 这个表可以映射虚拟地址与物理地址，单独一个地址是不够的，程序不可能只使用一个地址的空间；在映射空间的时候，是以块为单位的，块的大小是由 MMU 的性能和开发者的选择决定的。在ARM中支持3种块大小，细表1KB、粗表4KB、段1MB。获取 MMU 的基地址，写入到 c2 寄存器中就完成了 TTB 的设置。</p><p>此时还没有开启 MMU，通过对 c1 寄存器的置1就可以开启 MMU</p><h3 id="映射表细节">映射表细节</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * MMU Table for SMDKC110</span><br><span class="line"> * 0x0000_0000 -- 0xBFFF_FFFF =&gt; Not Allowed</span><br><span class="line"> * 0xB000_0000 -- 0xB7FF_FFFF =&gt; A:0xB000_0000 -- 0xB7FF_FFFF</span><br><span class="line"> * 0xC000_0000 -- 0xC7FF_FFFF =&gt; A:0x3000_0000 -- 0x37FF_FFFF</span><br><span class="line"> * 0xC800_0000 -- 0xDFFF_FFFF =&gt; Not Allowed</span><br><span class="line"> * 0xE000_0000 -- 0xFFFF_FFFF =&gt; A:0xE000_0000 -- 0XFFFF_FFFF</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>uboot 内部只做了简单的映射，除了上面的 Not Allowed 的地址，还是可以直接访问物理地址</p><p>虽然 uboot 中使用的是比较大的块大小，段的方式映射，但是4G/1MB=4096，如果一个个段进行映射，工作量还是很大的，为了方便映射，在 uboot 中使用了循环的方式进行映射</p><h2 id="再次设置栈">再次设置栈</h2><p><code>ldr    sp, =(CFG_UBOOT_BASE + CFG_UBOOT_SIZE - 0x1000)</code></p><p>CFG_UBOOT_SIZE 为 2MB，这里将栈设置在了 uboot 上方 2MB - 0x1000 的位置</p><p>这样可以避免内存空间被浪费，也可以保证栈空间的安全</p><h2 id="清理-bss-段">清理 bss 段</h2><p>通过从链接脚本中获得的 _bss_start 和 _bss_end 地址，将 bss 段清0</p><p>在将 bss 段清0后，通过将 start_armboot 的地址传入 PC 中，让 uboot 进入启动的第二阶段</p><h1 id="uboot-第一阶段主要工作">uboot 第一阶段主要工作</h1><ul><li>设置异常向量表</li><li>处理器复位</li><li>lowlevel_init</li><li>uboot 重定位</li><li>MMU 建立映射表并启动</li><li>准备启动 uboot 第二阶段</li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里继续 lowlevel_init 中的内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>栈和帧指针使用方法</title>
    <link href="http://greedyhao.cc/2019/05/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-asm-2019-05-27-%E6%A0%88%E5%92%8C%E5%B8%A7%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://greedyhao.cc/2019/05/27/编程语言-asm-2019-05-27-栈和帧指针使用方法/</id>
    <published>2019-05-27T12:15:25.000Z</published>
    <updated>2019-05-27T12:21:23.398Z</updated>
    
    <content type="html"><![CDATA[<p>这篇主要是围绕 SP FP PC LR 寄存器进行介绍，不理解的可以一起讨论下，我也是今天才开始学习这些</p><a id="more"></a><h1 id="汇编基础知识">汇编基础知识</h1><ul><li>处理器寄存器被指定为R0、R1等。</li><li>MOVE指令的源位于左侧，目标位于右侧。</li><li>伪处理程序中的堆栈从高地址增长到低地址。因此，push会导致堆栈指针的递减。pop会导致堆栈指针的增量。</li><li>寄存器 sp(stack pointer) 用于指向堆栈。</li><li>寄存器 fp(frame pointer) 用作帧指针。帧指针充当被调用函数和调用函数之间的锚。</li><li>当调用一个函数时，该函数首先将 fp 的当前值保存在堆栈上。然后，它将 sp 寄存器的值保存在 fp 寄存器中。然后递减 sp 寄存器来为本地变量分配空间。</li><li>fp 寄存器用于访问本地变量和参数，局部变量位于帧指针的负偏移量处，传递给函数的参数位于帧指针的正偏移量。</li><li>当函数返回时， fp 寄存器被复制到 sp 寄存器中，这将释放用于局部变量的堆栈，函数调用者的 fp 寄存器的值由pop从堆栈中恢复。</li></ul><h2 id="汇编指令介绍">汇编指令介绍</h2><p>首先先介绍涉及到的主要的汇编指令 PUSH 和 POP</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUSH&#123;cond&#125; reglist</span><br><span class="line">POP&#123;cond&#125; reglist</span><br></pre></td></tr></table></figure><p>cond</p><p>是一个可选的条件代码（请参阅条件执行）。</p><p>reglist</p><p>是一个非空的寄存器列表，括在大括号内。可以包含寄存器范围。 如果包含多个寄存器或寄存器范围，则必须用逗号分隔。</p><p>使用示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH    &#123;r0,r4-r7&#125;</span><br><span class="line">PUSH    &#123;r2,lr&#125;</span><br><span class="line">POP     &#123;r0,r10,pc&#125; ; no 16-bit version available</span><br></pre></td></tr></table></figure><p>简单的说，就是 PUSH 可以将选择的寄存器的值<strong>压栈</strong>，可以将 LR 寄存器的值一起压栈；而 POP 可以将选择寄存器的值从栈中<strong>弹出</strong>，可以选择弹出到 PC 寄存器，一般用于子函数回调</p><h2 id="其他背景知识介绍">其他背景知识介绍</h2><p>目标机是 ARM 架构处理器，内部为向下增长堆栈</p><p>向下增长意思堆栈是向低地址方向生长,称为递减堆栈</p><p>使用的是 arm-none-linux-gnueabi- 系列的交叉编译器</p><p>使用 gcc 编译，使用 objdump 反汇编</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arm-none-linux-gnueabi-gcc -c c_call_fun.c </span><br><span class="line">arm-none-linux-gnueabi-objdump -d c_call_fun.o &gt; c_call_fun_s</span><br></pre></td></tr></table></figure><h1 id="回到正题">回到正题</h1><p>之所以介绍这部分相关的知识是为了方便理解汇编中子函数调用子函数的过程</p><p>下面将从一个简单的示例进行介绍</p><h2 id="被调用函数框架一">被调用函数框架一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;fun_2&gt;:</span><br><span class="line">push&#123;fp&#125;</span><br><span class="line">; code of the function</span><br><span class="line">pop&#123;fp&#125;</span><br><span class="line">bxlr</span><br></pre></td></tr></table></figure><p>我们先把被调用函数的功能模块去除了，直接看它的主体框架</p><p>首先是对 fp(frame pointer) 压栈</p><p>压栈是为了保护该寄存器中的内容，弹出是为了恢复该寄存器中的值，为什么需要这么做在下面进行解释</p><p>最后的 <code>bx lr</code> 的作用等同于 <code>mov  pc,lr</code></p><p>因为在调用者中使用了 bl 调用子函数的时候，会将当前 PC 的值保存在 LR 中，这时将 LR 中的值载入到 PC 中，可以使得程序运行位置返回调用者中</p><p>这样就完成了子函数的调用</p><h2 id="被调用函数框架二">被调用函数框架二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;fun_2&gt;:</span><br><span class="line">push&#123;fp&#125;</span><br><span class="line">addfp, sp, #0</span><br><span class="line">subsp, sp, #12</span><br><span class="line">; code of the function</span><br><span class="line">addsp, fp, #0</span><br><span class="line">pop&#123;fp&#125;</span><br><span class="line">bxlr</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/prog_lang/asm/stack_fp_0.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这部分代码做的事情如上图</p><p>在上文的基础上，通过减小 sp 的地址，为局部数据的存放开启了12字节的空间，也就是 fp 和 sp 中间的空间</p><p>前面介绍了 fp 的作用是连接调用函数地方和被调用函数地方</p><p>在刚调用子函数的时候，fp 还指向的是上一个函数的堆栈空间，为了方便程序返回调用者时能够正常运行，需要保存旧的 fp 中的值，再指向新的地址，来分配空间</p><p>最后子程序运行完毕后，将 fp 中的值传递给 sp ，相当于让 sp 中的值恢复到了进入子程序前的情况，这个操作叫做释放内存</p><h2 id="被调用函数框架三">被调用函数框架三</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int local_num = 1;</span><br><span class="line"></span><br><span class="line">int fun_2(int num)</span><br><span class="line">&#123;</span><br><span class="line">    return num+local_num;</span><br><span class="line">&#125;</span><br><span class="line">-----------------</span><br><span class="line">&lt;fun_2&gt;:</span><br><span class="line">push&#123;fp&#125;; (str fp, [sp, #-4]!)</span><br><span class="line">addfp, sp, #0</span><br><span class="line">subsp, sp, #12</span><br><span class="line">strr0, [fp, #-8]</span><br><span class="line">ldrr3, [pc, #24]; 30 &lt;fun_2+0x30&gt;</span><br><span class="line">ldrr2, [r3]</span><br><span class="line">ldrr3, [fp, #-8]</span><br><span class="line">addr3, r2, r3</span><br><span class="line">movr0, r3</span><br><span class="line">addsp, fp, #0</span><br><span class="line">pop&#123;fp&#125;</span><br><span class="line">bxlr</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/prog_lang/asm/stack_fp_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这部分的功能示意图如上</p><p>这段代码访问了调用者的局部数据和被调用者的局部数据，从这段代码可以看出，被调用者的局部数据在 fp 的负偏移的地址，调用者的局部数据在 fp 的正偏移地址</p><h2 id="调用者">调用者</h2><p>上一篇我们提到了多层子函数调用的问题</p><p>就是 LR 寄存器只有一个，当使用 bl 调用子函数的时候，会将当前的 PC 存入 LR 中，这样子函数运行完会回到调用函数的地址继续运行程序</p><p>但是在子函数中再次调用子函数的时候，就不能直接使用 bl 调用子函数了，因为那样会把之前的 LR 寄存器中的值覆盖，导致程序无法正常运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push&#123;fp, lr&#125;</span><br><span class="line">; code of the function</span><br><span class="line">pop&#123;fp, pc&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是 main 函数的部分反汇编代码</p><p>我们都知道 main 函数也类似于一个子函数，在子函数中调用另一个子函数，需要存储当前的 LR 中的值。所以在 main 中将 LR 寄存器压栈，在 main 运行完后，将 LR 寄存器的值弹出，恢复程序的运行</p><h1 id="本文的代码">本文的代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">int local_num = 1;</span><br><span class="line"></span><br><span class="line">int fun_2(int num)</span><br><span class="line">&#123;</span><br><span class="line">    return num+local_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int num = 1;</span><br><span class="line"></span><br><span class="line">    num = fun_2(num);</span><br><span class="line">&#125;</span><br><span class="line">-------------------------</span><br><span class="line">c_call_fun.o:     file format elf32-littlearm</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;fun_2&gt;:</span><br><span class="line">   0:e52db004 push&#123;fp&#125;; (str fp, [sp, #-4]!)</span><br><span class="line">   4:e28db000 addfp, sp, #0</span><br><span class="line">   8:e24dd00c subsp, sp, #12</span><br><span class="line">   c:e50b0008 strr0, [fp, #-8]</span><br><span class="line">  10:e59f3018 ldrr3, [pc, #24]; 30 &lt;fun_2+0x30&gt;</span><br><span class="line">  14:e5932000 ldrr2, [r3]</span><br><span class="line">  18:e51b3008 ldrr3, [fp, #-8]</span><br><span class="line">  1c:e0823003 addr3, r2, r3</span><br><span class="line">  20:e1a00003 movr0, r3</span><br><span class="line">  24:e28bd000 addsp, fp, #0</span><br><span class="line">  28:e8bd0800 pop&#123;fp&#125;</span><br><span class="line">  2c:e12fff1e bxlr</span><br><span class="line">  30:00000000 .word0x00000000</span><br><span class="line"></span><br><span class="line">00000034 &lt;main&gt;:</span><br><span class="line">  34:e92d4800 push&#123;fp, lr&#125;</span><br><span class="line">  38:e28db004 addfp, sp, #4</span><br><span class="line">  3c:e24dd008 subsp, sp, #8</span><br><span class="line">  40:e3a03001 movr3, #1</span><br><span class="line">  44:e50b3008 strr3, [fp, #-8]</span><br><span class="line">  48:e51b0008 ldrr0, [fp, #-8]</span><br><span class="line">  4c:ebfffffe bl0 &lt;fun_2&gt;</span><br><span class="line">  50:e1a03000 movr3, r0</span><br><span class="line">  54:e50b3008 strr3, [fp, #-8]</span><br><span class="line">  58:e24bd004 subsp, fp, #4</span><br><span class="line">  5c:e8bd8800 pop&#123;fp, pc&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料">参考资料</h1><ul><li><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204ic/Babefbce.html" target="_blank" rel="noopener">RealView 编译工具 《汇编器指南》</a></li><li><a href="https://blog.csdn.net/IOT_AI/article/details/69525018" target="_blank" rel="noopener">ARM 指令集 之 PUSH and POP</a></li><li><a href="https://www.eventhelix.com/RealtimeMantra/Basics/CToAssemblyTranslation.htm" target="_blank" rel="noopener">C to assembly: function calling</a></li><li><a href="https://www.zhihu.com/question/22444939" target="_blank" rel="noopener">函数调用过程中栈到底是怎么压入和弹出的？</a></li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇主要是围绕 SP FP PC LR 寄存器进行介绍，不理解的可以一起讨论下，我也是今天才开始学习这些&lt;/p&gt;
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
      <category term="asm" scheme="http://greedyhao.cc/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>uboot启动阶段分析二</title>
    <link href="http://greedyhao.cc/2019/05/26/%E5%B7%A5%E4%BD%9C-x210-2019-05-26-uboot%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E5%88%86%E6%9E%90%E4%BA%8C/"/>
    <id>http://greedyhao.cc/2019/05/26/工作-x210-2019-05-26-uboot启动阶段分析二/</id>
    <published>2019-05-26T15:17:53.000Z</published>
    <updated>2019-05-27T08:43:47.635Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="物理基址定义">物理基址定义</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_TEXT_PHY_BASE:</span><br><span class="line">.wordCFG_PHY_UBOOT_BASE</span><br></pre></td></tr></table></figure><p><code>start.s</code> 中使用 <code>_TEXT_PHY_BASE</code> 存放物理基址。这个变量很重要，因为我们在 u-boot 中使用 MMU ，在 MMU 没有开启之前，需要这个变量来保证程序能在正确的地址运行</p><p>通过在 u-boot 源码中全局搜索可以发现， <code>CFG_PHY_UBOOT_BASE</code> 定义在 <code>uboot/include/configs/x210_sd.h</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMORY_BASE_ADDRESS0x30000000</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFG_PHY_UBOOT_BASEMEMORY_BASE_ADDRESS + 0x3e00000</span></span><br></pre></td></tr></table></figure><p><code>CFG_PHY_UBOOT_BASE</code> 这个宏是在 <code>MEMORY_BASE_ADDRESS</code> 的位置上偏移了 0x3e00000 的空间</p><h1 id="链接脚本需要的变量">链接脚本需要的变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.globl _bss_start</span><br><span class="line">_bss_start:</span><br><span class="line">.word __bss_start</span><br><span class="line"></span><br><span class="line">.globl _bss_end</span><br><span class="line">_bss_end:</span><br><span class="line">.word _end</span><br></pre></td></tr></table></figure><p><code>_bss_start</code> <code>_bss_end</code> 这两个变量之前也在链接脚本中见过</p><p>BSS 段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域</p><p>BSS 段使用前需要清0，通过在这里提供 BSS 段的地址，方便链接时清0</p><h1 id="复位">复位</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reset:</span><br><span class="line">/*</span><br><span class="line"> * set the cpu to SVC32 mode and IRQ &amp; FIQ disable</span><br><span class="line"> */</span><br><span class="line">@;mrsr0,cpsr</span><br><span class="line">@;bicr0,r0,#0x1f</span><br><span class="line">@;orrr0,r0,#0xd3</span><br><span class="line">@;msrcpsr,r0</span><br><span class="line">msrcpsr_c, #0xd3@ I &amp; F disable, Mode: 0x13 - SVC</span><br></pre></td></tr></table></figure><p>到这里就是 u-boot 真正的复位代码了</p><p><strong>MSR</strong> 指令用亍将操作数的内容传送到程序状态寄存器的特定域中</p><p><strong>cpsr</strong> 是 ARM 架构的当前程序状态寄存器，而 <strong>cpsr_c</strong> 是程序状态寄存器的后8位，也就是控制位</p><p>cpsr 寄存器的描述如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/bl0_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>I 和 F 位对应的是 IRQ 和 FIQ 中断的标志位，置1为关闭</p><p>因为模式位是前5位控制的，所以 0xd3 相当于 0x13，对应的就是 SVC(管理)模式</p><p>再加上代码中的注释，我们就可以知道这段代码的作用就是让处理器进入 SVC 模式并关闭中断</p><h1 id="cpu_init_crit">cpu_init_crit</h1><p>这里是为了初始化一些重要的寄存器和内存的时钟</p><p>cpu_init_crit 只会在重启的时候运行，当 u-boot 在 ram 中的时候不会运行</p><p>这部分做了这些事 1. 重新初始化开启 L2 cache 2. 刷新 L1 的数据和指令 cache 3. 关闭 MMU 4. 读取启动介质选择</p><p>##　读取启动信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldrr0, =PRO_ID_BASE        @ PRO_ID_BASE=E000 0000</span><br><span class="line">ldrr1, [r0,#OMR_OFFSET]    @ OMR_OFFSET=0000 0004</span><br><span class="line">bicr2, r1, #0xffffffc1</span><br></pre></td></tr></table></figure><p>这段代码目的是从 E000 0004 这个寄存器读取电平信息，这个寄存器是 OM 引脚的地址。通过设置　OM 引脚的电平，就可以设置　ｕ-boot 的启动介质</p><p>bic 的作用是为了清除无关的位，方便后面进行启动介质的判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* NAND BOOT */</span><br><span class="line">cmpr2, #0x0@ 512B 4-cycle</span><br><span class="line">moveqr3, #BOOT_NAND</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* SD/MMC BOOT */</span><br><span class="line">cmp     r2, #0xc</span><br><span class="line">moveq   r3, #BOOT_MMCSD</span><br><span class="line"></span><br><span class="line">/* NOR BOOT */</span><br><span class="line">cmp     r2, #0x14</span><br><span class="line">moveq   r3, #BOOT_NOR</span><br></pre></td></tr></table></figure><p>通过判断前面存入 r2 的值，得到不同的启动介质的信息</p><h2 id="lowlevel_init">lowlevel_init</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldrsp, =0xd0036000 /* end of sram dedicated to u-boot */</span><br><span class="line">subsp, sp, #12/* set stack */</span><br><span class="line">movfp, #0</span><br><span class="line"></span><br><span class="line">bllowlevel_init/* go setup pll,mux,memory */</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/uboot/bl0_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看出 0xd0036000 是 sram 的地址空间，此时　ddr 还没有初始化完成，只能使用不需要初始化的　sram</p><p>通过 sub 创建了一个 stack，再让 fp(栈帧指针)指向 stack 的开头(fp 用作栈的开头，sp 作为栈的当前位置，fp 和 sp 一起组成了一个栈帧)</p><p>设置 stack 是为了用来存储 LR 的值，因为当前是被调用的子函数中， LR 中存储着当前子函数的范围地址，如果直接使用 bl 调用子函数，就会丢失当前子函数的返回地址</p><p>所以在子函数中调用子函数时，需要先将当前的 LR 压栈</p><h1 id="后记">后记</h1><p>关于 SP FP PC LR 寄存器有空会说说的，我也是在学习汇编才接触到这些寄存器，也是在看了些资料才稍微了解了些</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;物理基址定义&quot;&gt;物理基址定义&lt;/h1&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
      
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>uboot启动阶段分析一</title>
    <link href="http://greedyhao.cc/2019/05/25/%E5%B7%A5%E4%BD%9C-x210-2019-05-25-uboot%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E5%88%86%E6%9E%90%E4%B8%80/"/>
    <id>http://greedyhao.cc/2019/05/25/工作-x210-2019-05-25-uboot启动阶段分析一/</id>
    <published>2019-05-25T12:53:02.000Z</published>
    <updated>2019-05-27T08:43:52.699Z</updated>
    
    <content type="html"><![CDATA[<p>从上一章的链接脚本分析中，我们知道了uboot的程序是从*ENTRY(_start)*开始的</p><p>在整个uboot工程下搜索**_start<strong>，可以找到一个</strong>start.S**文件包含了这个label，因此uboot启动的分析从这个文件开始</p><a id="more"></a><h1 id="头文件分析">头文件分析</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_ENABLE_MMU)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/proc/domain.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regs.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>start.S</strong>一开始include的<strong>config.h</strong>这个头文件是由<em>$(TOPDIR)/mkconfig</em>自动生成的，具体生成的脚本如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Create board specific header file</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">if [ <span class="string">"$APPEND"</span> = <span class="string">"yes"</span> ]<span class="comment"># Append to existing config file</span></span><br><span class="line">then</span><br><span class="line">echo &gt;&gt; config.h</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&gt; config.h<span class="comment"># Create new config file</span></span><br><span class="line">fi</span><br><span class="line">echo <span class="string">"/* Automatically generated - do not edit */"</span> &gt;&gt;config.h</span><br><span class="line">echo <span class="string">"#include &lt;configs/$1.h&gt;"</span> &gt;&gt;config.h</span><br></pre></td></tr></table></figure><p><em>config.h</em>这个头文件中的内容如下，<em>configs/x210_sd.h</em>中包含的是与x210特性相关的用于适配的宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Automatically generated - do not edit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;configs/x210_sd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>通过搜索这个头文件，我们可以发现<strong>CONFIG_ENABLE_MMU</strong>被定义，所以会包含<em>asm/proc/domain.h</em>这个头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ cat include/configs/x210_sd.h | grep CONFIG_ENABLE_MMU</span><br><span class="line">#define CONFIG_ENABLE_MMU</span><br><span class="line">#ifdef CONFIG_ENABLE_MMU</span><br><span class="line">#ifdef CONFIG_ENABLE_MMU</span><br></pre></td></tr></table></figure><p>通过<em>ls -l</em>可以发现这个头文件是<strong>proc-armv</strong>文件夹的一个软连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-PC:.../qt_x210v3s_160307/uboot$ ls -il include/asm/ | grep proc</span><br><span class="line">6430221 lrwxrwxrwx 1 greedyhao greedyhao      9 3月  15 09:31 proc -&gt; proc-armv</span><br></pre></td></tr></table></figure><p>之所以使用<strong>proc</strong>而不是<strong>proc-armv</strong>，是为了可移植性。</p><p>试想一下，在移植时需要去把<strong>proc-xxx</strong>一个个修改是件多么痛苦的事，而且这种启动代码应该可重用的部分很多，使用软连接的方式可以减少很多不必要的工作</p><h1 id="启动文件的校验头">启动文件的校验头</h1><p>uboot 选择 SD/NAND 启动方式，需要启动文件提供一个16字节的校验头，<code>start.S</code> 就在开头填充了16字节的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#if defined(CONFIG_EVT1) &amp;&amp; !defined(CONFIG_FUSED)</span><br><span class="line">.word 0x2000</span><br><span class="line">.word 0x0</span><br><span class="line">.word 0x0</span><br><span class="line">.word 0x0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>在 uboot 编译完，得到可执行文件后，还需要补充这16字节的校验和，uboot才能启动</p><p>三星有提供程序用来计算这个校验和，下面简单看看</p><h2 id="计算校验和">计算校验和</h2><p>程序的用法如下</p><p><code>Usage: mkbl1 &lt;source file&gt; &lt;destination file&gt; &lt;size&gt;</code></p><p>在使用这个程序的时候，会向程序的 main 函数中传递一个参数数组 *argv[] ，而且 argv[0] = mkbl1，argv[1] = source file，argv[2] = destination file，argv[3] = size，这些都是基本常识，就不多说了</p><p>mkbl1 在得到文件的大小后，先会分配一个缓冲区，准备用来存放需要处理的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufLen = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">Buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(BufLen);</span><br><span class="line"><span class="built_in">memset</span>(Buf, <span class="number">0x00</span>, BufLen);</span><br></pre></td></tr></table></figure><p>准备好缓冲区后，就把需要处理的文件读入，使用 fseek 计算文件长度，再使用 fread 将文件读入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已删除错误处理</span></span><br><span class="line">fp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>);</span><br><span class="line"></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">fileLen = ftell(fp);</span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">nbytes = fread(Buf, <span class="number">1</span>, BufLen, fp);</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><p>计算校验和的时候需要跳过前16个字节，然后从第9个字节开始写入计算出来的校验和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = Buf + <span class="number">16</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, checksum = <span class="number">0</span>; i &lt; BufLen - <span class="number">16</span>; i++)</span><br><span class="line">checksum += (<span class="number">0x000000FF</span>) &amp; *a++;</span><br><span class="line"></span><br><span class="line">a = Buf + <span class="number">8</span>;</span><br><span class="line">*( (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)a ) = checksum;</span><br></pre></td></tr></table></figure><p>写入也和读取类似，先 fopen 再使用 fwrite 写入，最后释放掉缓存区的空间</p><h1 id="异常向量表">异常向量表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start: breset</span><br><span class="line">ldrpc, _undefined_instruction</span><br><span class="line">ldrpc, _software_interrupt</span><br><span class="line">ldrpc, _prefetch_abort</span><br><span class="line">...</span><br><span class="line">.global _end_vect</span><br><span class="line">_end_vect:</span><br><span class="line">.balignl 16,0xdeadbeef</span><br></pre></td></tr></table></figure><p>异常向量表是当程序发生异常时的处理方式，在向量表制作完后，使用 balignl 伪指令，让内存16字节对齐，加速硬件访问；至于 0xdeadbeef 代表用来补位垃圾数据</p><h1 id="复位向量设置">复位向量设置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_TEXT_BASE:</span><br><span class="line">.wordTEXT_BASE</span><br></pre></td></tr></table></figure><p>定义了一个 _TEXT_BASE 标签用来存放复位向量，主要是用在处理器初始化和 stack 的设置</p><p>至于 TEXT_BASE 之前介绍过，由 makefile 文件导入</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x210_sd_config :unconfig</span><br><span class="line">@<span class="variable">$(MKCONFIG)</span> $(@:_config=) arm s5pc11x x210 samsung s5pc110</span><br><span class="line">@echo <span class="string">"TEXT_BASE = 0xc3e00000"</span> &gt; <span class="variable">$(obj)</span>board/samsung/x210/config.mk</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从上一章的链接脚本分析中，我们知道了uboot的程序是从*ENTRY(_start)*开始的&lt;/p&gt;
&lt;p&gt;在整个uboot工程下搜索**_start&lt;strong&gt;，可以找到一个&lt;/strong&gt;start.S**文件包含了这个label，因此uboot启动的分析从这个文件开始&lt;/p&gt;
    
    </summary>
    
    
      <category term="uboot" scheme="http://greedyhao.cc/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>使用机智云平台远程控制esp8266</title>
    <link href="http://greedyhao.cc/2019/05/13/%E5%B7%A5%E4%BD%9C-mcu-esp8266-2019-05-13-%E4%BD%BF%E7%94%A8%E6%9C%BA%E6%99%BA%E4%BA%91%E5%B9%B3%E5%8F%B0%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6esp8266/"/>
    <id>http://greedyhao.cc/2019/05/13/工作-mcu-esp8266-2019-05-13-使用机智云平台远程控制esp8266/</id>
    <published>2019-05-13T12:41:41.000Z</published>
    <updated>2019-05-13T12:54:18.718Z</updated>
    
    <content type="html"><![CDATA[<p>机智云平台是一个物联网平台，使用机智云平台可以简化设备联网的步骤。</p><a id="more"></a><p>从零开始的基于机智云平台的Demo实现，估计也就2个多小时，下面开始</p><h1 id="机智云平台相关">机智云平台相关</h1><h2 id="注册开发者账号">注册开发者账号</h2><p>机智云开发者账号，用于产品接入、设备管理、OTA服务、MCU开发等的功能使用。 注册链接：http://dev.gizwits.com/zh-cn/developer/</p><h2 id="创建新设备">创建新设备</h2><p>如下图，点击右上角创建新产品</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图，选择Wi-Fi/移动网络方案</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="创建数据点">创建数据点</h2><p>如图，电机新建数据点</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>弹出窗口中输入标识名，可读写，数据类型按需要选择</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>相关参考:http://docs.gizwits.com/zh-cn/deviceDev/UseSOC.html#2-%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91</p></blockquote><h1 id="准备上云端了">准备上云端了</h1><h2 id="云端生成代码">云端生成代码</h2><p>如图，左边菜单栏选择MCU开发，需要填写的<strong>Product Secret</strong>看下面</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图，左边菜单栏选择基本信息，点击显示完整密钥就行了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图，最后下载代码</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="修改代码">修改代码</h2><p>如图，修改 app/Gizwits/gizwits_product.c 的 gizwitsEventProcess</p><p>在之前设置的数据点(EVENT_)对应的case下添加自己的代码</p><p>需要初始化的外设可以在 app/user/user_main.c 的 user_init 下初始化</p><h2 id="编译源码">编译源码</h2><p>编译源码需要搭建交叉编译环境</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这部分参考这个链接，我懒得写了：http://docs.gizwits.com/zh-cn/deviceDev/WiFiSOC/GoKit3S%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91.html#GoKit3-S-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91</p><h2 id="烧写固件">烧写固件</h2><p>下载烧写软件</p><p>https://www.espressif.com/sites/default/files/tools/flash_download_tools_v3.6.4.rar</p><p>第一次需要烧写的 bin 文件有四个</p><p>bin/blank.bin bin/boot_v1.6.bin bin/esp_init_data_default.bin bin/upgrade/user1.4096.new.6.bin</p><h3 id="开发板进入烧录方式">开发板进入烧录方式</h3><p>如图，开关拨到下载位置，开发板关闭</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>点击烧录软件的开始按钮后，给开发板上电</p><p>烧录完毕后记得将开关拨回运行</p><p>bin 文件的烧录地址看下面</p><h3 id="烧录地址">烧录地址</h3><p>esp_init_data_default.bin 0x3fc000 blank.bin 0x3fe000 boot_v1.6.bin 0x00000 user1.4096.new.6.bin 0x01000</p><p>选项：CrystalFreq=26M SPI_SPEED=40MHz SPI_MODE=QIO FLASH_SIZE=32Mbit-C1, 其他默认，串口115200 进入uart烧录模式后，点击start下载即可！</p><p>官方的图的配置有点问题，我直接在图上改了，懒得重新弄</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/10.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="设备开始连接云">设备开始连接云</h1><h2 id="下载配网app">下载配网APP</h2><p>到这个网址去下载app用来给esp8266配网，ios还是安卓看个人手机</p><p>https://download.gizwits.com/zh-cn/p/98/99</p><h2 id="登陆开发者账号">登陆开发者账号</h2><p>软件需要登陆的，就先前创建的账号</p><h2 id="设备配网">设备配网</h2><p>如下面几个图操作就好</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/11.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/12.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/13.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/14.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266/15.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如果前面没问题的话，这里应该设备就配网成功了，可以远程操作了</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/esp8266//img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机智云平台是一个物联网平台，使用机智云平台可以简化设备联网的步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="esp8266" scheme="http://greedyhao.cc/tags/esp8266/"/>
    
  </entry>
  
  <entry>
    <title>pid算法的基础应用</title>
    <link href="http://greedyhao.cc/2019/05/04/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-05-04-pid%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    <id>http://greedyhao.cc/2019/05/04/自动控制-PID-2019-05-04-pid算法的基础应用/</id>
    <published>2019-05-04T15:06:07.000Z</published>
    <updated>2019-05-04T15:53:39.299Z</updated>
    
    <content type="html"><![CDATA[<p>五一放假终于有空，先验证一下之前了解的pid算法。</p><p>本次实验是应用pid算法，保持舵机与平面的角度保持在一定的数值。</p><a id="more"></a><p>感觉表述有点不清楚，从视频中看看吧。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/servo_pid/servo_pid_test.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="说说我做了的尝试">说说我做了的尝试</h1><h2 id="系统辨识建立模型">系统辨识建立模型</h2><p>本来之前以为可以通过matlab工具箱的系统辨识建立模型，然后通过工具箱自动调参</p><p>但是！自动调参更新完pid参数后，阶跃响应为负值</p><p>没办法，只能放弃这个操作了</p><h2 id="瞎调参数">瞎调参数</h2><p>之后就随便乱调参数，发现要不抖的厉害，要不就迟滞时间太长</p><p>随便调了几下后就放弃这个方法了</p><h2 id="arduino中的自整定算法">Arduino中的自整定算法</h2><p>就是<a href="https://github.com/br3ttb/Arduino-PID-Library/blob/master/examples/PID_AdaptiveTunings/PID_AdaptiveTunings.ino" target="_blank" rel="noopener">Arduino-PID-Library</a>的自整定例子</p><p>在疯狂调节相关参数后，还是抖的厉害，没法用</p><h1 id="系统整体框架">系统整体框架</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/servo_pid/design_of_sys.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="模糊pid">模糊PID</h1><p>最后还是选择了模糊PID的方法</p><p>随便在网上找到了一个用于Arduino的开源算法，<a href="https://github.com/afakharany93/Fuzzy-like-PI-controller" target="_blank" rel="noopener">Fuzzy-like-PI-controller</a></p><p>整合了mpu6050和舵机的相关代码后，得到了这个项目</p><p>这是这个项目的简单流程描述</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/servo_pid/fussy_pid_design.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="存在问题">存在问题</h2><p>为了验证pid的算法，今天一整天就没得了，心态有点爆炸了，所以最后这代码写的很随意了</p><p>就存在了那么些问题，对代码有兴趣的可以自行去github下载，目录下的README有问题的描述</p><p>代码地址</p><p>https://github.com/greedyhao/servo_mpu6050_pid/tree/master/Arduino</p><h1 id="后记">后记</h1><p>总算又完成一个任务，舒服</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;五一放假终于有空，先验证一下之前了解的pid算法。&lt;/p&gt;
&lt;p&gt;本次实验是应用pid算法，保持舵机与平面的角度保持在一定的数值。&lt;/p&gt;
    
    </summary>
    
      <category term="自动控制" scheme="http://greedyhao.cc/categories/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="PID" scheme="http://greedyhao.cc/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>移植MotionDriver到RTT</title>
    <link href="http://greedyhao.cc/2019/05/03/%E5%B7%A5%E4%BD%9C-rt-thread-2019-05-03-%E7%A7%BB%E6%A4%8DMotionDriver%E5%88%B0RTT/"/>
    <id>http://greedyhao.cc/2019/05/03/工作-rt-thread-2019-05-03-移植MotionDriver到RTT/</id>
    <published>2019-05-03T09:50:07.000Z</published>
    <updated>2019-05-03T09:51:21.690Z</updated>
    
    <content type="html"><![CDATA[<p>这个移植花费了我好多时间...</p><a id="more"></a><p>本来是想使用<a href="http://packages.rt-thread.org/itemDetail.html?package=mpu6xxx" target="_blank" rel="noopener">mpu6xxx的软件包</a>的，但是得到的数据抖动太厉害了</p><p>在网上找到了两种得到稳定的数据的方法 + DMP + Kalman滤波</p><p>看到DMP的效果更好，就选择DMP的方案</p><p>了解到 InvenSense 公司提供的 MotionDriver 可以用DMP的方式读取mpu，就开始移植 MotionDriver 这个库</p><p>本项目的地址 https://github.com/greedyhao/MotionDriver2RTT</p><h1 id="移植步骤">移植步骤</h1><p>简单的说，就是把 core/driver/eMPL/inv_mpu.c 这个文件中需要使用到的函数实现就行了</p><p>这个文件中也有相关说明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The following functions must be defined for this platform:</span></span><br><span class="line"><span class="comment"> * i2c_write(unsigned char slave_addr, unsigned char reg_addr,</span></span><br><span class="line"><span class="comment"> *      unsigned char length, unsigned char const *data)</span></span><br><span class="line"><span class="comment"> * i2c_read(unsigned char slave_addr, unsigned char reg_addr,</span></span><br><span class="line"><span class="comment"> *      unsigned char length, unsigned char *data)</span></span><br><span class="line"><span class="comment"> * delay_ms(unsigned long num_ms)</span></span><br><span class="line"><span class="comment"> * get_ms(unsigned long *count)</span></span><br><span class="line"><span class="comment"> * reg_int_cb(void (*cb)(void), unsigned char port, unsigned char pin)</span></span><br><span class="line"><span class="comment"> * labs(long x)</span></span><br><span class="line"><span class="comment"> * fabsf(float x)</span></span><br><span class="line"><span class="comment"> * min(int a, int b)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>不过实际需要实现的只有 i2c_write i2c_read delay_ms get_ms，以及 core/driver/stm32L/log_stm32.c 下的 log_i 与 log_e 的底层函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> i2c_write   imu_i2c_write_regs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> i2c_read    imu_i2c_read_regs </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> delay_ms    thread_mdelay</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_ms      get_tick_count</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log_i       MPL_LOGI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log_e       MPL_LOGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b)    ((a&lt;b)?a:b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> labs(n)     (((n) &lt; 0) ? (-(n)) : (n))</span></span><br></pre></td></tr></table></figure><h2 id="i2c的实现">i2c的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mpu_device</span> *<span class="title">mpu_dev</span>;</span></span><br></pre></td></tr></table></figure><p>通过 mpu_dev 这个全局指针来保存mpu设备的相关信息</p><p>不过全局指针的方式进行i2c通信不知道会不会不太好，暂时没有其他方式实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> imu_i2c_write_regs(<span class="keyword">unsigned</span> <span class="keyword">char</span> slave_addr, <span class="keyword">unsigned</span> <span class="keyword">char</span> reg_addr, <span class="keyword">unsigned</span> <span class="keyword">short</span> length, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *data_ptr)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!rt_mpu_write_reg(mpu_dev, reg_addr, length, data_ptr))</span><br><span class="line">    &#123;</span><br><span class="line">        res = RT_EOK;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_err_t</span> imu_i2c_read_regs(<span class="keyword">unsigned</span> <span class="keyword">char</span> slave_addr, <span class="keyword">unsigned</span> <span class="keyword">char</span> reg_addr, <span class="keyword">unsigned</span> <span class="keyword">char</span> length, <span class="keyword">unsigned</span> <span class="keyword">char</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">if</span> (!rt_mpu_read_regs(mpu_dev, reg_addr, length, data))</span><br><span class="line">    &#123;</span><br><span class="line">        res = RT_EOK;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 rt-thread 的i2c接口和 MotionDriver 中需要的i2c接口不一致，就写了个中间层适配，从 MotionDriver 的i2c接口传入的 slave_addr 直接使用 mpu_dev 中的地址，这样就可以使用 rt-thread 的 i2c设备框架了</p><p>i2c驱动的实现很重要，不然这个库没办法用的，遇到问题先检查i2c驱动的实现</p><h2 id="其他函数">其他函数</h2><p>其他的函数都可以使用 rt-thread 系统中自带函数</p><h1 id="遇到问题">遇到问题</h1><h2 id="fifo-overflow">fifo overflow</h2><p>卡在这个问题好久，偶然间从网上了解到，DMP程序要考虑到DMP数据的输出速率</p><p>本项目中设置的是100Hz，读取的速度也要相对应，不然就会overflow</p><p>为了防止溢出，我直接加大了fifo的大小，并加快了读取速度</p><h1 id="效果图">效果图</h1><p>现在数据稳得一批</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/motion_driver_test.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个移植花费了我好多时间...&lt;/p&gt;
    
    </summary>
    
    
      <category term="MPU" scheme="http://greedyhao.cc/tags/MPU/"/>
    
  </entry>
  
  <entry>
    <title>pid调节的方法</title>
    <link href="http://greedyhao.cc/2019/04/12/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6-PID-2019-04-12-pid%E8%B0%83%E8%8A%82%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://greedyhao.cc/2019/04/12/自动控制-PID-2019-04-12-pid调节的方法/</id>
    <published>2019-04-12T15:09:05.000Z</published>
    <updated>2019-04-12T15:09:14.418Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了建立系统模型的三种方法，这一篇介绍如何调节pid，并用MATLAB仿真</p><a id="more"></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>调节pid的目标就是使得从模型中得到的增益能够使物理系统正常工作</p><h1 id="调节pid的理论分析">调节pid的理论分析</h1><p>pid的一般形式如下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>经过移动化简可以得到</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在我们的问题就简化成了在哪里放置这两个极点，和设置多大的增益？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在给微分器加上滤波器，相当于系统多了一个极点，滤波器的相关内容之后介绍</p><h2 id="matlab仿真">MATLAB仿真</h2><p>仿真使用的模型还是我们上一篇使用的电机模型</p><p>随便取一个之前的模型进行pid控制仿真</p><p>先初始化电机模型的变量，再加上pid的必要模型，开始仿真</p><p>随便调了几下pid参数，得到下图的效果</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="调节零点位置和增益的方法">调节零点位置和增益的方法</h1><h2 id="新名词介绍">新名词介绍</h2><p>根轨迹图(root locus)是控制理论及稳定性理论中，绘图分析的方式，可以看到在特定参数（一般会是反馈系统的环路增益）变化时，系统极点的变化。</p><p>说实话，这东西以前我听都没听过，在经过线上线下查找资料才算知道了这么个东西。</p><p>简单的说，这个图可以用来判断非时变系统系统的稳定性，以及计算系统增益并实现它的控制器</p><p>手画这个图是有许多规则的，不过我没有去了解，毕竟我时间也不多，只知道可以用MATLAB画</p><h2 id="进入主题">进入主题</h2><p>有两种方法用于调节：Pole placement 和 Loop shaping</p><p><strong>Pole placement</strong></p><p>一个简单的开环系统，他的根轨迹图是这样的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在加入PID后，会引入新的零点和极点，就会变成这样</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这种调节方法就是通过调节增益，从而得到希望的系统性能</p><p><strong>Loop shaping</strong></p><p>这个方法和上面的类似，换了种形式的图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_13_8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>据<a href="http://folk.ntnu.no/skoge/prost/proceedings/ecc03/pdfs/148.pdf" target="_blank" rel="noopener">论文</a>介绍，这两种方法的性能都是差不多的，loop-shaping多了两个优点，(i)不需要在FRF上拟合LTI模型来设计控制器，并且(ii)随着控制器系数的平滑变化，增益调度的实现更加缓慢。</p><p>对于我来说，暂时只管怎么用，好不好用，就没有深入学习了</p><h2 id="matlab仿真-1">MATLAB仿真</h2><p>下图是我用之前的模型随意调的pid的阶跃响应，可以看出是不符合我们的期望的，下面我们就使用MATLAB进行pid调节</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我们首先需要做的是打开<em>analysis-&gt;control design-&gt;control system designer</em>，然后按照下面三张图所示，添加需要调节的pid模块，添加需要的信号</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在control system designer的菜单栏中点击tuning methods，在下拉框中选择root locus editor，就可以得到下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在new plot下选择new step，在弹出窗口按下图配置</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>最终效果如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>手动pid调节</strong></p><p>手动调节说实话我是不太懂，我这里只是随便乱调一下表示可以手动修整而已</p><p>这里使用的是pole placement的方法，loop shaping也是类似的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_8.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>自整定pid</strong></p><p>这里主要还是介绍自整定pid，毕竟方便，不需要懂太多相关知识</p><p>在tuning methods下选择pid tuning</p><p>可以在弹出窗口中选择pid控制器的类型、性能等等，最后附上调节效果图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>最后弄完后要在菜单栏选择update blocks</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/auto_control/pid/pid_14_10.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="结尾">结尾</h1><p>调节好的模型已上传github的<a href="https://github.com/greedyhao/trembling-ball-pid/tree/master/software/matlab/motor_model_pid.slx" target="_blank" rel="noopener">项目库</a></p><h1 id="参考资料">参考资料</h1><ul><li><a href="https://ww2.mathworks.cn/help/slcontrol/ug/design-compensator-in-simulink-using-automated-pid-tuning.html" target="_blank" rel="noopener">Design Compensator Using Automated PID Tuning and Graphical Bode Design</a></li><li><a href="https://ww2.mathworks.cn/help/control/getstart/designing-pid-controllers-with-the-pid-tuner-gui.html" target="_blank" rel="noopener">Designing PID Controllers with PID Tuner</a></li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了建立系统模型的三种方法，这一篇介绍如何调节pid，并用MATLAB仿真&lt;/p&gt;
    
    </summary>
    
      <category term="自动控制" scheme="http://greedyhao.cc/categories/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="Matlab" scheme="http://greedyhao.cc/tags/Matlab/"/>
    
      <category term="PID" scheme="http://greedyhao.cc/tags/PID/"/>
    
  </entry>
  
</feed>
