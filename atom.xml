<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhuhao&#39;s Blog</title>
  
  <subtitle>I am the captain of my ship and the master of my fate.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://greedyhao.cc/"/>
  <updated>2019-03-08T06:22:28.598Z</updated>
  <id>http://greedyhao.cc/</id>
  
  <author>
    <name>Greedyhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>体验deepin系统</title>
    <link href="http://greedyhao.cc/2019/03/04/%E5%B7%A5%E4%BD%9C-Linux-2019-03-04-%E4%BD%93%E9%AA%8Cdeepin%E7%B3%BB%E7%BB%9F/"/>
    <id>http://greedyhao.cc/2019/03/04/工作-Linux-2019-03-04-体验deepin系统/</id>
    <published>2019-03-04T15:42:25.000Z</published>
    <updated>2019-03-08T06:22:28.598Z</updated>
    
    <content type="html"><![CDATA[<p>之前体验了<a href="http://mp.weixin.qq.com/s?__biz=MzU0OTAyODAzMg==&amp;mid=100000323&amp;idx=1&amp;sn=7d889a7a8488e70c2ba32a97c7054672&amp;chksm=7bb76bec4cc0e2faeead09d5423fa334110b882d54dd104e790d2691d2d95f5ed0e6cd714d22#rd" target="_blank" rel="noopener">Ubuntu18.04</a>，在使用了几个月后，还是放弃了</p><a id="more"></a><p>主要是Ubuntu18.04有一些很难接受的问题如下: + 双屏体验很差。每次重启后会将笔记本的屏幕设置为主屏幕；从双屏转为单屏时，被关闭屏幕的图标不会自动移动到另一个屏幕。 + 会出现莫名奇妙的BUG</p><p>偶然间了解到了deepin这个系统，看了看他的演示视频，觉得真心不错。很顺畅，界面也好看。</p><p>先上一张启动器的图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/deepin/launcher.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="前期工作">前期工作</h1><p>可以参考一下官方的文档中说的<a href="https://www.deepin.org/installation/" target="_blank" rel="noopener">如何安装</a></p><h2 id="备份">备份</h2><p>如果当前电脑硬盘是MBR格式的话，在安装系统的时候会提示说无法安装，因为需要GPT格式的硬盘才支持安装。</p><p>如果是参考之前的<a href="http://mp.weixin.qq.com/s?__biz=MzU0OTAyODAzMg==&amp;mid=100000323&amp;idx=1&amp;sn=7d889a7a8488e70c2ba32a97c7054672&amp;chksm=7bb76bec4cc0e2faeead09d5423fa334110b882d54dd104e790d2691d2d95f5ed0e6cd714d22#rd" target="_blank" rel="noopener">Ubuntu18.04+win10双系统</a>安装的系统，可能是需要备份一下再安装，安装时会自动帮你转换硬盘格式</p><h2 id="制作启动盘">制作启动盘</h2><p>制作启动盘的方法可以参考官方的文档<a href="https://wiki.deepin.org/wiki/%E5%8E%9F%E7%94%9F%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">原生安装</a></p><p>制作启动盘推荐使用官方制作工具<a href="https://www.deepin.org/original/deepin-boot-maker/" target="_blank" rel="noopener">深度启动盘制作工具</a>，我试过了软碟通制作的启动盘是无法使用的</p><h2 id="选择文件格式挂载点分配空间">选择文件格式、挂载点、分配空间</h2><p>以下配置推荐来自<a href="https://www.deepin.org/installation/" target="_blank" rel="noopener">官方推荐</a>，如果是安装双系统的话需要boot分区</p><table><thead><tr class="header"><th style="text-align: left;">挂载点</th><th style="text-align: left;">挂载点中文名</th><th style="text-align: left;">文件系统</th><th style="text-align: left;">大小</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">/</td><td style="text-align: left;">根分区（必选）</td><td style="text-align: left;">EXT4（推荐）</td><td style="text-align: left;">最少10G</td></tr><tr class="even"><td style="text-align: left;">/boot</td><td style="text-align: left;">引导盘（可选）</td><td style="text-align: left;">EXT4（推荐）</td><td style="text-align: left;">最少800M</td></tr><tr class="odd"><td style="text-align: left;">/home</td><td style="text-align: left;">家目录（推荐）</td><td style="text-align: left;">EXT4（推荐）</td><td style="text-align: left;">最少10G</td></tr><tr class="even"><td style="text-align: left;">swap</td><td style="text-align: left;">交换分区（可选）</td><td style="text-align: left;">不设置</td><td style="text-align: left;">4G内存以下分配2G，4G以上可不分配</td></tr></tbody></table><h1 id="后期工作">后期工作</h1><h2 id="切换显卡驱动">切换显卡驱动</h2><p>进入到启动器搜索gpu，找到打开<strong>显卡驱动管理</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/deepin/gpu_driver_m.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>需要使用双屏的需要选择<strong>NV-PRIME</strong>，单屏的话可以选择<strong>小黄蜂</strong></p><p>有时候切换驱动会失败，一般再试下就可以切换成功了</p><h2 id="系统更新">系统更新</h2><p>在使用前最好更新下系统，因为有些旧版软件有BUG</p><p>在命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade -y</span><br></pre></td></tr></table></figure><h2 id="添加桌面快捷方式">添加桌面快捷方式</h2><p>一些常用软件可以在桌面添加一个快捷方式，这样启动起来比在命令行中启动方便</p><p>可以参考<a href="https://wiki.deepin.org/wiki/Desktop_Entry_%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">Desktop Entry 文件</a>这个文档</p><p>这里简单的说说</p><p>一般个人软件就放在<em>~/.local/share/applications</em>下，Desktop Entry 文件格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry] #每个desktop文件都以这个标签开始，说明这是一个Desktop Entry文件</span><br><span class="line">Version = 1.0 #标明Desktop Entry的版本（可选）</span><br><span class="line">Name = Firefox #程序名称（必须），这里以创建一个Firefox的快捷方式为例</span><br><span class="line">GenericName = Web Browser #程序通用名称（可选）</span><br><span class="line">Comment = A Web Browser #程序描述（可选）</span><br><span class="line">Exec = firefox %u #程序的启动命令（必选），可以带参数运行,当下面的Type为Application，此项有效</span><br><span class="line">Icon = firefox #设置快捷方式的图标（可选）</span><br><span class="line">Terminal = false #是否在终端中运行（可选），当Type为Application，此项有效</span><br><span class="line">Type = Application #desktop的类型（必选），常见值有“Application”和“Link”</span><br><span class="line">Categories = GNOME;Application;Network; #注明在菜单栏中显示的类别（可选）</span><br></pre></td></tr></table></figure><p>以我个人的配置作为示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name = STM32CubeMX</span><br><span class="line">Version = 5.1.0</span><br><span class="line">GenericName = STM32CubeMX</span><br><span class="line">Exec = /usr/local/STM32CubeMX/STM32CubeMX</span><br><span class="line">Icon = /usr/local/STM32CubeMX/help/STM32CubeMX.ico</span><br><span class="line">Path = /usr/local/STM32CubeMX</span><br><span class="line">Terminal = false </span><br><span class="line">Type = Application </span><br><span class="line">Categories = Development</span><br></pre></td></tr></table></figure><p>创建完这个文件就可以在启动器中看见这个软件了，右键即可添加到桌面</p><h1 id="事后感言">事后感言</h1><p>deepin团队修改完善了内核的一些方面，也开发了一些优秀的软件包方便使用deepin，基本的软件如QQ 微信 chrome都已经预装，开箱即用很方便</p><p><strong>双屏体验</strong>在deepin上得到了优化，不仅仅只是可以设置外接显示屏为主显示器，而且可以将外接显示器与自带显示器位置互换，并在重启后自定义位置不会重置，还可以将这个设置保存为一个自定义选项，方便从双屏与单屏之间的切换。截屏的功能在双屏下可以正常使用，不过录屏的功能无法录制扩展屏，暂时还不清楚是什么原因</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/linux/deepin/launcher.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>deepin-wine</strong>无法安装LOL。<strong>steam</strong>下的porton效果也不是太好，目前发现无法运行PUBG，主要是无法启动battleye服务</p><p>安装应用不要使用root权限，可以通过修改文件夹所有用户组安装，具体步骤下次说</p><p>希望这个系统的新鲜感保质期能久一点</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前体验了&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0OTAyODAzMg==&amp;amp;mid=100000323&amp;amp;idx=1&amp;amp;sn=7d889a7a8488e70c2ba32a97c7054672&amp;amp;chksm=7bb76bec4cc0e2faeead09d5423fa334110b882d54dd104e790d2691d2d95f5ed0e6cd714d22#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu18.04&lt;/a&gt;，在使用了几个月后，还是放弃了&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://greedyhao.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何移植RT-Thread的BSP</title>
    <link href="http://greedyhao.cc/2018/12/12/%E5%B7%A5%E4%BD%9C-rt-thread-2018-12-12-%E5%A6%82%E4%BD%95%E7%A7%BB%E6%A4%8DRT-Thread%E7%9A%84BSP/"/>
    <id>http://greedyhao.cc/2018/12/12/工作-rt-thread-2018-12-12-如何移植RT-Thread的BSP/</id>
    <published>2018-12-12T09:00:02.000Z</published>
    <updated>2018-12-12T09:07:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近RT-Thread重构了stm32的BSP，看了一下，感觉很思路很清晰</p><a id="more"></a><table><thead><tr class="header"><th style="text-align: left;">目录</th><th style="text-align: left;">简介</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">bsp32</td><td style="text-align: left;">重构BSP的介绍文档</td></tr><tr class="even"><td style="text-align: left;">bsp32</td><td style="text-align: left;">各系列的stm32的HAL库</td></tr><tr class="odd"><td style="text-align: left;">bsp32_Drivers</td><td style="text-align: left;">基于HAL库的设备驱动</td></tr><tr class="even"><td style="text-align: left;">bsp32_Drivers</td><td style="text-align: left;">外设驱动的配置文件</td></tr><tr class="odd"><td style="text-align: left;">bsp32_Drivers_flash</td><td style="text-align: left;">flash的配置文件</td></tr><tr class="even"><td style="text-align: left;">bsp32</td><td style="text-align: left;">移植BSP的模板</td></tr><tr class="odd"><td style="text-align: left;">bsp3232fxxx-xxx-xxx</td><td style="text-align: left;">各开发板的适配工程</td></tr></tbody></table><p>我觉得这就是我想要的，于是就开始移植重构后的BSP</p><h1 id="移植流程">移植流程</h1><ul><li>复制一个与自己开发板系列相近的BSP</li><li>修改Scons脚本文件</li><li>修改驱动文件</li><li>规范BSP</li></ul><h1 id="复制一个与自己开发板系列相近的bsp">复制一个与自己开发板系列相近的BSP</h1><p>先找一个和自己开发板MCU类似的BSP，例如我的开发板的MCU是stm32f767，所以我复制了这个目录下的工程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger</span><br></pre></td></tr></table></figure><p>修改名字为你的开发板名字，例如我的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f767-fire-challenger</span><br></pre></td></tr></table></figure><p>然后，在libraries目录下加入你使用的MCU系列的HAL库文件，比如我的f7系列就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\STM32F7xx_HAL</span><br></pre></td></tr></table></figure><p>HAL库文件可以从<a href="https://www.st.com/zh/development-tools/stm32cubemx.html" target="_blank" rel="noopener">STM32CubeFx</a>中解压得到</p><p>然后参照着已经有的HAL库文件夹的情况，将一些使用不到的文件删除，特别是以下文件需要删除，否则会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\STM32F7xx_HAL\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_msp_template.c</span><br><span class="line">bsp\stm32\libraries\STM32F7xx_HAL\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_timebase_rtc_alarm_template.c</span><br><span class="line">bsp\stm32\libraries\STM32F7xx_HAL\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_timebase_rtc_wakeup_template.c</span><br><span class="line">bsp\stm32\libraries\STM32F7xx_HAL\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_timebase_tim_template.c</span><br></pre></td></tr></table></figure><p><strong>在移植完成后</strong>，将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f767-fire-challenger</span><br></pre></td></tr></table></figure><p>复制到下面这个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates</span><br></pre></td></tr></table></figure><p>将名字更改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f7xx</span><br></pre></td></tr></table></figure><h1 id="修改scons脚本文件">修改Scons脚本文件</h1><p>需要修改的脚本文件有点多，不过不急，慢慢来</p><p>可以从<a href="https://github.com/RT-Thread/rt-thread/pull/2058/files" target="_blank" rel="noopener">我提交的pr</a>中看到我修改过的脚本文件，我将他们全部列出来，免得有人遗漏了需要修改的地方</p><ul><li>bsp/stm32/libraries/HAL_Drivers/SConscript</li><li>bsp/stm32/libraries/HAL_Drivers/drv_config.h</li><li>bsp/stm32/libraries/Kconfig</li><li>bsp/stm32/libraries/STM32F7xx_HAL/SConscript</li><li>bsp/stm32/stm32f767-fire-challenger/Kconfig</li><li>bsp/stm32/stm32f767-fire-challenger/SConscript</li><li>bsp/stm32/stm32f767-fire-challenger/SConstruct</li><li>bsp/stm32/stm32f767-fire-challenger/applications/SConscript</li><li>bsp/stm32/stm32f767-fire-challenger/board/Kconfig</li><li>bsp/stm32/stm32f767-fire-challenger/board/SConscript</li><li>bsp/stm32/stm32f767-fire-challenger/rtconfig.py</li><li>bsp/stm32/libraries/templates/stm32f7xx/Kconfig</li><li>bsp/stm32/libraries/templates/stm32f7xx/SConscript</li><li>bsp/stm32/libraries/templates/stm32f7xx/SConstruct</li><li>bsp/stm32/libraries/templates/stm32f7xx/applications/SConscript</li><li>bsp/stm32/libraries/templates/stm32f7xx/board/Kconfig</li><li>bsp/stm32/libraries/templates/stm32f7xx/board/SConscript</li><li>bsp/stm32/libraries/templates/stm32f7xx/rtconfig.py</li></ul><p>看着脚本文件很多，其实也不是太麻烦，只要参考已有的模板，该起来很容易的，那么接下来一个个来讲解吧</p><h2 id="bspstm32librarieshal_driverssconscript">bsp/stm32/libraries/HAL_Drivers/SConscript</h2><p>需要在这个文件中加入你的soc系列，按顺序排好，如图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librarieshal_driversdrv_config.h">bsp/stm32/libraries/HAL_Drivers/drv_config.h</h2><p>同上，加入你的soc系列</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librarieskconfig">bsp/stm32/libraries/Kconfig</h2><p>同上，加入你的soc系列</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librariesstm32f7xx_halsconscript">bsp/stm32/libraries/STM32F7xx_HAL/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\STM32F4xx_HAL\SConscript</span><br></pre></td></tr></table></figure><p>然后修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32stm32f767-fire-challengerkconfig">bsp/stm32/stm32f767-fire-challenger/Kconfig</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\Kconfig</span><br></pre></td></tr></table></figure><h2 id="bspstm32stm32f767-fire-challengersconscript">bsp/stm32/stm32f767-fire-challenger/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\SConscript</span><br></pre></td></tr></table></figure><h2 id="bspstm32stm32f767-fire-challengersconstruct">bsp/stm32/stm32f767-fire-challenger/SConstruct</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\SConstruct</span><br></pre></td></tr></table></figure><h2 id="bspstm32stm32f767-fire-challengerapplicationssconscript">bsp/stm32/stm32f767-fire-challenger/applications/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\applications\SConscript</span><br></pre></td></tr></table></figure><h2 id="bspstm32stm32f767-fire-challengerboardkconfig">bsp/stm32/stm32f767-fire-challenger/board/Kconfig</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\board\Kconfig</span><br></pre></td></tr></table></figure><p>不过需要修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32stm32f767-fire-challengerboardsconscript">bsp/stm32/stm32f767-fire-challenger/board/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\stm32f429-fire-challenger\board\SConscript</span><br></pre></td></tr></table></figure><p>不过需要修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32stm32f767-fire-challengerrtconfig.py">bsp/stm32/stm32f767-fire-challenger/rtconfig.py</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32f7-disco\rtconfig.py</span><br></pre></td></tr></table></figure><p>我是从旧版BSP中找的，你也可以找找你对应型号的旧版BSP中的这个脚本</p><h2 id="之后这个templates中的脚本修改内容和前面基本一样的">之后这个<strong>templates</strong>中的脚本修改内容和前面基本一样的</h2><h2 id="bspstm32librariestemplatesstm32f7xxkconfig">bsp/stm32/libraries/templates/stm32f7xx/Kconfig</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\Kconfig</span><br></pre></td></tr></table></figure><h2 id="bspstm32librariestemplatesstm32f7xxsconscript">bsp/stm32/libraries/templates/stm32f7xx/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\SConscript</span><br></pre></td></tr></table></figure><h2 id="bspstm32librariestemplatesstm32f7xxsconstruct">bsp/stm32/libraries/templates/stm32f7xx/SConstruct</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\SConstruct</span><br></pre></td></tr></table></figure><h2 id="bspstm32librariestemplatesstm32f7xxapplicationssconscript">bsp/stm32/libraries/templates/stm32f7xx/applications/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\applications\SConscript</span><br></pre></td></tr></table></figure><h2 id="bspstm32librariestemplatesstm32f7xxboardkconfig">bsp/stm32/libraries/templates/stm32f7xx/board/Kconfig</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\board\Kconfig</span><br></pre></td></tr></table></figure><p>不过需要修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librariestemplatesstm32f7xxboardsconscript">bsp/stm32/libraries/templates/stm32f7xx/board/SConscript</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\templates\stm32f4xx\board\SConscript</span><br></pre></td></tr></table></figure><p>不过需要修改图中标记部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="bspstm32librariestemplatesstm32f7xxrtconfig.py">bsp/stm32/libraries/templates/stm32f7xx/rtconfig.py</h2><p>这个文件可以从下面这个地址复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32f7-disco\rtconfig.py</span><br></pre></td></tr></table></figure><h1 id="修改驱动文件">修改驱动文件</h1><p>驱动文件分为：<strong>实现</strong>和<strong>配置</strong></p><p>实现是下面这个目录下的.c文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\HAL_Drivers</span><br></pre></td></tr></table></figure><p>配置是以下目录下的.h和部分.c文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\HAL_Drivers\config\fx</span><br><span class="line">bsp\stm32\libraries\HAL_Drivers\drv_flash</span><br><span class="line">bsp\stm32\stm32f767-fire-challenger\board\ports</span><br></pre></td></tr></table></figure><p>我们需要做的事就是根据开发板实际情况进行修改</p><h2 id="下面以移植uart为例子">下面以移植uart为例子</h2><p>先确认config文件是否符合开发板实际情况，同一个系列的MCU的移植不需要修改config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\HAL_Drivers\config\f7\uart_config.h</span><br></pre></td></tr></table></figure><p>根据HAL库的情况修改以下文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsp\stm32\libraries\HAL_Drivers\drv_usart.c</span><br></pre></td></tr></table></figure></p><p>例如f7系列，参照stm32f7xx_hal_uart.h，看看什么drv_usart.c中使用到的API是stm32f7xx_hal_uart.h中没有的，改为stm32f7xx_hal_uart.h有的接口，可以参考下面的方式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>还要注意一些寄存器是某些系列的产品特有的，要用宏定义区分，例如</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/proting_for_f7_8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其他需要修改的地方都是差不多的，可以参考一下我的修改</p><p>在移植完驱动后，需要使用Cubemx启动外设，这部分请参考<a href="https://github.com/RT-Thread/rt-thread/blob/master/bsp/stm32/docs/BSP%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md#%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%89%87%E4%B8%8A%E8%B5%84%E6%BA%90%E9%80%89%E9%A1%B9" target="_blank" rel="noopener">如何添加更多的片上资源选项</a></p><p>不过串口1默认是开启的</p><h1 id="规范bsp">规范BSP</h1><p>这部分请参考<a href="https://github.com/RT-Thread/rt-thread/blob/master/bsp/stm32/docs/STM32%E7%B3%BB%E5%88%97BSP%E5%88%B6%E4%BD%9C%E8%A7%84%E8%8C%83.md" target="_blank" rel="noopener">STM32 系列 BSP 制作规范</a></p><p>移植到此结束，欢迎尝试</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近RT-Thread重构了stm32的BSP，看了一下，感觉很思路很清晰&lt;/p&gt;
    
    </summary>
    
    
      <category term="rt-thread" scheme="http://greedyhao.cc/tags/rt-thread/"/>
    
      <category term="stm32" scheme="http://greedyhao.cc/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>通信原理角度调制</title>
    <link href="http://greedyhao.cc/2018/12/08/%E5%B7%A5%E4%BD%9C-wireless-2018-12-08-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E8%A7%92%E5%BA%A6%E8%B0%83%E5%88%B6/"/>
    <id>http://greedyhao.cc/2018/12/08/工作-wireless-2018-12-08-通信原理角度调制/</id>
    <published>2018-12-08T15:32:39.000Z</published>
    <updated>2018-12-08T15:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="角度调制的两种方法">角度调制的两种方法</h1><a id="more"></a><p>一般表达式为</p><p><span class="math display">\[s(t)=A_c\cos[2\pi f_c t+\theta(t)]  \tag{1}\]</span></p><h2 id="fm与pm的表达式">FM与PM的表达式</h2><p>PM: 消息直接放在相位上</p><p><span class="math display">\[\begin{aligned}\theta(t) &amp;= K_p m(t) \\s_{PM}(t) &amp;= A_c\cos\left[2\pi f_c t + k_{PM} m(t)\right] \end{aligned} \tag{2}\]</span></p><p>FM: 消息直接放在角频率上</p><p><span class="math display">\[\begin{aligned}\frac{d\theta(t)}{dt} &amp;= K_f m(t)  \\\theta(t) &amp;= K_f\int m(t)dt  \\s_{FM}(t) &amp;= A_c\cos\left[2\pi f_c t + 2\pi k_{FM}\int m(t)dt\right]\end{aligned} \tag{3}\]</span></p><h2 id="fm与pm之间的联系">FM与PM之间的联系</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看出来，PM和FM是存在某种联系的，他们是相对的、关联的。</p><p>这是由于频率与相位之间存在微分与积分的关系，FM和PM之间是可以互相转换的。</p><ul><li>消息信号经过积分器再进入PM调制器可以得到FM信号</li><li>消息信号经过微分器再进入FM调制器可以得到PM信号</li></ul><h2 id="角度调制的优势">角度调制的优势</h2><p>他是恒幅波，不怕非线性失真，这解决了大功率放大器的非线性失真问题</p><h1 id="角度调制的基本参数">角度调制的基本参数</h1><h2 id="调制程度">调制程度</h2><p><strong>最大相偏</strong></p><p>联合(1)(2)(3)式，我们可以得到最大相偏<span class="math inline">\(\Delta \theta_{max}\)</span></p><p><span class="math display">\[\begin{aligned}&amp;PM:\ \ k_{PM}|m(t)|_{max} \\&amp;FM:\ \ 2\pi k_{FM}\left| \int m(t)dt\right|_{max}\end{aligned}\]</span></p><p><strong>最大频偏</strong></p><p>根据(3)式可以知道频率与相位之间存在微分积分的关系，因此我们可以得到角度调制的频率变化函数</p><p><span class="math display">\[PM:\ \ f_i (t) = f_c + \frac{1}{2\pi} \frac{d}{dt} \theta(t) \\FM:\ \ f_i (t) = f_c + k_{FM} m(t)\]</span></p><p>因此可以得到最大频偏<span class="math inline">\(\Delta f_{max}\)</span></p><p><span class="math display">\[\begin{aligned}&amp;PM:\ \ \frac{1}{2\pi} k_{PM}|m\prime (t)|_{max} \\&amp;FM:\ \ k_{FM}\left| m(t)dt\right|_{max}\end{aligned}\]</span></p><p>从上面的分析中，我们可以发现最大频偏/相偏正比于调制系数与消息信号的最大幅度</p><h2 id="正弦消息特例与调制指数">正弦消息特例与调制指数</h2><p>令消息信号m(t)如下</p><p><span class="math display">\[m(t) = a\cos(2\pi f_m t)\]</span></p><p>角度调制公式则如下</p><p><span class="math display">\[PM:\ \  s_{PM}(t) =  A_c\cos\left[2\pi f_c t +\beta \cos(2\pi f_m t) \right] \\\theta_{max} = k_{PM}a \\ \Delta f_{max} = f_m k_{PM}a  \\ \beta_{PM} = \Delta \theta_{max} \\FM:\ \  s_{FM}(t) = A_c\cos\left[2\pi f_c t + \beta \sin(2\pi f_m t) \right] \\\Delta f_{max} = k_{FM}a  \\ \beta_{FM} = \frac{\Delta f_{max}}{f_m} \\\]</span></p><p>调制指数是角度调制的基本参数之一，所以很重要，对于一般信号的定义如下</p><p><span class="math display">\[\beta = \frac{\Delta f_{max}}{B}\]</span></p><p>式中B为消息信号的带宽</p><h2 id="角度调制的信号带宽">角度调制的信号带宽</h2><h2 id="信号带宽">信号带宽</h2><p>角度调制信号的频谱无法用公式表示，不过他的带宽可以使用Carson公式计算得到，这个公式是通过对角度调制信号傅里叶系数分解得到的</p><p><span class="math display">\[B_T = 2\Delta f_{max} + 2B = 2(D+1)B\\D = \frac{\Delta f_{max}}{B}\]</span></p><p>式中的D为频偏比，也就是调制指数</p><h2 id="频谱特点">频谱特点</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从单音调频信号的频谱也再次验证了角度调制是非线性调制。而且也看得出FM调制会占用很宽的频带，但也正是因此，FM信号抗干扰、高质量。</p><p>实际生活中 + 宽带调频应用广泛 + 窄带调频应用较少</p><h1 id="角度调制的产生与接收">角度调制的产生与接收</h1><p>简单的说，角度调制就是将信号幅度上的变化转变为频率相位上的变化</p><h2 id="直接调频">直接调频</h2><p>直接调频是通过前文提到过的压控振荡器(VCO)实现的，VCO的振荡频率正比于输入控制电压</p><p><span class="math display">\[f_i (t) = f_c + k_{FM} m(t)\]</span></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>VCO可以通过LC振荡器实现，目前常用的电抗元件是变容二极管。但是这种直接调频的方法频率稳定性不好，不过可以通过使用PLL电路优化。因此，在早期的时候，直接调频的方法并不好用，主要使用的是间接调频的方法。</p><h2 id="间接调频">间接调频</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>间接调频使用的是阿姆斯特朗(Armstrong)法，它是先将消息信号积分，然后对载波调相，得到窄带调频(NBFM)信号，经过倍频得到宽带调频(WBFM)信号。上图就是他是系统框图</p><p>下面来解释他的原理</p><p>当<span class="math inline">\(\theta (t)\)</span>远小于1时，<span class="math inline">\(\cos\theta(t)\)</span>接近于1，<span class="math inline">\(\sin\theta(t)\)</span>接近于<span class="math inline">\(\theta(t)\)</span>；因为<span class="math inline">\(\theta(t)\)</span>很小，所以调制指数<span class="math inline">\(\beta=\Delta\theta_{max}\)</span>也就很小，因此这是一个<strong>窄带调频信号</strong>。</p><p>从系统框图我们可以看出，这个信号的产生是将消息信号m(t)通过积分器得到<span class="math inline">\(\theta(t)\)</span>，并将<span class="math inline">\(\theta(t)\)</span>控制得很小，再乘以cos信号反相得到的sin信号，最后再加上这个cos信号就得到了NBFM信号；由于这个NBFM信号不是理想的，所以还存在起伏，通过限幅器减小这种畸变；再经过倍频器和贷带通滤波器，得到WBFM。</p><h2 id="角度调制信号解调">角度调制信号解调</h2><p>解调是用和调制相反的方法，也就是将调制信号的疏密(频率相位)转换为幅度</p><p>先从数学上分析解调过程</p><p><span class="math display">\[s_{FM}(t) = A_c\cos\left[2\pi f_c t + K_f\int m(t)dt\right]\]</span></p><p>将其对t求微分</p><p><span class="math display">\[\frac{d s_{FM}(t)}{dt} = -A_c[2\pi f_c t + K_f m(t)]\sin\left[2\pi f_c t + K_f\int m(t)dt\right]\]</span></p><p>联系在AM中解调的方法，将包络提取出来，再去掉直流信号与高频载波信号，就得到m(t)信号了。</p><p>下面是解调的系统框图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在包络检波时，如果使用单调谐回路存在线性度差、线性范围较小的问题，而且还存在直流分量，虽然可以使用电容隔离直流，但是也有可能对低频信号产生损失；为了改进包络检波的电路，可以使用双调谐互补电路，在线性度好的同时，还没有直流成分的存在。</p><h2 id="篇外话">篇外话</h2><p>无论是发送还是接收，现代流行的技术方案都是采用基带处理与正交调制相结合的方案。</p><p>基带处理可以用DSP FPGA方便灵活实现各种调制方案</p><h1 id="噪声分析">噪声分析</h1><p>无论什么系统，在通过信道传输后总会被噪声干扰，只有了解噪声才能降低噪声的干扰，下面开始对噪声的分析</p><ul><li>如何分析</li><li>解调增益 系统增益</li><li>各种调制方法性能</li></ul><h2 id="噪声分析方法">噪声分析方法</h2><p><strong>基带传输中的噪声</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一般情况下，噪声都可以简化为高斯白噪声信号</p><p>去除噪声的方法就是使用一个和调制信号带宽相同的理想滤波器滤除噪声，不过调制信号带宽内的噪声无法去除</p><p>我们使用信噪比(SNR)来度量消息的质量</p><p>高斯白噪声是平坦的，通过低通滤波器后还是平坦的，因此噪声信号功率可以通过噪声信号的面积得到</p><p><span class="math display">\[SNR_o = \frac{P_m}{P_{n_o}} = \frac{\overline{m^2(t)}}{N_o B}\]</span></p><p><strong>频带传输中的噪声</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在频带分析中会涉及到调制解调，解调可能会使得消息信号发生变化，所以无法得知调制信号和残留噪声的具体值，因此SNR的分析就不是那么简单了，就需要更细致的分析</p><ul><li>针对具体解调方法分析</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>ENV指包络的意思</p><ul><li>将具体信号带入分析</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="解调增益和系统增益">解调增益和系统增益</h2><p><strong>解调增益</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个表中有列举几种调制的解调增益，输入SNR比较容易获得，我们可以通过解调增益和输入SNR求得输出SNR</p><p><strong>系统增益</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将基带传输信噪比与频带传输信噪比对比，得到系统增益，通过系统增益衡量频带传输系统的好坏</p><p>通过推导可以得到系统增益与解调增益之间的关系如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>下面这个表列举了几种调制的系统增益</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过系统增益可以直接比较不同系统的性能</p><h2 id="各种调制性能比较">各种调制性能比较</h2><p><strong>模拟调制性能指标</strong></p><ul><li>可靠性 输出信号的信噪比</li><li>有效性 占用的带宽</li></ul><p><strong>各种调制系统的性能比较</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>比较结论</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/PM_FM_15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="参考资料">参考资料：</h1><ul><li><a href="http://www.icourse163.org/learn/UESTC-238011?tid=1003260003#/learn/content" target="_blank" rel="noopener">通信原理 电子科技大学 中国大学MOOC</a></li><li><a href="http://wzzjzxx.com:8081/Media/2011/05/09/49b31ce5-8019-49cb-8a06-6a7a279f151b/65c0473b-61d1-4ccf-9c93-5bd89de4bb87.doc" target="_blank" rel="noopener">模拟调制系统</a></li><li><a href="http://101.96.10.63/www.eie.polyu.edu.hk/~em/cf03pdf/9%20FM2.pdf" target="_blank" rel="noopener">FM – Generation and Detection</a></li><li><a href="https://www.tutorialspoint.com/analog_communication/analog_communication_fm_modulators.htm" target="_blank" rel="noopener">Analog Communication FM Modulators - Tutorialspoint</a></li><li><a href="https://www.radio-electronics.com/info/rf-technology-design/fm-reception/fm-demodulation-detection-overview.php" target="_blank" rel="noopener">FM Demodulation / Detection Tutorial</a></li><li><a href="http://www.chinabaike.com/t/35816/2014/0623/2536846.html" target="_blank" rel="noopener">微分法鉴频器原理电路知识</a></li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;角度调制的两种方法&quot;&gt;角度调制的两种方法&lt;/h1&gt;
    
    </summary>
    
    
      <category term="wireless" scheme="http://greedyhao.cc/tags/wireless/"/>
    
  </entry>
  
  <entry>
    <title>通信原理线性调制</title>
    <link href="http://greedyhao.cc/2018/11/29/%E5%B7%A5%E4%BD%9C-wireless-2018-11-29-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%BA%BF%E6%80%A7%E8%B0%83%E5%88%B6/"/>
    <id>http://greedyhao.cc/2018/11/29/工作-wireless-2018-11-29-通信原理线性调制/</id>
    <published>2018-11-29T14:41:19.000Z</published>
    <updated>2018-12-08T15:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模拟线性调制">模拟线性调制</h1><a id="more"></a><h2 id="常规调幅-am">常规调幅 AM</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/am_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>AM 调制是一种线性调制，它的作用是将基带信号转变为调制信号。之所以调制的原因在上一篇文章说了，天线的长度要不短于信号的波长的1/10，这是为了阻抗匹配，具体原因在电磁波相关的书籍有介绍。</p><p>从图中不难看出，AM调制是一个很简单的调制方式，简单的只需要一个乘法器和一个加法器就可以完成。</p><p><strong>频谱特点</strong></p><ol type="1"><li>频带信号：位于载频fc，带宽BT = 2B</li><li>上下两个边带</li><li>+-fc处有两个冲激，有纯载波</li></ol><p><strong>波形特点</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/am_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>消息突显在载波包络上</p><p>通过调节消息信号的幅度，可以调节调幅指数，从而调节调制强度。调幅指数的定义如下</p><p><span class="math display">\[\begin {aligned}\beta_{AM} &amp;= \frac{max[s_{AM}(t)]-A_c}{A_c} \\&amp;= max|m(t)|\end {aligned}\]</span></p><p>不过调幅指数不能大于1，否则会发生上图中的过调制情况；过调制会导致承载消息的已调波变形，使得消息错误。</p><p><strong>发送与接收</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/am_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>发送使用的是一个乘法器与一个加法器的组合</p><p>接收端使用的是包络检波器，基本原理是：正弦波上升时，二极管正向导通给电容充电，正弦波下降时二极管截止，电容放电；通过电容的充放电就可以展示出消息信号的波形。</p><p>包络检波器的R C选值需要考虑输入信号的频率和载波的频率</p><p><strong>功率与效率</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/am_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>功率就是已调信号的平方的平均值</p><p>效率就是消息信号的功率比上总功率。使用正弦信号时，峰均功率比PARPm(t)最低，效率也只有33.3%，由此可以看出AM调制效率的低。</p><h2 id="抑制载波双边带调幅-dsb">抑制载波双边带调幅 DSB</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/dsb_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>DSB调制和AM调制信号很类似，频域上的特性基本相同，不过在fc处没有了冲激，而且DSB调制信号在时域上有一个反向点。</p><p>DSB调制效率为1</p><p><strong>接收方法</strong></p><p>包络没有直接直接呈现消息信号，所以无法使用包络检波器</p><p>可以通过乘以同频同相正弦函数调制回基频</p><p><span class="math display">\[\begin {aligned}&amp;S_{DSB} \times \cos 2\pi f_c t \\&amp;= A_c m(t) \cos^2 2\pi f_c t \\&amp;= A_c m(t) \frac{1+\cos 4\pi f_c t}{2}\end {aligned}\]</span></p><p>分析公式可以知道，乘以一个同频同相正弦信号的结果就是会产生基频信号和4倍基频信号，再同过一个低通滤波器就可以得到我们想要的原信号了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/dsb_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>乘法解调器的示意图如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/dsb_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>同步问题</strong></p><p>前面说了使用乘法解调器需要同频同相的正弦波，但是发射端和接收端一般都有一定的距离，很难保证频率相同。</p><p>为了保证接收端的本振和发射端的震荡频率相同，使用锁相环(PLL)做一个可控振荡器，通过比较接收到的DSB信号的频率来产生相同的频率</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/dsb_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="单边带调制-ssb">单边带调制 SSB</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>傅里叶变换的性质，信号的共轭等于原信号的频域信号的取反。而实信号的共轭等于它本身，因此可以推导出信号的频域共轭对称</p><p>因此可以去掉DSB调制的一半的带宽，但是自然界中只存在实信号，也就是说+-fc处都要有频带，因此只有两种单边带调制方式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>接收方法</strong></p><p>接收方法可以通过相干解调，解调过程图示如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>SSB调制信号的时域公式比较复杂，先搁置</p><p>SSB调制信号还可以通过增加载波分量的方法，可以实现包络检波</p><h2 id="残留边带调幅-vsb">残留边带调幅 VSB</h2><p>前面讲的SSB是理想情况下的，实现SSB需要非常陡峭的滤波器，这在显示中是不存在的；因此，为了能够实现这个滤波器，就加大了滤波器的过渡带，不过过渡带形状必须要对称互补</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/vsb_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="相移法生成单边带">相移法生成单边带</h2><p>前文讲的SSB VSB都是在频域进行滤波生成的单边带，接下来讲一个在现代使用的更多的相移法，尤其是在生成高频率的单边带时。</p><p>相移法是在时域处理的，所以需要在时域讨论SSB</p><p>目前我们知道的是，DSB的时域表达式</p><p>设调制信号为</p><p><span class="math display">\[m(t) = A_m\cos\omega_m t\]</span></p><p>载波为</p><p><span class="math display">\[c(t) = \cos\omega_c t\]</span></p><p>则DSB表达式为</p><p><span class="math display">\[\begin {aligned}s_{DSB}(t) &amp;= A_m \cos\omega_m t\cos\omega_c t \\&amp;= \frac{1}{2} A_m \cos (\omega_c+\omega_m)t + \frac{1}{2} A_m \cos (\omega_c-\omega_m)t\end {aligned}\]</span></p><p>保留上边带则有</p><p><span class="math display">\[\begin {aligned}s_{USB}(t) &amp;= \frac{1}{2} A_m \cos (\omega_c+\omega_m)t \\&amp;= \frac{1}{2}A_m \cos\omega_m t\cos\omega_c t-\frac{1}{2}A_m \sin\omega_m t\sin\omega_c t\end {aligned}\]</span></p><p>保留下边带则有</p><p><span class="math display">\[\begin {aligned}s_{LSB}(t) &amp;= \frac{1}{2} A_m \cos (\omega_c-\omega_m)t \\&amp;= \frac{1}{2}A_m \cos\omega_m t\cos\omega_c t+\frac{1}{2}A_m \sin\omega_m t\sin\omega_c t\end {aligned}\]</span></p><p>综合起来</p><p><span class="math display">\[\begin {aligned}s_{SSB}(t) &amp;= \frac{1}{2}m(t)\cos\omega_c t-\frac{1}{2}\hat{m}(t)\sin\omega_c t\end {aligned}\]</span></p><p>式中<span class="math inline">\(\hat{m}(t)\)</span>为希尔伯特变换，相当于正弦信号相移pi/2</p><p>为了验证SSB时域表达式的正确性，我们可以从频域进行分析</p><p><span class="math display">\[\begin {aligned}S_{SSB}(f) &amp;= \frac{M(f-f_c)+M(f+f_c)}{2} - \frac{-j\hat{M}(f-f_c)-j\hat{M}(f+f_c)}{2}\end {aligned}\]</span></p><p>希尔伯特变换的相关信息如下</p><p><span class="math display">\[\begin {aligned}&amp;\hat{m}(t) = m(t)*\frac{1}{\pi t} \\&amp;\hat{M}(f) = M(f)x[-j sgn(f)]\\&amp;j\hat{M}(f) = -j^2 M(f)sgn(f)\\\end {aligned}\]</span></p><p>在频域中，做希尔伯特变换相当于乘以了一个符号函数，SSB过程图示如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>接下来就是根据时域表达式实现相移法</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/ssb_5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模拟线性调制&quot;&gt;模拟线性调制&lt;/h1&gt;
    
    </summary>
    
    
      <category term="wireless" scheme="http://greedyhao.cc/tags/wireless/"/>
    
  </entry>
  
  <entry>
    <title>51总线方式获取adc0809数值</title>
    <link href="http://greedyhao.cc/2018/11/27/%E5%B7%A5%E4%BD%9C-mcu-51-2018-11-27-51%E6%80%BB%E7%BA%BF%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96adc0809%E6%95%B0%E5%80%BC/"/>
    <id>http://greedyhao.cc/2018/11/27/工作-mcu-51-2018-11-27-51总线方式获取adc0809数值/</id>
    <published>2018-11-27T13:32:55.000Z</published>
    <updated>2018-11-27T13:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近单片机有一个实验挺有意思的，使用51单片机以总线的方式读取adc0809的数据</p><p>先补充点关于单片机总线的预备知识，我一开始不了解总线的时候做这个实验也是很懵逼的。</p><h1 id="单片机的三总线结构">单片机的三总线结构</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/51/51bus_arch.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>51单片机有三条总线：数据总线、地址总线、控制总线</p><p>从图中可以看出，8位数据总线由P0组成，16位地址总线由P0和P2组成，控制总线由P3和相关引脚组成</p><p>采用总线的方式可以简化编程，节省I/O口，便于外设扩展</p><p>但是数据口和地址口在P0是怎么复用的呢，这就需要看到时序了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/51/51bus_seq.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看出，P0口是数据/地址分时复用的，这是P0口内部的复用结构完成的</p><h1 id="实操练习">实操练习</h1><p>51单片机与adc0809接线原理图如下 <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/51/51bus_sch.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="解释电路">解释电路</h2><p>P2.7口用作adc0809的选择线</p><p>P0.0~P0.2所接的A B C是adc0809的IN0通道选择线</p><p>接下来就是计算adc0809的地址了</p><p>P2 P0</p><p>0xxx xxxx xxxx x000</p><p>因此地址为0x7ff8</p><h2 id="遇到的问题">遇到的问题</h2><p>本来应该显示5v的位置只显示1.144v，而且在电阻增大的过程中，显示的值先减小后增大又减小，具体情况如图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/51/51bus_err_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/51/51bus_err_1.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>实在没有办法的情况下，借别的同学的代码来看，没发现自己的程序在时序、地址上的错误。</p><p>琢磨了单片机的数值变换的现象后，突然觉得是不是保存ad转换数值的变量溢出了，然后就发现我的变量类型是int，而别人的变量类型是long int</p><p>在将保存ad转换的变量类型修改过后，程序就运行正常了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mcu/51/51bus_err_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="程序代码">程序代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;absacc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> uint16;</span><br><span class="line"></span><br><span class="line">uchar led_mod[] = &#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="comment">//!&lt; 数码管编码</span></span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line"><span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AD_IN0 XBYTE [0x7ff8]</span></span><br><span class="line"></span><br><span class="line">sbit EOC = P3^<span class="number">5</span>;</span><br><span class="line">sbit CLK = P3^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">sbit seg1 = P2^<span class="number">0</span>;</span><br><span class="line">sbit seg2 = P2^<span class="number">1</span>;</span><br><span class="line">sbit seg3 = P2^<span class="number">2</span>;</span><br><span class="line">sbit seg4 = P2^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">uint16 adc_data = <span class="number">0</span>;    <span class="comment">//&gt; 保存ad转换结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 延迟函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_ms</span><span class="params">(uint8 time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint8 j;</span><br><span class="line">    <span class="keyword">for</span> (; time&gt;<span class="number">0</span>; time--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">114</span>; j&gt;<span class="number">0</span>; j--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器初始化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TMOD |= <span class="number">0x02</span>;</span><br><span class="line">TH0 = <span class="number">200</span>;<span class="comment">//&gt; 产生方波周期2us</span></span><br><span class="line">TL0 = <span class="number">200</span>;</span><br><span class="line">                                       </span><br><span class="line">ET0 = <span class="number">1</span>;                                      </span><br><span class="line">TR0 = <span class="number">1</span>;                                      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 数码管动态显示函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">adc_data = adc_data*<span class="number">1000</span>/<span class="number">51</span>;<span class="comment">//&gt; 分辨率为5/256约为1/51</span></span><br><span class="line">P1 = <span class="number">0x00</span>;</span><br><span class="line">P1 = led_mod[adc_data/<span class="number">1000</span>]|<span class="number">0x80</span>;</span><br><span class="line">seg1 = <span class="number">0</span>;</span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line">seg1 = <span class="number">1</span>;</span><br><span class="line">P1 = <span class="number">0x00</span>;</span><br><span class="line">P1 = led_mod[(adc_data%<span class="number">1000</span>)/<span class="number">100</span>];</span><br><span class="line">seg2 = <span class="number">0</span>;</span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line">seg2 = <span class="number">1</span>;</span><br><span class="line">P1 = <span class="number">0x00</span>;</span><br><span class="line">P1 = led_mod[(adc_data%<span class="number">100</span>)/<span class="number">10</span>];</span><br><span class="line">seg3 = <span class="number">0</span>;</span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line">seg3 = <span class="number">1</span>;</span><br><span class="line">P1 = <span class="number">0x00</span>;</span><br><span class="line">P1 = led_mod[adc_data%<span class="number">10</span>];</span><br><span class="line">seg4 = <span class="number">0</span>;</span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line">seg4 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">timer_init();</span><br><span class="line">EA = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">AD_IN0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(EOC == <span class="number">0</span>);</span><br><span class="line">adc_data = AD_IN0;</span><br><span class="line">display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 产生时钟周期</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0</span><span class="params">()</span> interrupt 1                   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CLK = ~CLK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近单片机有一个实验挺有意思的，使用51单片机以总线的方式读取adc0809的数据&lt;/p&gt;
&lt;p&gt;先补充点关于单片机总线的预备知识，我一开始不了解总线的时候做这个实验也是很懵逼的。&lt;/p&gt;
&lt;h1 id=&quot;单片机的三总线结构&quot;&gt;单片机的三总线结构&lt;/h1&gt;
&lt;figure 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rt-thread内核移植</title>
    <link href="http://greedyhao.cc/2018/11/25/%E5%B7%A5%E4%BD%9C-rt-thread-2018-11-25-rt-thread%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D/"/>
    <id>http://greedyhao.cc/2018/11/25/工作-rt-thread-2018-11-25-rt-thread内核移植/</id>
    <published>2018-11-25T12:07:37.000Z</published>
    <updated>2018-11-25T12:19:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享一下我参加rtt培训的内容吧</p><a id="more"></a><h1 id="rt-thread-nano版移植">rt-thread nano版移植</h1><h2 id="让内核运转起来">让内核运转起来</h2><p>移植选用的是rt-thread nano版，这次的移植的乞丐版，rt-thread的组件都没有移植，只有最基本的内核。</p><p>为了简单，参考了rtt提供的模板移植。我这块板是stm32f767的，和提供的模板使用的m4不一样，所以要做一些修改。</p><p>首先是创建工程，按照模板添加工程文件，配置好魔法棒中的c/c++参数，之后就开始移植了。</p><ol type="1"><li>将下载好的rt-thread nano版的src添加到工程中，由于这里不使用rtt的组件，所以rt-thread</li><li>修改时钟，找到SystemClock_Config的实现，按照自己板子的实际情况对时钟进行修改，这里的需要用到uasrt1，所以我就在这里初始化了uasrt1的时钟。</li><li>按照板子的实际情况，在board.c中实现led、uart的bsp</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/porting_rtt_1_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/porting_rtt_1_2.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="实现os-tick">实现OS Tick</h2><p>此时main中使用的delay还是通过空循环实现的，为了使用内核的rt_thread_delay，还需要实现OS Tick来给RTOS提供时间节拍，ARM Cortex-M提供了一个定时器Systick，这个定时器的时钟来源于系统时钟，会周期性的溢出，一般RTOS都是使用Systick来提供OS Tick</p><ol type="1"><li>实现SysTick_Handler，让mcu在Systick定时器溢出时给os tick的值加1，在加os tick时需要关闭中断</li><li>rt_hw_board_init中给Systick初始化</li><li>更换main.c中的_delay为rt_thread_delay</li></ol><p>效果和前面相同</p><h2 id="实现控制台打印">实现控制台打印</h2><p>调试设备少不了串口打印设备信息，rt-thread中提供了rt_kprintf来打印设备信息。进入到rt_kprintf的实现中看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_kprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_DEVICE</span></span><br><span class="line">    …</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    rt_hw_console_output(rt_log_buf);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出rt_kprintf的实现有分情况的，如果有显示设备就在显示设备上输出，没有就通过rt_hw_console_output在控制台输出</p><p>rt_thread的rt_hw_console_output是弱定义，所以需要用户自己实现</p><p>前面实现了串口输出，因此可以直接使用bsp_uart_send作为控制台输出</p><p>此时效果如下: <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/porting_rtt_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="实现动态内存">实现动态内存</h2><p>线程的创建是需要动态内存的，rt-thread使用rtconfig.h来控制RTOS的各个功能的开关；要想使用动态内存首先需要在rtconfig.h中打开动态内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_USING_HEAP </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_USING_SMALL_MEM</span></span><br></pre></td></tr></table></figure><p>然后需要在rt_hw_board_init中使用rt_system_heap_init对动态内存堆初始化</p><p>在main.c中创建一个线程测试rt_kprintf</p><p>效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/porting_rtt_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><a href="https://github.com/greedyhao/rt-thread/tree/master/stm32f767-rt-thread-nano" target="_blank" rel="noopener">此工程的代码地址</a></p><h1 id="使用env">使用env</h1><p>我的板子是stm32f767，在bsp中找到了一个stm32f7-disco的移植，就拿来用了。修改了一下工程配置，发现串口管脚都相同，就关掉sdram直接用了</p><p>效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RTOS/rt-thread/porting_rtt_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><a href="https://github.com/greedyhao/rt-thread/tree/master/stm32f767-fire" target="_blank" rel="noopener">此工程的代码地址</a></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享一下我参加rtt培训的内容吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="rt-thread" scheme="http://greedyhao.cc/tags/rt-thread/"/>
    
      <category term="stm32" scheme="http://greedyhao.cc/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>通信原理导学</title>
    <link href="http://greedyhao.cc/2018/11/25/%E5%B7%A5%E4%BD%9C-wireless-2018-11-25-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AF%BC%E5%AD%A6/"/>
    <id>http://greedyhao.cc/2018/11/25/工作-wireless-2018-11-25-通信原理导学/</id>
    <published>2018-11-25T11:02:18.000Z</published>
    <updated>2018-11-25T12:15:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下是我在中国大学mooc学习通信原理所做笔记</p><a id="more"></a><h1 id="通信系统主要指标">通信系统主要指标</h1><table><tbody><tr class="odd"><td>信息</td><td>内涵</td></tr><tr class="even"><td>消息</td><td>信息的载体</td></tr><tr class="odd"><td>信号</td><td>消息的载体</td></tr></tbody></table><p>消息分为数字消息、模拟消息</p><p>数字消息的基本指标： + N元 + RB码元传输速率 Rb信息传输速率</p><p>细节描述： + 符号集 + 概率</p><p>数字通信系统的基本指标 + 传输效率 Rb + 传输质量 误码率Pe 误信率Pb</p><p>模拟消息的基本指标 + 频谱带宽</p><h1 id="信道">信道</h1><h2 id="基本问题">基本问题</h2><ul><li>信号衰减 导线电阻</li><li>加性噪声 热噪声</li></ul><h2 id="其他问题">其他问题</h2><ul><li>外来干扰</li><li>信号畸变 信道特性不理想导致信号通过后变形</li></ul><p>信号畸变的例子：电话线过长，寄生电容变大，高频信号衰减，影响语音信号</p><h1 id="信道问题">信道问题</h1><p>加性噪声主要是热噪声，热噪声主要是高斯白噪声 + 时域上 随机性服从高斯分布 + 频域上 噪声均匀分布在所有频率上</p><p>AWGN信道模型——加性高斯白噪声信道模型</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="AWGN.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="电磁波">电磁波</h1><p>天线不短于电磁波波长的1/10</p><p>波长——电波在一次震荡里行进的距离</p><p>波长=光速/频率</p><h1 id="电磁波传输途径">电磁波传输途径</h1><ul><li>地波 1-2MHz 传输几十公里 主要用于AM、海事广播</li><li>天波 3-30MHz 长距离传输 被电离层反射 短波信道是时变的</li><li>视距 高于30MHz 穿透电离层 需要中继</li></ul><h1 id="电磁波管理">电磁波管理</h1><p>频分复用/频分多址(FDN/FDMA) + 频分复用 有线通信中多个话音&quot;错开频率&quot;共用一条电线传输 + 频分多址 多个无线用户&quot;使用各自频率&quot;同时接入通信系统 + 频分双工 每个用户&quot;采用不同频率&quot;接收与发送，两个方向同时传输</p><h1 id="基带与频带传输">基带与频带传输</h1><ul><li>基带信号 零频率附近</li><li>频带信号 某高频附近</li></ul><h2 id="模拟通信系统">模拟通信系统</h2><p>主要使用频带传输</p><p>核心为 + 调制 + 解调</p><p>调制</p><p>用正弦波(载波)携带消息 + 幅度调制 + 角度调制</p><h2 id="数字通信系统">数字通信系统</h2><p>基本功能 + 格式化 规范化的数字符号序列 + 基带调制 新成合适的电信号，基带信号通常是用脉冲生成 + 频带调制 转换为频带信号 + 同步</p><p>高级功能 + 信源编码 压缩编码 + 加密 + 信道编码 加入特殊数据位(奇偶校验位)，以便接收端发现与纠错 + 复用 + 多址接入 + 频谱扩展</p><h1 id="数字相对于模拟通信系统的优势">数字相对于模拟通信系统的优势</h1><ul><li>抗噪性 数字信号不容易被噪声干扰，长距离传输可以通过中继的方式避免噪声干扰</li><li>标准性<ul><li>各种消息可以混杂 复用、多媒体</li><li>消息汇集与中转 多址接入、路由与交换、互联网</li><li>消息与通信系统分离</li></ul></li><li>实现性</li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是我在中国大学mooc学习通信原理所做笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="wireless" scheme="http://greedyhao.cc/tags/wireless/"/>
    
  </entry>
  
  <entry>
    <title>另一种模拟傅里叶变换的方式</title>
    <link href="http://greedyhao.cc/2018/11/24/%E5%B7%A5%E4%BD%9C-dsp-2018-11-24-%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://greedyhao.cc/2018/11/24/工作-dsp-2018-11-24-另一种模拟傅里叶变换的方式/</id>
    <published>2018-11-24T14:02:50.000Z</published>
    <updated>2018-11-24T14:08:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是好久之前写的，忘记发了，另一种模拟傅里叶变换的方式。相关阅读：<a href="http://greedyhao.cc/2018/10/21/%E5%B7%A5%E4%BD%9C-dsp-2018-10-21-Matlab%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/">Matlab模拟傅里叶变换</a></p><a id="more"></a><h1 id="前言">前言</h1><p><a href="http://greedyhao.cc/2018/10/21/%E5%B7%A5%E4%BD%9C-dsp-2018-10-21-Matlab%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/">前文</a>进行了傅里叶变换的分析，以及在Matlab上模拟傅里叶变换，但是使用的是矩阵向乘法，这里提供另外一种模拟的方法。</p><h1 id="解决方法">解决方法</h1><p>我就是在<a href="https://www.csun.edu/~skatz/ece460/matlab_tut_two.pdf" target="_blank" rel="noopener">Evaluating Fourier Transforms with MATLAB</a>这篇文章中找到答案的。</p><p>我发现在这篇文章中，使用了一个Matlab built-in function---trapz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">help</span> trapz</span><br><span class="line"> trapz  Trapezoidal numerical integration.</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>简单来说，这个函数的作用是做积分，之前没有使用这个函数的时候，使用的就是求和的方法，也不知道之前的方法对复指数信号不适合的原因是不是求和导致了信息丢失。</p><p>下面进入主题</p><h1 id="分析与实现">分析与实现</h1><p>首先还是看到傅里叶变换上来</p><p><span class="math display">\[X_a(j\Omega)=\int x_a(t)e^{-j\Omega t}dt\]</span></p><p>思路很清晰，就是对<span class="math inline">\(x_a(t)e^{-j2\pi ft}\)</span>积分而已</p><p>我们需要使用到的trapz的更详细的描述如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q = trapz(X,Y) 根据 X 指定的坐标或标量间距对 Y 进行积分。</span><br><span class="line">如果 X 是坐标向量，则 length(X) 必须等于 Y 的大小不等于 1 的第一个维度的大小。</span><br><span class="line">如果 X 是标量间距，则 trapz(X,Y) 等于 X*trapz(Y)。</span><br></pre></td></tr></table></figure><p>根据文档，使用trapz(X,Y)时，让X为t，Y为积分部分就行</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trapz(t,x.*<span class="built_in">exp</span>(-<span class="built_in">j</span>*<span class="number">2</span>*<span class="built_in">pi</span>*f*t))</span><br></pre></td></tr></table></figure><h2 id="一个简单的trapz例子">一个简单的trapz例子</h2><p>接下来就使用trapz来做一个简单的函数的变换</p><p><span class="math display">\[X(jf)=\int^2_2 1e^{-j2\pi f} dt\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">t=<span class="number">-2</span>:<span class="number">.01</span>:<span class="number">2</span>;</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> f=<span class="number">-5</span>:<span class="number">.01</span>:<span class="number">5</span></span><br><span class="line">    k=k+<span class="number">1</span>;</span><br><span class="line">    X(k)=trapz(t,<span class="built_in">exp</span>(-<span class="built_in">j</span>*<span class="number">2</span>*<span class="built_in">pi</span>*f*t));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f=<span class="number">-5</span>:<span class="number">.01</span>:<span class="number">5</span>;</span><br><span class="line"><span class="built_in">plot</span>(f,X)</span><br></pre></td></tr></table></figure><p>效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/ctft_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这是对一个非周期脉宽信号的变换，得到的结果是我们很熟悉的sinc信号，而且结果是符合理论的。</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是好久之前写的，忘记发了，另一种模拟傅里叶变换的方式。相关阅读：&lt;a href=&quot;http://greedyhao.cc/2018/10/21/%E5%B7%A5%E4%BD%9C-dsp-2018-10-21-Matlab%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/&quot;&gt;Matlab模拟傅里叶变换&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="DSP" scheme="http://greedyhao.cc/tags/DSP/"/>
    
      <category term="Matlab" scheme="http://greedyhao.cc/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>18年11月总结</title>
    <link href="http://greedyhao.cc/2018/11/24/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2018-11-24-18%E5%B9%B411%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>http://greedyhao.cc/2018/11/24/学习总结-2018-11-24-18年11月总结/</id>
    <published>2018-11-24T14:02:13.000Z</published>
    <updated>2018-11-24T14:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有点飘，尝试了一下小说，没想到会难以自拔，准备重新改变看小说这个习惯中。</p><p>表面上小说好像带来了一些冷门的知识，但事实上浪费的时间比想象中的多，搞到我连博客都不想写了，所以还是得改。</p><p>下面进入主题，介绍一下最近接触的东西。</p><h1 id="rt-thread">RT-Thread</h1><p>之前报名参加了rtt的大学生培训活动，目前已经进行到了内核移植阶段。</p><p>培训内容是从熟悉内核开始的，先后学习了线程的创建启动、各种线程间通信同步的方式。我看了看野火的rtt的书，从目录来看，两者的教程很相似，由于对两者的接触很浅，所以具体的异同还要细看后才好说。</p><p>就我目前见识到的，各种操作系统的基本功能都差不多，都有对线程的操作、线程间通信、内存管理等功能，不过具体实现各有特点。</p><h1 id="dsp">DSP</h1><p>幅值、相位、实部、虚部是不一样的，可惜我学了很久直到不就前才注意到，之前在画频谱时，只知道要用abs取绝对值，但不知道为什么；不过后来慢慢知道频域中一般研究的是幅值和相位，实部和虚部的研究在时域中出现的比较多。</p><h1 id="通信原理">通信原理</h1><p>通信原理是我目前最头疼的一门学科了，这个月感觉根本没有学到什么...不过这也主要和我这个月态度太差了有关，既然之前没有学好，只能现在开始补了</p><h1 id="对下个月的打算">对下个月的打算</h1><p>首先是会尽快将这周的rtt培训任务完成，任务需要将rtt内核移植到自己的开发板上，我准备先使用rtt nano版的移植，再做env的移植。目前还没有对rtt在linux上的编译链接了解太多，准备到时候使用Truestudio开发吧。</p><p>然后自然就是学习数字信号处理和通信原理了，毕竟专业学科不能落下，这两门学科学起来还是不容易。</p><p>接下来我会改变目前的状态，只要有点所得就写下发出来，就当是给自己动力把。</p><h1 id="专业词汇">专业词汇</h1><ul><li>Finite-duration impulse response (FIR)</li><li>Infinite-duration impulse response (FIR)</li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有点飘，尝试了一下小说，没想到会难以自拔，准备重新改变看小说这个习惯中。&lt;/p&gt;
&lt;p&gt;表面上小说好像带来了一些冷门的知识，但事实上浪费的时间比想象中的多，搞到我连博客都不想写了，所以还是得改。&lt;/p&gt;
&lt;p&gt;下面进入主题，介绍一下最近接触的东西。&lt;/p&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="总结" scheme="http://greedyhao.cc/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Matlab模拟傅里叶变换</title>
    <link href="http://greedyhao.cc/2018/10/21/%E5%B7%A5%E4%BD%9C-dsp-2018-10-21-Matlab%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <id>http://greedyhao.cc/2018/10/21/工作-dsp-2018-10-21-Matlab模拟傅里叶变换/</id>
    <published>2018-10-21T07:45:09.000Z</published>
    <updated>2018-11-22T07:55:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>傅里叶变换是我们最早开始接触的时频域变换方法，虽然经常使用，知道怎么用纸笔计算，但是还从来没有在电脑中模拟过，正好现在开始学习数字信号处理，借着这个机会再学习如何在电脑上模拟傅里叶变换。</p><a id="more"></a><blockquote><p>以下大部分内容来自<em>Digital Signal Processing Using Matlab</em>和<em>数字信号处理教程 程佩青</em></p></blockquote><p>此次选择的软件平台为Matlab。</p><p>由于Matlab无法处理无限长序列，所以需要处理的信号必须是有限长的。</p><h1 id="连续时间傅里叶变换">连续时间傅里叶变换</h1><p>傅里叶变换的公式为：</p><p><span class="math display">\[X_a(j\Omega)=\int x_a(t)e^{-j\Omega t}dt\]</span></p><p>为了在计算机中模拟傅里叶变换，我们将积分变为求和的方式，上下限也从正无穷到负无穷变为一段长度M，dt需要尽可能小</p><p><span class="math display">\[X_a(j\Omega) = \sum_m x_a(m\Delta t)e^{-j\Omega m\Delta t}\Delta t\]</span></p><p>在Matlab中，函数的自变量因变量的集合都是使用矩阵来存储的，从矩阵的角度来看傅里叶变换的公式如下：</p><p><span class="math display">\[[X_a(0)\ X_a(1)\ X_a(2)\ ..] = [x_a(0)\ x_a(1)\ x_a(2)\ ..]\left[\begin{matrix} e^{-j\omega_0 t_0} &amp; e^{-j\omega_1 t_0} &amp; \cdots &amp; e^{-j\omega_K t_0}      \\ e^{-j\omega_0 t_1} &amp; e^{-j\omega_1 t_1} &amp; \cdots &amp; e^{-j\omega_K t_1}      \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ e^{-j\omega_0 t_N} &amp; e^{-j\omega_1 t_N} &amp; \cdots &amp; e^{-j\omega_K t_N}      \\\end{matrix}\right]\]</span></p><p>角频率向量定义为<span class="math inline">\(\omega=[\omega_0\ \omega_1\ ...\ \omega_K]\)</span></p><p>时间向量定义为<span class="math inline">\(t=[t_0 :\Delta t: t_N]\)</span></p><p>因此矩阵指数可写为<span class="math inline">\(-j*t&#39;*\omega\)</span></p><p>整个傅里叶变换可写为 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xa = xa * <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">j</span>*t'*W) * Dt;</span><br></pre></td></tr></table></figure></p><h2 id="具体实现">具体实现</h2><p>其实下面这个例子是<em>Digital Signal Processing Using Matlab</em>中的，来自P64页，不过想到都看到这里了还要读者翻书不太好，就一起放上来了。</p><p>定义<span class="math inline">\(x_a(t) = e^{-1000|t|}\)</span></p><p>先进行数学上的分析，</p><p><span class="math display">\[\begin {aligned}X_a(j \Omega) &amp;= \int^\infty_{-\infty}x_a(t)e^{-j\Omega t}dt \\&amp;= \int^0_{-\infty}e^{1000t}e^{-j\Omega t}dt + \int^\infty_0 e^{-1000t}e^{-j\Omega t}dt \\&amp;= \frac{0.002}{1+(\frac{\Omega}{1000})^2}\end {aligned}\]</span></p><p>MATLAB实现如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Analog Signal</span></span><br><span class="line">Dt = <span class="number">0.00005</span>;</span><br><span class="line">t = <span class="number">-0.005</span>:Dt:<span class="number">0.005</span>;</span><br><span class="line">xa = <span class="built_in">exp</span>(<span class="number">-1000</span>*<span class="built_in">abs</span>(t));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Continuous-time Fourier Transform</span></span><br><span class="line">Wmax = <span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">2000</span>;</span><br><span class="line">K = <span class="number">500</span>;</span><br><span class="line">k = <span class="number">0</span>:<span class="number">1</span>:K;</span><br><span class="line">W = k*Wmax/K;</span><br><span class="line"></span><br><span class="line">Xa = xa * <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">j</span>*t'*W) * Dt;</span><br><span class="line">Xa = <span class="built_in">abs</span>(Xa);</span><br><span class="line"></span><br><span class="line">W = [-<span class="built_in">fliplr</span>(W), W(<span class="number">2</span>:<span class="number">501</span>)];</span><br><span class="line">Xa = [<span class="built_in">fliplr</span>(Xa), Xa(<span class="number">2</span>:<span class="number">501</span>)];</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>); </span><br><span class="line"><span class="built_in">plot</span>(t*<span class="number">1000</span>,xa);</span><br><span class="line">xlabel(<span class="string">'t in msec.'</span>); </span><br><span class="line">ylabel(<span class="string">'xa(t)'</span>);</span><br><span class="line">title(<span class="string">'Analog Signal'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>); </span><br><span class="line"><span class="built_in">plot</span>(W/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">1000</span>),Xa*<span class="number">1000</span>);</span><br><span class="line">xlabel(<span class="string">'Frequency in KHz'</span>); ylabel(<span class="string">'Xa(jW)*1000'</span>);</span><br><span class="line">title(<span class="string">'Continuous-time Fourier Transform'</span>);</span><br></pre></td></tr></table></figure><p>运行效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/ctft_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果想确认变换的正确性，可以在运行完上面这个脚本后，在命令行输入</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(W/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">1000</span>),(<span class="number">0.002</span>./(<span class="number">1</span>+(W./<span class="number">1000</span>).^<span class="number">2</span>))*<span class="number">1000</span>);</span><br><span class="line">xlabel(<span class="string">'Frequency in KHz'</span>); ylabel(<span class="string">'Xa(jW)*1000'</span>);</span><br></pre></td></tr></table></figure><p>运行效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/source/dsp/ctft_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这时会发现，根据上面推导的变换公式直接plot出的图形和变换后得到的图形是一样的，这样可以确定变换的正确性。</p><h2 id="存在问题">存在问题</h2><p>目前存在的问题是，对于复函数的变换结果不正确。我想了很多天都找不出问题所在，只能暂时放弃，等以后有机会再研究。</p><h1 id="离散时间傅里叶变换">离散时间傅里叶变换</h1><p>下面是对上一个例子中的模拟输入信号做离散化，然后再进行离散傅里叶变换。</p><p>为了体现Nyquist定理，将使用两种不同的采样频率 1. 使用Fs=5000sam/sec采样来获得x1(n) 2. 使用Fs=1000sam/sec采样来获得x2(n)</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Analog Signal</span></span><br><span class="line">Dt = <span class="number">0.00005</span>;</span><br><span class="line">t = <span class="number">-0.005</span>:Dt:<span class="number">0.005</span>;</span><br><span class="line">xa = <span class="built_in">exp</span>(<span class="number">-1000</span>*<span class="built_in">abs</span>(t));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Discrete-time Signal </span></span><br><span class="line">Ts = <span class="number">0.0002</span>;</span><br><span class="line">n = <span class="number">-25</span>:<span class="number">1</span>:<span class="number">25</span>;</span><br><span class="line">x = <span class="built_in">exp</span>(<span class="number">-1000</span>*<span class="built_in">abs</span>(n*Ts));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Discrete-time Fourier transform</span></span><br><span class="line">K = <span class="number">500</span>;</span><br><span class="line">k = <span class="number">0</span>:<span class="number">1</span>:K;</span><br><span class="line">w = <span class="built_in">pi</span>*k/K;</span><br><span class="line"></span><br><span class="line">X = x*<span class="built_in">exp</span>(-<span class="built_in">j</span>*n'*w); X = <span class="built_in">real</span>(X);</span><br><span class="line"></span><br><span class="line">w = [-<span class="built_in">fliplr</span>(w), w(<span class="number">2</span>:K+<span class="number">1</span>)];</span><br><span class="line">X = [<span class="built_in">fliplr</span>(X), X(<span class="number">2</span>:K+<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="built_in">plot</span>(t*<span class="number">1000</span>,xa);</span><br><span class="line">xlabel(<span class="string">'t in msec.'</span>); </span><br><span class="line">ylabel(<span class="string">'x1(n)'</span>);</span><br><span class="line">title(<span class="string">'Discrete Signal'</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">stem(n*Ts*<span class="number">1000</span>,<span class="built_in">real</span>(x));gtext(<span class="string">'Ts=0.2 msec'</span>);<span class="built_in">hold</span> off;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);<span class="built_in">plot</span>(w/<span class="built_in">pi</span>,X);</span><br><span class="line">xlabel(<span class="string">'Frequency in pi units'</span>);ylabel(<span class="string">'X1(w)'</span>);</span><br><span class="line">title(<span class="string">'Discrete-time Fourier Transform'</span>);</span><br></pre></td></tr></table></figure><h2 id="fs5000samsec">Fs=5000sam/sec</h2><p>xa(t)的频率为2KHz，因此它的Nyquist频率为4KHz，而它的采样频率为5KHz，所以是满足Nyquist采样定律的，此时不会发生混叠。</p><p>运行效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/dtft_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="fs1000samsec">Fs=1000sam/sec</h2><p>这里使用的采样频率为1KHz，不满足Nyquist条件，因此会发生混叠。观察一下就会发生，1KHz采样得到的序列的频域波形和前面的频域波形不同，这就是混叠导致的，而且过低的采样率采集的信号的变换的不可逆的。</p><p>运行效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/dtft_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;傅里叶变换是我们最早开始接触的时频域变换方法，虽然经常使用，知道怎么用纸笔计算，但是还从来没有在电脑中模拟过，正好现在开始学习数字信号处理，借着这个机会再学习如何在电脑上模拟傅里叶变换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DSP" scheme="http://greedyhao.cc/tags/DSP/"/>
    
      <category term="Matlab" scheme="http://greedyhao.cc/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>c语言scanf输入问题</title>
    <link href="http://greedyhao.cc/2018/10/17/%E5%B7%A5%E4%BD%9C-c-language-2018-10-17-c%E8%AF%AD%E8%A8%80scanf%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://greedyhao.cc/2018/10/17/工作-c-language-2018-10-17-c语言scanf输入问题/</id>
    <published>2018-10-17T10:28:22.000Z</published>
    <updated>2018-10-17T10:28:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>经常有学弟学妹问到一个max函数(从两个数中找出最大的数)的问题，现在统一作答。</p><a id="more"></a><p>我将他们的代码放出来 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d,%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    c = max(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max=%d\n"</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) z = x;</span><br><span class="line">    <span class="keyword">else</span> z = y;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后输出结果 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ gcc error.c </span><br><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ ./a.out </span><br><span class="line">1，8</span><br><span class="line">max=1</span><br></pre></td></tr></table></figure></p><p>这里输出结果视编译器不同而不同。</p><p>之所以出现这样的问题，是因为输入数据的时候，格式化使用的逗号是中文导致的问题，重新使用英文逗号尝试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ ./a.out </span><br><span class="line">1,8</span><br><span class="line">max=8</span><br></pre></td></tr></table></figure><p>会发现程序运行正常了</p><p>在这里建议各位，在scanf格式化的时候，别使用逗号做分隔符，使用空格就可以避免类似的问题了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scanf("%d,%d",&amp;a,&amp;b);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br></pre></td></tr></table></figure><p>修改后的程序使用示例 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ gcc error.c </span><br><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ ./a.out </span><br><span class="line">1 8</span><br><span class="line">max=8</span><br></pre></td></tr></table></figure></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常有学弟学妹问到一个max函数(从两个数中找出最大的数)的问题，现在统一作答。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c语言" scheme="http://greedyhao.cc/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Sysgen-license-checkout-failed</title>
    <link href="http://greedyhao.cc/2018/10/11/%E5%B7%A5%E4%BD%9C-fpga-2018-10-11-Sysgen-license-checkout-failed/"/>
    <id>http://greedyhao.cc/2018/10/11/工作-fpga-2018-10-11-Sysgen-license-checkout-failed/</id>
    <published>2018-10-11T09:00:45.000Z</published>
    <updated>2018-10-11T09:00:48.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reported by:</span><br><span class="line">Unspecified</span><br><span class="line"></span><br><span class="line">Details:</span><br><span class="line">Sysgen license checkout failed.</span><br><span class="line">XILINXD_LICENSE_FILE = C:/Xilinx/Vivado/2016.1/data/sysgen/hwcosim_compiler/pp_ethernet</span><br><span class="line">Environment variable LM_LICENSE_FILE is not set.</span><br><span class="line">License search path: C:\.Xilinx;C:\Xilinx\Vivado\2016.1\data\sysgen\hwcosim_compiler\pp_ethernet;C:\Xilinx\Vivado\2016.1\data\ipcore_licenses</span><br></pre></td></tr></table></figure><p>这个错误是由于找不到license导致的</p><p>由于我无法复原错误了，所以就去网上找了一个差不多的出错信息</p><p>这个错误信息是windows下的，我的系统是ubuntu18.04，不过操作过程是差不多的</p><p>在错误信息中，可以看见<strong>XILINXD_LICENSE_FILE</strong>的位置，cd到这个位置，把自己的license复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x *.lic</span><br></pre></td></tr></table></figure><p>再次运行Sysgen会发现，没有再报错了</p><h1 id="windows下操作">windows下操作</h1><p>找到你的<strong>XILINXD_LICENSE_FILE</strong>位置，然后找到你的vivado的license位置，把这个license复制到<strong>XILINXD_LICENSE_FILE</strong>位置</p><h1 id="license下载">license下载</h1><p>虽然说是支持正版，不过这种软件一般的个人还是负担不起的，主要还是靠公司买单。</p><p>没钱的穷孩子可以下载<a href="https://github.com/greedyhao/some_useful_files/tree/master/vivado-license" target="_blank" rel="noopener">vivado-license全部功能破解</a></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
  </entry>
  
  <entry>
    <title>对Xil_Out32未定义的引用</title>
    <link href="http://greedyhao.cc/2018/09/29/%E5%B7%A5%E4%BD%9C-fpga-2018-09-29-%E5%AF%B9Xil-Out32%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <id>http://greedyhao.cc/2018/09/29/工作-fpga-2018-09-29-对Xil-Out32未定义的引用/</id>
    <published>2018-09-29T12:48:10.000Z</published>
    <updated>2018-09-29T12:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一次在HLS中遇见一个官方的函数未定义问题，这就把解决方法记录下来。</p><a id="more"></a><p>在创建好工程，写完工程代码后，发现报错如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./src/led_controller_test_tut_4A.o：在函数‘main’中：</span><br><span class="line">/home/greedyhao/Projects/LearningAndWorking/led_controller/led_controller.sdk/LED_Controller_test/Debug/../src/led_controller_test_tut_4A.c:44：对‘Xil_Out32’未定义的引用</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">makefile:39: recipe for target &apos;LED_Controller_test.elf&apos; failed</span><br><span class="line">make: *** [LED_Controller_test.elf] Error 1</span><br></pre></td></tr></table></figure><p>一眼就知道<strong>Xil_Out32</strong>这个函数，绝对是官方定义的啊。</p><p>找到它的定义在<em>xil_io.h</em>这个文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> INLINE <span class="keyword">void</span> <span class="title">Xil_Out32</span><span class="params">(UINTPTR Addr, u32 Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在网上查到有人说，因为这个函数是static的，所以将这个头文件include到主函数的文件就可以了</p><p>于是在主函数文件添加<strong>#include &quot;xil_io.h&quot;</strong>并保存好，工程正常</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次在HLS中遇见一个官方的函数未定义问题，这就把解决方法记录下来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
  </entry>
  
  <entry>
    <title>Vivado生成Bitstream失败的解决方法</title>
    <link href="http://greedyhao.cc/2018/09/29/%E5%B7%A5%E4%BD%9C-fpga-2018-09-29-Vivado%E7%94%9F%E6%88%90Bitstream%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://greedyhao.cc/2018/09/29/工作-fpga-2018-09-29-Vivado生成Bitstream失败的解决方法/</id>
    <published>2018-09-29T09:18:12.000Z</published>
    <updated>2018-09-29T09:18:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>跟着实验指导书，难得的又遇到问题了，在最后生成Bitstream的时候出错了，无法生成Bitstream。</p><a id="more"></a><p>报错信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[DRC NSTD-1] Unspecified I/O Standard: 4 out of 134 logical ports use I/O standard (IOSTANDARD) value &apos;DEFAULT&apos;, instead of a user assigned specific value. This may cause I/O contention or incompatibility with the board power or connectivity affecting performance, signal integrity or in extreme cases cause damage to the device or the components to which it is connected. To correct this violation, specify all I/O standards. This design will fail to generate a bitstream unless all logical ports have a user specified I/O standard value defined. To allow bitstream creation with unspecified I/O standard values (not recommended), use this command: set_property SEVERITY &#123;Warning&#125; [get_drc_checks NSTD-1].  NOTE: When using the Vivado Runs infrastructure (e.g. launch_runs Tcl command), add this command to a .tcl file and add that file as a pre-hook for write_bitstream step for the implementation run. Problem ports: LEDs_out_0[3:0].</span><br><span class="line"></span><br><span class="line">[DRC UCIO-1] Unconstrained Logical Port: 4 out of 134 logical ports have no user assigned specific location constraint (LOC). ... Problem ports: LEDs_out_0[3:0].</span><br></pre></td></tr></table></figure><p>在我绝望的时候在网上搜到了解决方法，问题还是出在了XDC文件上</p><p>我是直接复制的实验指导书中的XDC文件中的内容，但是在生成ked_controller这个ip核的port的时候，生成的port的名字和实验中的并不一样。</p><p>xdc文件内容如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set_property PACKAGE_PIN M14            [get_ports &#123;LEDs_out[0]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;LEDs_out[0]&#125;]</span><br><span class="line">set_property PACKAGE_PIN M15 [get_ports &#123;LEDs_out[1]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;LEDs_out[1]&#125;]</span><br><span class="line">set_property PACKAGE_PIN G14     [get_ports &#123;LEDs_out[2]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;LEDs_out[2]&#125;]</span><br><span class="line">set_property PACKAGE_PIN D18 [get_ports &#123;LEDs_out[3]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;LEDs_out[3]&#125;]</span><br></pre></td></tr></table></figure></p><p>注意下我的DRC报错信息就会发现一个重要的信息 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Problem ports: LEDs_out_0[3:0].</span><br></pre></td></tr></table></figure></p><p>这报错的port似乎有点不对劲，和约束文件中声明的port不一样，这也是为什么报错说LEDs_out_0这个port unspecified的原因，因为你XDC中声明的是LEDs_out啊。</p><p>解决方法很简单，把这个port的名字改了就好，更改方法如图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_E4a_BitERR.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟着实验指导书，难得的又遇到问题了，在最后生成Bitstream的时候出错了，无法生成Bitstream。&lt;/p&gt;
    
    </summary>
    
      <category term="入门学习" scheme="http://greedyhao.cc/categories/%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
      <category term="Zybo" scheme="http://greedyhao.cc/tags/Zybo/"/>
    
  </entry>
  
  <entry>
    <title>ZynqBook实验二的实践</title>
    <link href="http://greedyhao.cc/2018/09/21/%E5%B7%A5%E4%BD%9C-fpga-2018-09-21-ZynqBook%E5%AE%9E%E9%AA%8C%E4%BA%8C%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>http://greedyhao.cc/2018/09/21/工作-fpga-2018-09-21-ZynqBook实验二的实践/</id>
    <published>2018-09-21T15:50:54.000Z</published>
    <updated>2018-09-22T05:18:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先自然是跟着实验指导书做实验了</p><a id="more"></a><h1 id="实验2b">实验2B</h1><p>然后发现别人添加另外一个gpio的方法是需要重新添加一个gpio的ip核的，而不是直接用同一个ip核的另外一个gpio口</p><p><sub>而且感觉在SDK上编程的体验还是不太佳，没有代码自动补全能力</sub>~ ，网上搜索了一下，发现代码补全的能力是有的，快捷键<strong>alt+/</strong></p><p>这个实验的目标是使用中断检测按键输入，然后控制led灯的变换，按键(btns)按下时，对应leds的那一位加1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InterruptSystemSetup</span><span class="params">(XScuGic *XScuGicInstancePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Enable interrupt</span></span><br><span class="line">XGpio_InterruptEnable(&amp;BTNInst, BTN_INT);</span><br><span class="line">XGpio_InterruptGlobalEnable(&amp;BTNInst);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IntcInitFunction</span><span class="params">(u16 DeviceId, XGpio *GpioInstancePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    status = XScuGic_Connect(&amp;INTCInst,</span><br><span class="line">                            INTC_GPIO_INTERRUPT_ID,</span><br><span class="line">                            (Xil_ExceptionHandler)BTN_Intr_Handler,</span><br><span class="line">                            (<span class="keyword">void</span> *)GpioInstancePtr);</span><br><span class="line"><span class="keyword">if</span>(status != XST_SUCCESS) <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable GPIO interrupts interrupt</span></span><br><span class="line">XGpio_InterruptEnable(GpioInstancePtr, <span class="number">1</span>);</span><br><span class="line">XGpio_InterruptGlobalEnable(GpioInstancePtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable GPIO and timer interrupts in the controller</span></span><br><span class="line">XScuGic_Enable(&amp;INTCInst, INTC_GPIO_INTERRUPT_ID);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zynq的ps这边使用中断和以前mcu开发时很像，也都是需要先对中断注册，然后开中断，最后才能使用。</p><p>中断能用了，还要声明一个处理中断的函数，这个例程中的<em>BTN_Intr_Handler</em>就是一个处理中断的函数，在初始化中断的时候就注册好了。</p><p>效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_E2b.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="实验2b总结">实验2B总结</h2><p>通过这个部分的实验，学会了如何在Vivado中，开启一个ip的中断，又是怎么与zynq的ps核连接。</p><p>还学习到，要想在ps中使用这个中断，需要注册初始化这个中断和声明一个处理中断的函数。</p><h1 id="实验2d">实验2D</h1><p>这个实验是教我们添加更多的中断源，很现实的一个例子。</p><p>目前来看，ps添加多个中断源，需要增加一个mask，通过判定加了mask后的中断号，来判定是哪一个外设产生的中断。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_E2b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个实验添加了一个定时器中断源，在上一个实验的基础上使用了定时器中断，每三次定时器中断会让leds的值加1，控制定时器中断时间的，是<em>TMRInst</em>这个变量，每达到设置的0xF8000000这个值，触发一次中断</p><p>效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_E2d.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="实验2d总结">实验2D总结</h2><p>学习了怎么添加多个中断源</p><p>学习了xilinx中的定时器的使用</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先自然是跟着实验指导书做实验了&lt;/p&gt;
    
    </summary>
    
      <category term="入门学习" scheme="http://greedyhao.cc/categories/%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
      <category term="Zybo" scheme="http://greedyhao.cc/tags/Zybo/"/>
    
  </entry>
  
  <entry>
    <title>ZynqBook实验一延伸部分</title>
    <link href="http://greedyhao.cc/2018/09/21/%E5%B7%A5%E4%BD%9C-fpga-2018-09-21-ZynqBook%E5%AE%9E%E9%AA%8C%E4%B8%80%E5%BB%B6%E4%BC%B8%E9%83%A8%E5%88%86/"/>
    <id>http://greedyhao.cc/2018/09/21/工作-fpga-2018-09-21-ZynqBook实验一延伸部分/</id>
    <published>2018-09-21T14:46:44.000Z</published>
    <updated>2018-09-22T06:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>实验一的内容主要就是如何为zybo创建工程，然后如何烧写这第一个程序。尽管只是一个简单的LED闪烁的程序，但是对学习开发zybo的帮助还是很大的。</p><a id="more"></a><p>上次的实验，是直接使用zynqbook提供的代码，是让led 0 3位和1 2位的交替闪烁</p><p>根据实验指导书建议的，自己修改led的闪烁方式</p><p>我将它的闪烁方式改成了类似流水灯的闪烁方式、</p><p>原理就是和一个移动的位异或，然后循环左移这个位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Definitions */</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED 0x0<span class="comment">/* Initial LED value - X00X */</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LEDOutputExample</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Loop forever blinking the LED. */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Flip LEDs. */</span></span><br><span class="line"><span class="comment">//led = ~led;</span></span><br><span class="line">led = led ^ (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">4</span>) i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait a small amount of time so that the LED blinking is visible. */</span></span><br><span class="line"><span class="keyword">for</span> (Delay = <span class="number">0</span>; Delay &lt; LED_DELAY; Delay++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> XST_SUCCESS; <span class="comment">/* Should be unreachable */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_E1x.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>至于第三个建议扩展一个io的部分，我没有实现</p><p>因为我在block design中添加gpio2后，在sdk中没有生成gpio2的定义</p><p>于是我决定在第二个实验中寻找答案</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实验一的内容主要就是如何为zybo创建工程，然后如何烧写这第一个程序。尽管只是一个简单的LED闪烁的程序，但是对学习开发zybo的帮助还是很大的。&lt;/p&gt;
    
    </summary>
    
      <category term="入门学习" scheme="http://greedyhao.cc/categories/%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
      <category term="Zybo" scheme="http://greedyhao.cc/tags/Zybo/"/>
    
  </entry>
  
  <entry>
    <title>linux命令行运行第三方软件</title>
    <link href="http://greedyhao.cc/2018/09/18/%E5%B7%A5%E4%BD%9C-Linux-2018-09-18-linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6/"/>
    <id>http://greedyhao.cc/2018/09/18/工作-Linux-2018-09-18-linux命令行运行第三方软件/</id>
    <published>2018-09-18T07:41:50.000Z</published>
    <updated>2018-09-18T08:30:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>linux的宗旨是万物皆文件，所以很多不在源中的程序就是解包即用，但这样使用起来有些不方便，需要cd到可执行文件目录，然后再运行，显得有些麻烦。</p><a id="more"></a><p>就以最近下载的一个软件为例</p><p>它的执行命令为 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar proxyee-down-main.jar</span><br></pre></td></tr></table></figure></p><p>保存到proxyee-down后，发现无法运行，就给权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x proxyee-down</span><br></pre></td></tr></table></figure><p>但是发现这样的话，还是只能在这个jar包的位置才能正常执行这个文件</p><p>想到shell下可以使用pwd查看当前目录</p><p>于是首先先加上标记，告诉系统使用bash <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">java -jar $(<span class="built_in">pwd</span>)/proxyee-down-main.jar</span><br></pre></td></tr></table></figure></p><p>但是发现pwd给的是当前目录，而不是脚本的目录，于是改用dirname</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">work_path=$(dirname $(readlink -f <span class="variable">$0</span>))</span><br><span class="line">java -jar <span class="variable">$&#123;work_path&#125;</span>/proxyee-down-main.jar</span><br></pre></td></tr></table></figure><p>在命令行测试成功</p><hr><p><strong>参考资料</strong></p><ul><li><a href="http://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">Shell 教程</a></li><li><a href="https://blog.csdn.net/qq_18150497/article/details/76600828" target="_blank" rel="noopener">shell 当前工作目录的绝对路径</a></li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux的宗旨是万物皆文件，所以很多不在源中的程序就是解包即用，但这样使用起来有些不方便，需要cd到可执行文件目录，然后再运行，显得有些麻烦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://greedyhao.cc/tags/Linux/"/>
    
      <category term="Shell" scheme="http://greedyhao.cc/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>zybo初体验</title>
    <link href="http://greedyhao.cc/2018/09/17/%E5%B7%A5%E4%BD%9C-fpga-2018-09-17-zybo%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://greedyhao.cc/2018/09/17/工作-fpga-2018-09-17-zybo初体验/</id>
    <published>2018-09-17T14:15:21.000Z</published>
    <updated>2018-09-22T05:18:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间过生日，亲戚给了些钱让我自己买生日礼物，早就想搞一块zynq的板了，但是淘宝一看太贵，于是去咸鱼上淘了一块二手的ZYBO(谁知道是不是二手，反正看着挺新)来玩玩。</p><a id="more"></a><p>学习肯定是从官方资料开始的，<em>The Zynq Book</em>了解下，作者都是牛人，他们的介绍看<a href="http://www.zynqbook.com/authors.html" target="_blank" rel="noopener">这里</a>，反正跟着大牛学就没有错，可以避免很多坑。</p><p><em>The Zynq Book</em>系统的讲解了Zynq的相关知识，比如Zynq的架构、应用等，主要偏理论，它的配套书籍<em>The Zynq Book Tutorial</em>，就是实战内容了，可以跟着Tutorial动手，一步步完成实验，对学习使用Zynq和它的开发软件Vivado很有帮助。</p><p>目前我刚刚学习完第一个练习，很开心，迫不及待的跑过来分享一下我的体验。</p><p>首先，开发板越多人使用越好，最好要选择大公司，他们的生态比小公司生产的开发板要好很多。就像我这次，在第一个实验就出现了问题，明明按照Tutorial说明的实验步骤操作的，但是结果却不正确，搜索了很久找不到结果(可能是没找到点上)，然后去Digilent的论坛上发帖提问，才过了几个小时就有人解决了我的问题，原来是我配置GPIO借口时粗心了，配置到btns 4bits去了，导致程序不能正常工作。</p><p>然后就是，Xilinx的体验感觉比Altera的体验要好。Altera的文档不好找，之前使用Altera，翻文档的经历不好受，想找的东西就是找不到；而且tutorial也做的不好。Xilinx做的就比Altera明显好得多了，对文档做了打包，用DocNav管理文档，而且文档有了更新下载很方便；最重要的是新手教程很不错，<em>The Zynq Book</em>很好用。</p><p>最后献上我的体验效果 <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_E1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_led_blink.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>本文所提及的教程已经上传百度云，回复</p><p><strong>下载|Zynq_Book</strong></p><p>获取下载链接</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间过生日，亲戚给了些钱让我自己买生日礼物，早就想搞一块zynq的板了，但是淘宝一看太贵，于是去咸鱼上淘了一块二手的ZYBO(谁知道是不是二手，反正看着挺新)来玩玩。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
      <category term="Zybo" scheme="http://greedyhao.cc/tags/Zybo/"/>
    
      <category term="Zynq" scheme="http://greedyhao.cc/tags/Zynq/"/>
    
  </entry>
  
  <entry>
    <title>代码重定位</title>
    <link href="http://greedyhao.cc/2018/09/13/%E5%B7%A5%E4%BD%9C-x210-2018-09-13-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
    <id>http://greedyhao.cc/2018/09/13/工作-x210-2018-09-13-代码重定位/</id>
    <published>2018-09-13T08:25:18.000Z</published>
    <updated>2018-09-13T11:21:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>代码重定位可以将一段代码镜像到另一个地址，有点像链接，不过镜像位置所占空间大小和原代码位置所占大小相同。</p><a id="more"></a><p>那么为什么要这么做呢</p><p>我们知道，越是高速的设备越贵，因此为了节约成本，这些高速设备空间都比较小，比如像S5PV210中的SRAM，只有96KB的大小，但是不需要初始化；SDRAM虽然可以做到很大，多以G做单位，但是需要软件初始化。</p><p>产品中使用的bootloader可能可以裁剪到几十K的大小，但是如果想使用uboot的话，就会发现，才几十K的空间根本不够用；为了解决这个办法，只好使用重定位的方法，将uboot的代码重定位到容量比较大，速度又还过得去的SDRAM中，在SDRAM中运行系统。</p><h1 id="长跳转与短跳转">长跳转与短跳转</h1><p>在镜像后，运行时地址相关函数地址也会被映射到镜像地址处，要想执行镜像代码处的函数，就需要使用长跳转ldr，而不是短跳转bl。</p><h1 id="adr短加载和ldr长加载的不同">adr短加载和ldr长加载的不同</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//file: .S</span><br><span class="line">...</span><br><span class="line">adr r0, _start</span><br><span class="line">ldr r1, =_start</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//file: .dis</span><br><span class="line">...</span><br><span class="line">d002401c:e24f0024 subr0, pc, #36; 0x24</span><br><span class="line">d0024020:e59f1048 ldrr1, [pc, #72]; d0024070 &lt;run_on_dram+0x10&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="清bss">清bss</h1><p>把链接地址处把bss段清零，这是为了避免脏数据，万一连接处的bss段不为０，会导致c语言中的全局变量不为０。</p><p>运行处的bss段不需要清0，编译器已经帮忙清0过了。</p><h1 id="需要重定位的长度为代码段数据段">需要重定位的长度为代码段＋数据段</h1><h1 id="两级流水线导致pc的值指向前两个字节">两级流水线导致pc的值指向前２两个字节</h1><p>而且pc指针指向的是当前地址，而不是被链接到的地址，实际pc的地址为当前地址加两个字节</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码重定位可以将一段代码镜像到另一个地址，有点像链接，不过镜像位置所占空间大小和原代码位置所占大小相同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="x210" scheme="http://greedyhao.cc/tags/x210/"/>
    
  </entry>
  
  <entry>
    <title>运行c代码前发生了什么</title>
    <link href="http://greedyhao.cc/2018/09/13/%E5%B7%A5%E4%BD%9C-c-language-2018-09-13-%E8%BF%90%E8%A1%8Cc%E4%BB%A3%E7%A0%81%E5%89%8D%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://greedyhao.cc/2018/09/13/工作-c-language-2018-09-13-运行c代码前发生了什么/</id>
    <published>2018-09-13T01:56:04.000Z</published>
    <updated>2018-09-13T11:16:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，c代码也是一种比较高级的语言了，机器是没有办法直接运行的，机器所能理解的只有机器码--那一串0和1而已。</p><a id="more"></a><p>虽然早就知道c代码是先经过编译链接最后才放在机器上执行，但是在这么一个过程中究竟发生了什么，最近在学习嵌入式裸机开发中，才又有了更深入的了解。</p><h1 id="简单描述一下生成机器代码过程">简单描述一下生成机器代码过程</h1><h2 id="编译过程">编译过程</h2><p>编译过程是以前就知道了的，预编译会对一些带#号的预编译命令处理，如#define等，编译器会对他们进行替换得到.i文件，然后进一步编译得到.o文件。</p><h2 id="链接过程">链接过程</h2><p>在将源文件编译成可执行文件时，有一个过程是链接。</p><p>其实我以前就对这个链接过程感觉有些不解的，这个链接过程到底是怎么把这些.o文件链接在一起，是有一种什么样的规则呢，总不可能随便链接的吧，随便链接的话怎么解决依赖问题。</p><p>直到之前了解了一下alios系统，在学习的过程中发现，在芯片架构的支持中，有一个elf文件，里面定义了一些地址，当时还不知道有什么用；最近学习裸机开发中，也遇到了这么一个类似的lds文件。</p><p>通过学习，才知道，原来这种文件定义了各个段如代码段、数据段等的地址，这样编译器在链接的过程中，就知道了要把各种.o文件以什么样的顺序链接，链接在什么地址处。</p><h1 id="准备c语言运行环境">准备c语言运行环境</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/c_language/StartupCode.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这是我在网上找的图，从图中可以看出，为了使c程序可以执行在目标处理器，链接的过程中，还混入了一些其他的东西，比如Startup Code。</p><p>在Startup Code中，会做一系列的事，比如关中断、重定位、申请栈空间等等，具体过程和硬件相关。</p><p>最后跳转到main()。</p><p>网上有一篇基于ARM介绍这些相关知识的，非常建议去看看，可以解决自己以前嵌入式编程的很多疑惑。</p><p>http://www.bravegnu.org/gnu-eprog/c-startup.html</p><h1 id="篇外话">篇外话</h1><p>这篇博文是在接触到了一些启动代码后突然有的想法，就开始整理自己的思路，写的同时，在谷歌上查找自己疑惑的地方，从runtime environment查到startup code，结果发现自己疑惑的地方却更多了O__O &quot;…，好好的一篇科普文变成了推荐阅读文(手动笑哭)</p><p>非常建议看看下面给出的参考资料，相信对初学者会有很大帮助。</p><h1 id="参考资料">参考资料</h1><ul><li><a href="http://www.bravegnu.org/gnu-eprog/c-startup.html" target="_blank" rel="noopener">C Startup</a></li><li><a href="http://microchipdeveloper.com/tls2101:c-runtime-environment" target="_blank" rel="noopener">Microchip Developer Help</a></li><li><a href="https://stackoverflow.com/questions/3393611/flow-of-startup-code-in-an-embedded-system-concept-of-boot-loader" target="_blank" rel="noopener">Flow of Startup code in an embedded system , concept of boot loader?</a></li><li><a href="https://www.zhihu.com/question/49580321" target="_blank" rel="noopener">C 如何编译出一个不需要操作系统的程序？</a></li><li><a href="http://www.cnblogs.com/pengdonglin137/p/3234367.html" target="_blank" rel="noopener">数据段、代码段、堆栈段、BSS段的区别</a></li><li><a href="https://blog.csdn.net/koozxcv/article/details/49533731" target="_blank" rel="noopener">Linux进程的五个段（数据段、代码段、bss、堆栈段）</a></li></ul><hr><p><img src="/img/wechat_official_accounts.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，c代码也是一种比较高级的语言了，机器是没有办法直接运行的，机器所能理解的只有机器码--那一串0和1而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="x210" scheme="http://greedyhao.cc/tags/x210/"/>
    
  </entry>
  
</feed>
