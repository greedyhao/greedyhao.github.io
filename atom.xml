<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhuhao&#39;s Blog</title>
  <subtitle>I am the captain of my ship and the master of my fate.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://greedyhao.cc/"/>
  <updated>2018-09-29T12:48:34.037Z</updated>
  <id>http://greedyhao.cc/</id>
  
  <author>
    <name>Greedyhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对Xil_Out32未定义的引用</title>
    <link href="http://greedyhao.cc/2018/09/29/%E5%B7%A5%E4%BD%9C-fpga-2018-09-29-%E5%AF%B9Xil-Out32%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <id>http://greedyhao.cc/2018/09/29/工作-fpga-2018-09-29-对Xil-Out32未定义的引用/</id>
    <published>2018-09-29T12:48:10.000Z</published>
    <updated>2018-09-29T12:48:34.037Z</updated>
    
    <content type="html"><![CDATA[<p>第一次在HLS中遇见一个官方的函数未定义问题，这就把解决方法记录下来。</p>
<a id="more"></a>
<p>在创建好工程，写完工程代码后，发现报错如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./src/led_controller_test_tut_4A.o：在函数‘main’中：</span><br><span class="line">/home/greedyhao/Projects/LearningAndWorking/led_controller/led_controller.sdk/LED_Controller_test/Debug/../src/led_controller_test_tut_4A.c:44：对‘Xil_Out32’未定义的引用</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">makefile:39: recipe for target &apos;LED_Controller_test.elf&apos; failed</span><br><span class="line">make: *** [LED_Controller_test.elf] Error 1</span><br></pre></td></tr></table></figure>
<p>一眼就知道<strong>Xil_Out32</strong>这个函数，绝对是官方定义的啊。</p>
<p>找到它的定义在<em>xil_io.h</em>这个文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> INLINE <span class="keyword">void</span> <span class="title">Xil_Out32</span><span class="params">(UINTPTR Addr, u32 Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在网上查到有人说，因为这个函数是static的，所以将这个头文件include到主函数的文件就可以了</p>
<p>于是在主函数文件添加<strong>#include &quot;xil_io.h&quot;</strong>并保存好，工程正常</p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次在HLS中遇见一个官方的函数未定义问题，这就把解决方法记录下来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
  </entry>
  
  <entry>
    <title>Vivado生成Bitstream失败的解决方法</title>
    <link href="http://greedyhao.cc/2018/09/29/%E5%B7%A5%E4%BD%9C-fpga-2018-09-29-Vivado%E7%94%9F%E6%88%90Bitstream%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://greedyhao.cc/2018/09/29/工作-fpga-2018-09-29-Vivado生成Bitstream失败的解决方法/</id>
    <published>2018-09-29T09:18:12.000Z</published>
    <updated>2018-09-29T09:18:27.204Z</updated>
    
    <content type="html"><![CDATA[<p>跟着实验指导书，难得的又遇到问题了，在最后生成Bitstream的时候出错了，无法生成Bitstream。</p>
<a id="more"></a>
<p>报错信息如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[DRC NSTD-1] Unspecified I/O Standard: 4 out of 134 logical ports use I/O standard (IOSTANDARD) value &apos;DEFAULT&apos;, instead of a user assigned specific value. This may cause I/O contention or incompatibility with the board power or connectivity affecting performance, signal integrity or in extreme cases cause damage to the device or the components to which it is connected. To correct this violation, specify all I/O standards. This design will fail to generate a bitstream unless all logical ports have a user specified I/O standard value defined. To allow bitstream creation with unspecified I/O standard values (not recommended), use this command: set_property SEVERITY &#123;Warning&#125; [get_drc_checks NSTD-1].  NOTE: When using the Vivado Runs infrastructure (e.g. launch_runs Tcl command), add this command to a .tcl file and add that file as a pre-hook for write_bitstream step for the implementation run. Problem ports: LEDs_out_0[3:0].</span><br><span class="line"></span><br><span class="line">[DRC UCIO-1] Unconstrained Logical Port: 4 out of 134 logical ports have no user assigned specific location constraint (LOC). ... Problem ports: LEDs_out_0[3:0].</span><br></pre></td></tr></table></figure>
<p>在我绝望的时候在网上搜到了解决方法，问题还是出在了XDC文件上</p>
<p>我是直接复制的实验指导书中的XDC文件中的内容，但是在生成ked_controller这个ip核的port的时候，生成的port的名字和实验中的并不一样。</p>
<p>xdc文件内容如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set_property PACKAGE_PIN M14            [get_ports &#123;LEDs_out[0]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 		[get_ports &#123;LEDs_out[0]&#125;]</span><br><span class="line">set_property PACKAGE_PIN M15 			[get_ports &#123;LEDs_out[1]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 		[get_ports &#123;LEDs_out[1]&#125;]</span><br><span class="line">set_property PACKAGE_PIN G14 		    [get_ports &#123;LEDs_out[2]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 		[get_ports &#123;LEDs_out[2]&#125;]</span><br><span class="line">set_property PACKAGE_PIN D18 			[get_ports &#123;LEDs_out[3]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 		[get_ports &#123;LEDs_out[3]&#125;]</span><br></pre></td></tr></table></figure></p>
<p>注意下我的DRC报错信息就会发现一个重要的信息 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Problem ports: LEDs_out_0[3:0].</span><br></pre></td></tr></table></figure></p>
<p>这报错的port似乎有点不对劲，和约束文件中声明的port不一样，这也是为什么报错说LEDs_out_0这个port unspecified的原因，因为你XDC中声明的是LEDs_out啊。</p>
<p>解决方法很简单，把这个port的名字改了就好，更改方法如图。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/xilinx/zybo_E4a_BitERR.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟着实验指导书，难得的又遇到问题了，在最后生成Bitstream的时候出错了，无法生成Bitstream。&lt;/p&gt;
    
    </summary>
    
      <category term="入门学习" scheme="http://greedyhao.cc/categories/%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
      <category term="Zybo" scheme="http://greedyhao.cc/tags/Zybo/"/>
    
  </entry>
  
  <entry>
    <title>ZynqBook实验二的实践</title>
    <link href="http://greedyhao.cc/2018/09/21/%E5%B7%A5%E4%BD%9C-fpga-2018-09-21-ZynqBook%E5%AE%9E%E9%AA%8C%E4%BA%8C%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>http://greedyhao.cc/2018/09/21/工作-fpga-2018-09-21-ZynqBook实验二的实践/</id>
    <published>2018-09-21T15:50:54.000Z</published>
    <updated>2018-09-22T05:18:07.317Z</updated>
    
    <content type="html"><![CDATA[<p>首先自然是跟着实验指导书做实验了</p>
<a id="more"></a>
<h1 id="实验2b">实验2B</h1>
<p>然后发现别人添加另外一个gpio的方法是需要重新添加一个gpio的ip核的，而不是直接用同一个ip核的另外一个gpio口</p>
<p><sub>而且感觉在SDK上编程的体验还是不太佳，没有代码自动补全能力</sub>~ ，网上搜索了一下，发现代码补全的能力是有的，快捷键<strong>alt+/</strong></p>
<p>这个实验的目标是使用中断检测按键输入，然后控制led灯的变换，按键(btns)按下时，对应leds的那一位加1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InterruptSystemSetup</span><span class="params">(XScuGic *XScuGicInstancePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Enable interrupt</span></span><br><span class="line">	XGpio_InterruptEnable(&amp;BTNInst, BTN_INT);</span><br><span class="line">	XGpio_InterruptGlobalEnable(&amp;BTNInst);</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IntcInitFunction</span><span class="params">(u16 DeviceId, XGpio *GpioInstancePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    status = XScuGic_Connect(&amp;INTCInst,</span><br><span class="line">                            INTC_GPIO_INTERRUPT_ID,</span><br><span class="line">                            (Xil_ExceptionHandler)BTN_Intr_Handler,</span><br><span class="line">                            (<span class="keyword">void</span> *)GpioInstancePtr);</span><br><span class="line">	<span class="keyword">if</span>(status != XST_SUCCESS) <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable GPIO interrupts interrupt</span></span><br><span class="line">	XGpio_InterruptEnable(GpioInstancePtr, <span class="number">1</span>);</span><br><span class="line">	XGpio_InterruptGlobalEnable(GpioInstancePtr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enable GPIO and timer interrupts in the controller</span></span><br><span class="line">	XScuGic_Enable(&amp;INTCInst, INTC_GPIO_INTERRUPT_ID);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zynq的ps这边使用中断和以前mcu开发时很像，也都是需要先对中断注册，然后开中断，最后才能使用。</p>
<p>中断能用了，还要声明一个处理中断的函数，这个例程中的<em>BTN_Intr_Handler</em>就是一个处理中断的函数，在初始化中断的时候就注册好了。</p>
<p>效果如下： <figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/xilinx/zybo_E2b.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="实验2b总结">实验2B总结</h2>
<p>通过这个部分的实验，学会了如何在Vivado中，开启一个ip的中断，又是怎么与zynq的ps核连接。</p>
<p>还学习到，要想在ps中使用这个中断，需要注册初始化这个中断和声明一个处理中断的函数。</p>
<h1 id="实验2d">实验2D</h1>
<p>这个实验是教我们添加更多的中断源，很现实的一个例子。</p>
<p>目前来看，ps添加多个中断源，需要增加一个mask，通过判定加了mask后的中断号，来判定是哪一个外设产生的中断。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/xilinx/zybo_E2b.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>这个实验添加了一个定时器中断源，在上一个实验的基础上使用了定时器中断，每三次定时器中断会让leds的值加1，控制定时器中断时间的，是<em>TMRInst</em>这个变量，每达到设置的0xF8000000这个值，触发一次中断</p>
<p>效果如下： <figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/xilinx/zybo_E2d.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="实验2d总结">实验2D总结</h2>
<p>学习了怎么添加多个中断源</p>
<p>学习了xilinx中的定时器的使用</p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先自然是跟着实验指导书做实验了&lt;/p&gt;
    
    </summary>
    
      <category term="入门学习" scheme="http://greedyhao.cc/categories/%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
      <category term="Zybo" scheme="http://greedyhao.cc/tags/Zybo/"/>
    
  </entry>
  
  <entry>
    <title>ZynqBook实验一延伸部分</title>
    <link href="http://greedyhao.cc/2018/09/21/%E5%B7%A5%E4%BD%9C-fpga-2018-09-21-ZynqBook%E5%AE%9E%E9%AA%8C%E4%B8%80%E5%BB%B6%E4%BC%B8%E9%83%A8%E5%88%86/"/>
    <id>http://greedyhao.cc/2018/09/21/工作-fpga-2018-09-21-ZynqBook实验一延伸部分/</id>
    <published>2018-09-21T14:46:44.000Z</published>
    <updated>2018-09-22T06:42:53.161Z</updated>
    
    <content type="html"><![CDATA[<p>实验一的内容主要就是如何为zybo创建工程，然后如何烧写这第一个程序。尽管只是一个简单的LED闪烁的程序，但是对学习开发zybo的帮助还是很大的。</p>
<a id="more"></a>
<p>上次的实验，是直接使用zynqbook提供的代码，是让led 0 3位和1 2位的交替闪烁</p>
<p>根据实验指导书建议的，自己修改led的闪烁方式</p>
<p>我将它的闪烁方式改成了类似流水灯的闪烁方式、</p>
<p>原理就是和一个移动的位异或，然后循环左移这个位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Definitions */</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED 0x0										<span class="comment">/* Initial LED value - X00X */</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LEDOutputExample</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Loop forever blinking the LED. */</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">/* Flip LEDs. */</span></span><br><span class="line"><span class="comment">//				led = ~led;</span></span><br><span class="line">			led = led ^ (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= <span class="number">4</span>) i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Wait a small amount of time so that the LED blinking is visible. */</span></span><br><span class="line">			<span class="keyword">for</span> (Delay = <span class="number">0</span>; Delay &lt; LED_DELAY; Delay++);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> XST_SUCCESS; <span class="comment">/* Should be unreachable */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下： <figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/xilinx/zybo_E1x.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>至于第三个建议扩展一个io的部分，我没有实现</p>
<p>因为我在block design中添加gpio2后，在sdk中没有生成gpio2的定义</p>
<p>于是我决定在第二个实验中寻找答案</p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实验一的内容主要就是如何为zybo创建工程，然后如何烧写这第一个程序。尽管只是一个简单的LED闪烁的程序，但是对学习开发zybo的帮助还是很大的。&lt;/p&gt;
    
    </summary>
    
      <category term="入门学习" scheme="http://greedyhao.cc/categories/%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
      <category term="Zybo" scheme="http://greedyhao.cc/tags/Zybo/"/>
    
  </entry>
  
  <entry>
    <title>linux命令行运行第三方软件</title>
    <link href="http://greedyhao.cc/2018/09/18/%E5%B7%A5%E4%BD%9C-Linux-2018-09-18-linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6/"/>
    <id>http://greedyhao.cc/2018/09/18/工作-Linux-2018-09-18-linux命令行运行第三方软件/</id>
    <published>2018-09-18T07:41:50.000Z</published>
    <updated>2018-09-18T08:30:46.514Z</updated>
    
    <content type="html"><![CDATA[<p>linux的宗旨是万物皆文件，所以很多不在源中的程序就是解包即用，但这样使用起来有些不方便，需要cd到可执行文件目录，然后再运行，显得有些麻烦。</p>
<a id="more"></a>
<p>就以最近下载的一个软件为例</p>
<p>它的执行命令为 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar proxyee-down-main.jar</span><br></pre></td></tr></table></figure></p>
<p>保存到proxyee-down后，发现无法运行，就给权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x proxyee-down</span><br></pre></td></tr></table></figure>
<p>但是发现这样的话，还是只能在这个jar包的位置才能正常执行这个文件</p>
<p>想到shell下可以使用pwd查看当前目录</p>
<p>于是首先先加上标记，告诉系统使用bash <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">java -jar $(<span class="built_in">pwd</span>)/proxyee-down-main.jar</span><br></pre></td></tr></table></figure></p>
<p>但是发现pwd给的是当前目录，而不是脚本的目录，于是改用dirname</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">work_path=$(dirname $(readlink -f <span class="variable">$0</span>))</span><br><span class="line">java -jar <span class="variable">$&#123;work_path&#125;</span>/proxyee-down-main.jar</span><br></pre></td></tr></table></figure>
<p>在命令行测试成功</p>
<hr>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="http://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">Shell 教程</a></li>
<li><a href="https://blog.csdn.net/qq_18150497/article/details/76600828" target="_blank" rel="noopener">shell 当前工作目录的绝对路径</a></li>
</ul>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux的宗旨是万物皆文件，所以很多不在源中的程序就是解包即用，但这样使用起来有些不方便，需要cd到可执行文件目录，然后再运行，显得有些麻烦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://greedyhao.cc/tags/Linux/"/>
    
      <category term="Shell" scheme="http://greedyhao.cc/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>zybo初体验</title>
    <link href="http://greedyhao.cc/2018/09/17/%E5%B7%A5%E4%BD%9C-fpga-2018-09-17-zybo%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://greedyhao.cc/2018/09/17/工作-fpga-2018-09-17-zybo初体验/</id>
    <published>2018-09-17T14:15:21.000Z</published>
    <updated>2018-09-22T05:18:03.881Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间过生日，亲戚给了些钱让我自己买生日礼物，早就想搞一块zynq的板了，但是淘宝一看太贵，于是去咸鱼上淘了一块二手的ZYBO(谁知道是不是二手，反正看着挺新)来玩玩。</p>
<a id="more"></a>
<p>学习肯定是从官方资料开始的，<em>The Zynq Book</em>了解下，作者都是牛人，他们的介绍看<a href="http://www.zynqbook.com/authors.html" target="_blank" rel="noopener">这里</a>，反正跟着大牛学就没有错，可以避免很多坑。</p>
<p><em>The Zynq Book</em>系统的讲解了Zynq的相关知识，比如Zynq的架构、应用等，主要偏理论，它的配套书籍<em>The Zynq Book Tutorial</em>，就是实战内容了，可以跟着Tutorial动手，一步步完成实验，对学习使用Zynq和它的开发软件Vivado很有帮助。</p>
<p>目前我刚刚学习完第一个练习，很开心，迫不及待的跑过来分享一下我的体验。</p>
<p>首先，开发板越多人使用越好，最好要选择大公司，他们的生态比小公司生产的开发板要好很多。就像我这次，在第一个实验就出现了问题，明明按照Tutorial说明的实验步骤操作的，但是结果却不正确，搜索了很久找不到结果(可能是没找到点上)，然后去Digilent的论坛上发帖提问，才过了几个小时就有人解决了我的问题，原来是我配置GPIO借口时粗心了，配置到btns 4bits去了，导致程序不能正常工作。</p>
<p>然后就是，Xilinx的体验感觉比Altera的体验要好。Altera的文档不好找，之前使用Altera，翻文档的经历不好受，想找的东西就是找不到；而且tutorial也做的不好。Xilinx做的就比Altera明显好得多了，对文档做了打包，用DocNav管理文档，而且文档有了更新下载很方便；最重要的是新手教程很不错，<em>The Zynq Book</em>很好用。</p>
<p>最后献上我的体验效果 <figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/xilinx/zybo_E1.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/xilinx/zybo_led_blink.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<hr>
<p>本文所提及的教程已经上传百度云，回复</p>
<p><strong>下载|Zynq_Book</strong></p>
<p>获取下载链接</p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间过生日，亲戚给了些钱让我自己买生日礼物，早就想搞一块zynq的板了，但是淘宝一看太贵，于是去咸鱼上淘了一块二手的ZYBO(谁知道是不是二手，反正看着挺新)来玩玩。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
      <category term="Zynq" scheme="http://greedyhao.cc/tags/Zynq/"/>
    
      <category term="Zybo" scheme="http://greedyhao.cc/tags/Zybo/"/>
    
  </entry>
  
  <entry>
    <title>代码重定位</title>
    <link href="http://greedyhao.cc/2018/09/13/%E5%B7%A5%E4%BD%9C-x210-2018-09-13-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
    <id>http://greedyhao.cc/2018/09/13/工作-x210-2018-09-13-代码重定位/</id>
    <published>2018-09-13T08:25:18.000Z</published>
    <updated>2018-09-13T11:21:05.240Z</updated>
    
    <content type="html"><![CDATA[<p>代码重定位可以将一段代码镜像到另一个地址，有点像链接，不过镜像位置所占空间大小和原代码位置所占大小相同。</p>
<a id="more"></a>
<p>那么为什么要这么做呢</p>
<p>我们知道，越是高速的设备越贵，因此为了节约成本，这些高速设备空间都比较小，比如像S5PV210中的SRAM，只有96KB的大小，但是不需要初始化；SDRAM虽然可以做到很大，多以G做单位，但是需要软件初始化。</p>
<p>产品中使用的bootloader可能可以裁剪到几十K的大小，但是如果想使用uboot的话，就会发现，才几十K的空间根本不够用；为了解决这个办法，只好使用重定位的方法，将uboot的代码重定位到容量比较大，速度又还过得去的SDRAM中，在SDRAM中运行系统。</p>
<h1 id="长跳转与短跳转">长跳转与短跳转</h1>
<p>在镜像后，运行时地址相关函数地址也会被映射到镜像地址处，要想执行镜像代码处的函数，就需要使用长跳转ldr，而不是短跳转bl。</p>
<h1 id="adr短加载和ldr长加载的不同">adr短加载和ldr长加载的不同</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//file: .S</span><br><span class="line">...</span><br><span class="line">adr r0, _start</span><br><span class="line">ldr r1, =_start</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//file: .dis</span><br><span class="line">...</span><br><span class="line">d002401c:	e24f0024 	sub	r0, pc, #36	; 0x24</span><br><span class="line">d0024020:	e59f1048 	ldr	r1, [pc, #72]	; d0024070 &lt;run_on_dram+0x10&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="清bss">清bss</h1>
<p>把链接地址处把bss段清零，这是为了避免脏数据，万一连接处的bss段不为０，会导致c语言中的全局变量不为０。</p>
<p>运行处的bss段不需要清0，编译器已经帮忙清0过了。</p>
<h1 id="需要重定位的长度为代码段数据段">需要重定位的长度为代码段＋数据段</h1>
<h1 id="两级流水线导致pc的值指向前两个字节">两级流水线导致pc的值指向前２两个字节</h1>
<p>而且pc指针指向的是当前地址，而不是被链接到的地址，实际pc的地址为当前地址加两个字节</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码重定位可以将一段代码镜像到另一个地址，有点像链接，不过镜像位置所占空间大小和原代码位置所占大小相同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="x210" scheme="http://greedyhao.cc/tags/x210/"/>
    
  </entry>
  
  <entry>
    <title>运行c代码前发生了什么</title>
    <link href="http://greedyhao.cc/2018/09/13/%E5%B7%A5%E4%BD%9C-c-language-2018-09-13-%E8%BF%90%E8%A1%8Cc%E4%BB%A3%E7%A0%81%E5%89%8D%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://greedyhao.cc/2018/09/13/工作-c-language-2018-09-13-运行c代码前发生了什么/</id>
    <published>2018-09-13T01:56:04.000Z</published>
    <updated>2018-09-13T11:16:41.364Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，c代码也是一种比较高级的语言了，机器是没有办法直接运行的，机器所能理解的只有机器码--那一串0和1而已。</p>
<a id="more"></a>
<p>虽然早就知道c代码是先经过编译链接最后才放在机器上执行，但是在这么一个过程中究竟发生了什么，最近在学习嵌入式裸机开发中，才又有了更深入的了解。</p>
<h1 id="简单描述一下生成机器代码过程">简单描述一下生成机器代码过程</h1>
<h2 id="编译过程">编译过程</h2>
<p>编译过程是以前就知道了的，预编译会对一些带#号的预编译命令处理，如#define等，编译器会对他们进行替换得到.i文件，然后进一步编译得到.o文件。</p>
<h2 id="链接过程">链接过程</h2>
<p>在将源文件编译成可执行文件时，有一个过程是链接。</p>
<p>其实我以前就对这个链接过程感觉有些不解的，这个链接过程到底是怎么把这些.o文件链接在一起，是有一种什么样的规则呢，总不可能随便链接的吧，随便链接的话怎么解决依赖问题。</p>
<p>直到之前了解了一下alios系统，在学习的过程中发现，在芯片架构的支持中，有一个elf文件，里面定义了一些地址，当时还不知道有什么用；最近学习裸机开发中，也遇到了这么一个类似的lds文件。</p>
<p>通过学习，才知道，原来这种文件定义了各个段如代码段、数据段等的地址，这样编译器在链接的过程中，就知道了要把各种.o文件以什么样的顺序链接，链接在什么地址处。</p>
<h1 id="准备c语言运行环境">准备c语言运行环境</h1>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/c_language/StartupCode.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>这是我在网上找的图，从图中可以看出，为了使c程序可以执行在目标处理器，链接的过程中，还混入了一些其他的东西，比如Startup Code。</p>
<p>在Startup Code中，会做一系列的事，比如关中断、重定位、申请栈空间等等，具体过程和硬件相关。</p>
<p>最后跳转到main()。</p>
<p>网上有一篇基于ARM介绍这些相关知识的，非常建议去看看，可以解决自己以前嵌入式编程的很多疑惑。</p>
<p>http://www.bravegnu.org/gnu-eprog/c-startup.html</p>
<h1 id="篇外话">篇外话</h1>
<p>这篇博文是在接触到了一些启动代码后突然有的想法，就开始整理自己的思路，写的同时，在谷歌上查找自己疑惑的地方，从runtime environment查到startup code，结果发现自己疑惑的地方却更多了O__O &quot;…，好好的一篇科普文变成了推荐阅读文(手动笑哭)</p>
<p>非常建议看看下面给出的参考资料，相信对初学者会有很大帮助。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="http://www.bravegnu.org/gnu-eprog/c-startup.html" target="_blank" rel="noopener">C Startup</a></li>
<li><a href="http://microchipdeveloper.com/tls2101:c-runtime-environment" target="_blank" rel="noopener">Microchip Developer Help</a></li>
<li><a href="https://stackoverflow.com/questions/3393611/flow-of-startup-code-in-an-embedded-system-concept-of-boot-loader" target="_blank" rel="noopener">Flow of Startup code in an embedded system , concept of boot loader?</a></li>
<li><a href="https://www.zhihu.com/question/49580321" target="_blank" rel="noopener">C 如何编译出一个不需要操作系统的程序？</a></li>
<li><a href="http://www.cnblogs.com/pengdonglin137/p/3234367.html" target="_blank" rel="noopener">数据段、代码段、堆栈段、BSS段的区别</a></li>
<li><a href="https://blog.csdn.net/koozxcv/article/details/49533731" target="_blank" rel="noopener">Linux进程的五个段（数据段、代码段、bss、堆栈段）</a></li>
</ul>
<hr>
<div class="figure">
<img src="/img/wechat_official_accounts.jpg">

</div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，c代码也是一种比较高级的语言了，机器是没有办法直接运行的，机器所能理解的只有机器码--那一串0和1而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="x210" scheme="http://greedyhao.cc/tags/x210/"/>
    
  </entry>
  
  <entry>
    <title>Vivado无法连接到开发板</title>
    <link href="http://greedyhao.cc/2018/09/12/%E5%B7%A5%E4%BD%9C-fpga-2018-09-12-Vivado%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    <id>http://greedyhao.cc/2018/09/12/工作-fpga-2018-09-12-Vivado无法连接到开发板/</id>
    <published>2018-09-12T03:09:48.000Z</published>
    <updated>2018-09-12T03:12:52.983Z</updated>
    
    <content type="html"><![CDATA[<p>从咸鱼上淘了一块二手的ZYBO来玩，因为出了新版开发板ZYBO-Z7，所以旧版的还是比较便宜，才600来块</p>
<p>在使用Hardware Manage的auto connect连接开发板的时候发现，无论开发板是使用QSPI还是JTAG模式，都无法连接到电脑</p>
<p>参考自<a href="https://forums.xilinx.com/t5/Installation-and-Licensing/Vivado-2015-2-Cable-driver-installation-problem/td-p/642140" target="_blank" rel="noopener">Vivado 2015.2 Cable driver installation problem</a></p>
<p>发现我缺少了驱动的安装</p>
<p>步骤如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;Vivado installation dir&gt;/data/xicom/cable_drivers/lin64/install_script/install_drivers/</span><br><span class="line">./install_drivers</span><br></pre></td></tr></table></figure></p>
<p>下面是我的输出结果，不知道为什么有个CRITICAL WARNING，暂时没有找到解决方法，也没有遇见问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:/usr/<span class="built_in">local</span>/Xilinx/Vivado/2018.2/data/xicom/cable_drivers/lin64/install_script/install_drivers$ sudo ./install_drivers </span><br><span class="line">[sudo] greedyhao 的密码： </span><br><span class="line">INFO: Installing cable drivers.</span><br><span class="line">INFO: Script name = ./install_drivers</span><br><span class="line">INFO: HostName = greedyhao-HP-Pavilion-Notebook</span><br><span class="line">INFO: Current working dir = /usr/<span class="built_in">local</span>/Xilinx/Vivado/2018.2/data/xicom/cable_drivers/lin64/install_script/install_drivers</span><br><span class="line">INFO: Kernel version = 4.15.0-34-generic.</span><br><span class="line">INFO: Arch = x86_64.</span><br><span class="line">Successfully installed Digilent Cable Drivers</span><br><span class="line">--File /etc/udev/rules.d/52-xilinx-ftdi-usb.rules does not exist.</span><br><span class="line">--File version of /etc/udev/rules.d/52-xilinx-ftdi-usb.rules = 0000.</span><br><span class="line">--Updating rules file.</span><br><span class="line">--File /etc/udev/rules.d/52-xilinx-pcusb.rules does not exist.</span><br><span class="line">--File version of /etc/udev/rules.d/52-xilinx-pcusb.rules = 0000.</span><br><span class="line">--Updating rules file.</span><br><span class="line"></span><br><span class="line">INFO: Digilent Return code = 0</span><br><span class="line">INFO: Xilinx Return code = 0</span><br><span class="line">INFO: Xilinx FTDI Return code = 0</span><br><span class="line">INFO: Return code = 0</span><br><span class="line">INFO: Driver installation successful.</span><br><span class="line">CRITICAL WARNING: Cable(s) on the system must be unplugged <span class="keyword">then</span> plugged back <span class="keyword">in</span> order <span class="keyword">for</span> the driver scripts to update the cables.</span><br></pre></td></tr></table></figure>
<p>参考资料 + <a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2018_1/ug973-vivado-release-notes-install-license.pdf" target="_blank" rel="noopener">ug973-vivado-release-notes-install-license</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从咸鱼上淘了一块二手的ZYBO来玩，因为出了新版开发板ZYBO-Z7，所以旧版的还是比较便宜，才600来块&lt;/p&gt;
&lt;p&gt;在使用Hardware Manage的auto connect连接开发板的时候发现，无论开发板是使用QSPI还是JTAG模式，都无法连接到电脑&lt;/p&gt;

    
    </summary>
    
    
      <category term="FPGA" scheme="http://greedyhao.cc/tags/FPGA/"/>
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
  </entry>
  
  <entry>
    <title>Vivado启动遇见QSslSocket系列问题</title>
    <link href="http://greedyhao.cc/2018/09/12/%E5%B7%A5%E4%BD%9C-fpga-2018-09-12-Vivado%E5%90%AF%E5%8A%A8%E9%81%87%E8%A7%81QSslSocket%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>http://greedyhao.cc/2018/09/12/工作-fpga-2018-09-12-Vivado启动遇见QSslSocket系列问题/</id>
    <published>2018-09-12T02:34:11.000Z</published>
    <updated>2018-09-12T02:57:19.601Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~$ vivado</span><br><span class="line"></span><br><span class="line">****** Vivado v2018.2 (64-bit)</span><br><span class="line">  **** SW Build 2258646 on Thu Jun 14 20:02:38 MDT 2018</span><br><span class="line">  **** IP Build 2256618 on Thu Jun 14 22:10:49 MDT 2018</span><br><span class="line">    ** Copyright 1986-2018 Xilinx, Inc. All Rights Reserved.</span><br><span class="line"></span><br><span class="line">start_gui</span><br><span class="line"></span><br><span class="line">QSslSocket: cannot resolve CRYPTO_num_locks</span><br><span class="line">QSslSocket: cannot resolve CRYPTO_set_id_callback</span><br><span class="line">QSslSocket: cannot resolve CRYPTO_set_locking_callback</span><br><span class="line">QSslSocket: cannot resolve sk_free</span><br><span class="line">QSslSocket: cannot resolve sk_num</span><br><span class="line">QSslSocket: cannot resolve sk_pop_free</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我发现我每次启动vivado时，都会弹出这些错误信息，而且Hardware Manage的auto connect无法识别我的开发板ZYBO，就想着先解决这些报错信息。</p>
<p>解决方法来自<a href="https://github.com/wkhtmltopdf/wkhtmltopdf/issues/3001" target="_blank" rel="noopener">QSslSocket: cannot resolve SSLv3_client_method / SSLv3_server_method</a></p>
<p>原文是这么说的</p>
<blockquote>
<p>For Debian Stretch users and others with the QSslSocket: cannot resolve $func issue, you just need to install the package libssl1.0-dev (or similar package in your distro).</p>
</blockquote>
<p>打开终端 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libssl1.0-dev</span><br></pre></td></tr></table></figure></p>
<p>安装完成后就会发现，不会再有报错信息出现了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
    
    </summary>
    
    
      <category term="FPGA" scheme="http://greedyhao.cc/tags/FPGA/"/>
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
  </entry>
  
  <entry>
    <title>如何使用matlab进行频域分析</title>
    <link href="http://greedyhao.cc/2018/08/24/%E5%B7%A5%E4%BD%9C-dsp-2018-08-24-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8matlab%E8%BF%9B%E8%A1%8C%E9%A2%91%E5%9F%9F%E5%88%86%E6%9E%90/"/>
    <id>http://greedyhao.cc/2018/08/24/工作-dsp-2018-08-24-如何使用matlab进行频域分析/</id>
    <published>2018-08-24T11:33:08.000Z</published>
    <updated>2018-09-09T05:47:24.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何使用matlab进行频域分析">如何使用matlab进行频域分析</h1>
<p>Matlab可以说是一个非常有用且功能齐全的工具，在通信、自控、金融等方面有广泛的应用。</p>
<p>本文讨论使用Matlab对信号进行频域分析的方法。</p>
<a id="more"></a>
<p>说到频域，不可避免的会提到傅里叶变换，傅里叶变换提供了一个将信号从时域转变到频域的方法。之所以要有信号的频域分析，是因为很多信号在时域不明显的特征可以在频域下得到很好的展现，可以更加容易的进行分析和处理。</p>
<h1 id="fft"><a href="#FFT"></a>FFT</h1>
<p>Matlab提供的傅里叶变换的函数是FFT，中文名叫做快速傅里叶变换。快速傅里叶变换的提出是伟大的，使得处理器处理数字信号的能力大大提升，也使我们生活向数字化迈了一大步。</p>
<p>接下来就谈谈如何使用这个函数。</p>
<p>fft使用很简单，但是一般信号都有x和y两个向量，而fft只会处理y向量，所以想让频域分析变得有意义，那么就需要用户自己处理x向量</p>
<h1 id="一个简单的例子"><a href="#一个简单的例子"></a>一个简单的例子</h1>
<p>从一个简单正弦信号开始吧，正弦信号定义为：</p>
<p><span class="math display">\[
y(t) = 2\sin (2\pi f_0 t)
\]</span></p>
<p>我们现在通过以下代码在Matlab中画出这个正弦曲线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fo = 4;   %frequency of the sine wave</span><br><span class="line">Fs = 100; %sampling rate</span><br><span class="line">Ts = 1/Fs; %sampling time interval</span><br><span class="line">t = 0:Ts:1-Ts; %sampling period</span><br><span class="line">n = length(t); %number of samples</span><br><span class="line">y = 2*sin(2*pi*fo*t); %the sine curve	</span><br><span class="line"></span><br><span class="line">%plot the cosine curve in the time domain</span><br><span class="line">sinePlot = figure;</span><br><span class="line">plot(t,y)</span><br><span class="line">xlabel(&apos;time (seconds)&apos;)</span><br><span class="line">ylabel(&apos;y(t)&apos;)</span><br><span class="line">title(&apos;Sample Sine Wave&apos;)</span><br><span class="line">grid</span><br></pre></td></tr></table></figure>
<p>这就是我们得到的：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/matlab/how_to_use_fft_1.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>当我们对这条曲线fft时，我们希望在频域得到以下频谱（基于傅里叶变换理论，我们希望看见一个幅值为1的峰值在-4Hz处，另一个在+4Hz处）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/matlab/how_to_use_fft_3.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h1 id="使用fft命令"><a href="#使用FFT命令"></a>使用FFT命令</h1>
<p>我们知道目标是什么了，那么现在使用Matlab的内建的FFT函数来重新生成频谱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%plot the frequency spectrum using the MATLAB fft command</span><br><span class="line">matlabFFT = figure;  %create a new figure</span><br><span class="line">YfreqDomain = fft(y); %take the fft of our sin wave, y(t)</span><br><span class="line"></span><br><span class="line">stem(abs(YfreqDomain));  %use abs command to get the magnitude</span><br><span class="line">%similary, we would use angle command to get the phase plot!</span><br><span class="line">%we&apos;ll discuss phase in another post though!</span><br><span class="line"></span><br><span class="line">xlabel(&apos;Sample Number&apos;)</span><br><span class="line">ylabel(&apos;Amplitude&apos;)</span><br><span class="line">title(&apos;Using the Matlab fft command&apos;)</span><br><span class="line">grid</span><br><span class="line">axis([0,100,0,120])</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/matlab/how_to_use_fft_2.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>但是注意一下，这并不是我们真正想要的，有一些信息是缺失的</strong></p>
<ul>
<li>x轴本来应该给我们提供频率信息，但是你能读出频率吗？</li>
<li>幅度都是100</li>
<li>没有让频谱中心为0</li>
</ul>
<h1 id="为fft定义一个函数来获取双边频谱"><a href="#为FFT定义一个函数来获取双边频谱"></a>为FFT定义一个函数来获取双边频谱</h1>
<p>以下代码可以简化获取双边频谱的过程，复制并保存到你的.m文件中</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[X,freq]</span>=<span class="title">centeredFFT</span><span class="params">(x,Fs)</span></span></span><br><span class="line"><span class="comment">%this is a custom function that helps in plotting the two-sided spectrum</span></span><br><span class="line"><span class="comment">%x is the signal that is to be transformed</span></span><br><span class="line"><span class="comment">%Fs is the sampling rate</span></span><br><span class="line">N=<span class="built_in">length</span>(x);</span><br><span class="line"><span class="comment">%this part of the code generates that frequency axis</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">mod</span>(N,<span class="number">2</span>)==<span class="number">0</span></span><br><span class="line">    k=-N/<span class="number">2</span>:N/<span class="number">2</span><span class="number">-1</span>; <span class="comment">% N even</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    k=-(N<span class="number">-1</span>)/<span class="number">2</span>:(N<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">% N odd</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">T=N/Fs;</span><br><span class="line">freq=k/T;  <span class="comment">%the frequency axis</span></span><br><span class="line"><span class="comment">%takes the fft of the signal, and adjusts the amplitude accordingly</span></span><br><span class="line">X=fft(x)/N; <span class="comment">% normalize the data</span></span><br><span class="line">X=fftshift(X); <span class="comment">%shifts the fft data so that it is centered</span></span><br></pre></td></tr></table></figure>
<p>这个函数输出正确的频域范围和变换后的信号，它需要输入需要变换的信号和采样率。</p>
<p>接下来使用前文的正弦信号做一个简单的示例，注意你的示例.m文件要和centeredFFT.m文件在一个目录下</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[YfreqDomain,frequencyRange] = centeredFFT(y,Fs);</span><br><span class="line">centeredFFT = figure;</span><br><span class="line"><span class="comment">%remember to take the abs of YfreqDomain to get the magnitude!</span></span><br><span class="line">stem(frequencyRange,<span class="built_in">abs</span>(YfreqDomain));</span><br><span class="line">xlabel(<span class="string">'Freq (Hz)'</span>)</span><br><span class="line">ylabel(<span class="string">'Amplitude'</span>)</span><br><span class="line">title(<span class="string">'Using the centeredFFT function'</span>)</span><br><span class="line">grid</span><br><span class="line">axis([<span class="number">-6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1.5</span>])</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/matlab/how_to_use_fft_3.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>这张图就满足了我们的需求,我们得到了在+4和-4处的峰值，而且幅值为1.</p>
<h1 id="为fft定义一个函数来获取右边频谱"><a href="#为FFT定义一个函数来获取右边频谱"></a>为FFT定义一个函数来获取右边频谱</h1>
<p>从上图可以看出，FFT变换得到的频谱是左右对称的，因此，我们只需要其中一边就能获得信号的所有信息，我们一般保留正频率一侧。</p>
<p>以下的函数对上面的自定义函数做了一些修改，让它可以帮助我们只画出信号的正频率一侧</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[X,freq]</span>=<span class="title">positiveFFT</span><span class="params">(x,Fs)</span></span></span><br><span class="line">N=<span class="built_in">length</span>(x); <span class="comment">%get the number of points</span></span><br><span class="line">k=<span class="number">0</span>:N<span class="number">-1</span>;     <span class="comment">%create a vector from 0 to N-1</span></span><br><span class="line">T=N/Fs;      <span class="comment">%get the frequency interval</span></span><br><span class="line">freq=k/T;    <span class="comment">%create the frequency range</span></span><br><span class="line">X=fft(x)/N; <span class="comment">% normalize the data</span></span><br><span class="line"><span class="comment">%only want the first half of the FFT, since it is redundant</span></span><br><span class="line">cutOff = <span class="built_in">ceil</span>(N/<span class="number">2</span>);</span><br><span class="line"><span class="comment">%take only the first half of the spectrum</span></span><br><span class="line">X = X(<span class="number">1</span>:cutOff);</span><br><span class="line">freq = freq(<span class="number">1</span>:cutOff);</span><br></pre></td></tr></table></figure>
<p>和前面一样，使用正弦信号做一个示例，下面是示例代码</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[YfreqDomain,frequencyRange] = positiveFFT(y,Fs);</span><br><span class="line">positiveFFT = figure;</span><br><span class="line">stem(frequencyRange,<span class="built_in">abs</span>(YfreqDomain));</span><br><span class="line">set(positiveFFT,<span class="string">'Position'</span>,[<span class="number">500</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">300</span>])</span><br><span class="line">xlabel(<span class="string">'Freq (Hz)'</span>)</span><br><span class="line">ylabel(<span class="string">'Amplitude'</span>)</span><br><span class="line">title(<span class="string">'Using the positiveFFT function'</span>)</span><br><span class="line">grid</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">20</span>,<span class="number">0</span>,<span class="number">1.5</span>])</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/matlab/how_to_use_fft_4.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<hr>
<p>本文内容主要来自Matlab官方FFT教程，但是我找不到原链接了，就把我电脑上的文件上传到了百度云盘，公众号后台回复</p>
<p><strong>下载|FFT_tutorial</strong></p>
<p>获取下载链接</p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何使用matlab进行频域分析&quot;&gt;如何使用matlab进行频域分析&lt;/h1&gt;
&lt;p&gt;Matlab可以说是一个非常有用且功能齐全的工具，在通信、自控、金融等方面有广泛的应用。&lt;/p&gt;
&lt;p&gt;本文讨论使用Matlab对信号进行频域分析的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="dsp" scheme="http://greedyhao.cc/tags/dsp/"/>
    
  </entry>
  
  <entry>
    <title>简单说说卷积的作用</title>
    <link href="http://greedyhao.cc/2018/08/12/%E5%B7%A5%E4%BD%9C-dsp-2018-08-12-%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%E5%8D%B7%E7%A7%AF%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://greedyhao.cc/2018/08/12/工作-dsp-2018-08-12-简单说说卷积的作用/</id>
    <published>2018-08-11T22:53:32.000Z</published>
    <updated>2018-09-09T05:49:18.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单说说卷积的作用">简单说说卷积的作用</h1>
<p>卷积是一个耳熟能详的的词，自从我开始学习信号与系统以后，就一直没有离开过它，不过只是把它当成一个运算符号来看待。</p>
<a id="more"></a>
<p>不过闲着的时候，也会去想，卷积到底有什么作用。</p>
<div class="figure">
<img src="/img/dsp/思考卷积.jpg">

</div>
<h1 id="提供一种方便的频域处理方式"><a href="#提供一种方便的频域处理方式"></a>提供一种方便的频域处理方式</h1>
<p><strong>时域卷积频域相乘</strong></p>
<p>这条法则想必大家都知道，作用非常大，可以轻松的对信号的频域做处理</p>
<p>简单的应用就是频域滤波</p>
<p><span class="math display">\[
g(x) =  \mathscr{F}^{-1}\left[H(x)F(x)\right]
\]</span></p>
<p>F(x)代表输入信号，H(x)代表滤波函数，g(x)代表滤波（输出）信号。</p>
<p>转换到时域则是</p>
<p><span class="math display">\[
g(x) = h(x) \ast f(x)
\]</span></p>
<p>以下是一个声音信号处理的例子，给matlab自带鸟叫声加了一个低通滤波器。</p>
<p>效果如下：</p>
<p>滤波前：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/chirp_bf.bmp" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>滤波后：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/chirp_af.bmp" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% 主函数</span><br><span class="line">close all;</span><br><span class="line">load chirp;</span><br><span class="line">Hd = getFilter; % 使用Filter Builder设计的FIR</span><br><span class="line">X = filter(Hd,y); % 等同于conv(y,Hd.Numerator)</span><br><span class="line"></span><br><span class="line">DrawFFT(y,Fs); % 自定义函数用于画频谱</span><br><span class="line">DrawFFT(X,Fs);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Hd = getFilter</span><br><span class="line">%GETFILTER Returns a discrete-time filter object.</span><br><span class="line"></span><br><span class="line">% MATLAB Code</span><br><span class="line">% Generated by MATLAB(R) 9.4 and DSP System Toolbox 9.6.</span><br><span class="line">% Generated on: 11-Aug-2018 21:15:57</span><br><span class="line"></span><br><span class="line">Fpass = 2500;  % Passband Frequency</span><br><span class="line">Fstop = 3000;  % Stopband Frequency</span><br><span class="line">Apass = 1;     % Passband Ripple (dB)</span><br><span class="line">Astop = 60;    % Stopband Attenuation (dB)</span><br><span class="line">Fs    = 8192;  % Sampling Frequency</span><br><span class="line"></span><br><span class="line">h = fdesign.lowpass( &apos;fp,fst,ap,ast &apos;, Fpass, Fstop, Apass, Astop, Fs);</span><br><span class="line"></span><br><span class="line">Hd = design(h,  &apos;equiripple &apos;, ...</span><br><span class="line">     &apos;MinOrder &apos;,  &apos;any &apos;, ...</span><br><span class="line">     &apos;StopbandShape &apos;,  &apos;flat &apos;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function [  ] = DrawFFT( x, Fs )</span><br><span class="line">% DrawFFT 对输入信号进行快速傅里叶变换</span><br><span class="line">% 输入参数：x ：输入信号；   Fs：采样频率</span><br><span class="line">% by Yang Xiaokang , 2016-02</span><br><span class="line"></span><br><span class="line">L = length(x);</span><br><span class="line"></span><br><span class="line">NFFT = 2^nextpow2(L);          		%确定FFT变换的长度</span><br><span class="line">y = fft(x, NFFT)/L;</span><br><span class="line">f = Fs/2*linspace(0,1,NFFT/2+1);	%频率向量</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line"></span><br><span class="line">plot(f, 2*abs(y(1:NFFT/2+1)));		%绘制频域图像</span><br><span class="line">title( &apos;幅度谱 &apos;);</span><br><span class="line">xlabel( &apos;Frequency (Hz) &apos;);</span><br><span class="line">ylabel( &apos;|y(f)| &apos;);</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% 作者：TaylorSe</span><br><span class="line">% 链接：https://www.zhihu.com/question/46038488/answer/144244073</span><br><span class="line">% 来源：知乎</span><br><span class="line">% 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单说说卷积的作用&quot;&gt;简单说说卷积的作用&lt;/h1&gt;
&lt;p&gt;卷积是一个耳熟能详的的词，自从我开始学习信号与系统以后，就一直没有离开过它，不过只是把它当成一个运算符号来看待。&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="dsp" scheme="http://greedyhao.cc/tags/dsp/"/>
    
  </entry>
  
  <entry>
    <title>mathjax的基本操作</title>
    <link href="http://greedyhao.cc/2018/08/11/%E5%B7%A5%E4%BD%9C-latex-2018-08-11-mathjax%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://greedyhao.cc/2018/08/11/工作-latex-2018-08-11-mathjax的基本操作/</id>
    <published>2018-08-11T08:04:26.000Z</published>
    <updated>2018-09-09T05:58:19.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mathjax的基本操作">mathjax的基本操作</h1>
<p>随着知识难度的加深，对于数学的依赖也不断增加，数学涉及到很多公式，老是用截图的方法总觉得不方便，很早以前就听说了LaTeX，正好博客的主体支持mathjax，就学习一下，拿来使用。</p>
<a id="more"></a>
<p>我使用的是VSCode编辑，为了方便编辑，我安装了一个Markdown+Math的插件，这个插件可以渲染LaTeX的公式，打开预览就可以实时查看自己文章的效果。</p>
<p><a href="https://pic.plover.com/MISC/symbols.pdf" target="_blank" rel="noopener">this shorter listing</a></p>
<h2 id="实现分段函数">实现分段函数</h2>
<p>这是我在网上搜索到的一个人总结的<strong>分段函数的写法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$ 函数名=\begin&#123;cases&#125;</span><br><span class="line">公式1 &amp; 条件1 \\</span><br><span class="line">公式2 &amp; 条件2 \\</span><br><span class="line">公式3 &amp; 条件3 </span><br><span class="line">\end&#123;cases&#125;$$</span><br></pre></td></tr></table></figure>
<p>**&amp;表示对齐，*</p>
<p>一个通带为<span class="math inline">\(\omega_c\lt\pi\)</span>的理想低通滤波器的系统函数的示例如下</p>
<p><span class="math display">\[
H_d(e^{j\omega})=\begin{cases}
1\cdotp e^{j\alpha\omega} &amp; |\omega|\le\omega_e \\\
0 &amp; \omega_e\lt\pi
\end{cases}
\]</span></p>
<h2 id="公式推导过程">公式推导过程</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin &#123;aligned&#125;</span><br><span class="line">A&amp;=B \\</span><br><span class="line">&amp;=C \\</span><br><span class="line">&amp;=D</span><br><span class="line">\end &#123;aligned&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><span class="math display">\[
\begin {aligned}
A&amp;=B \\\
&amp;=C \\\
&amp;=D
\end {aligned}
\]</span></p>
<h2 id="并排显示两个公式">并排显示两个公式</h2>
<p>可以使用~~ <sub>~</sub></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">h(n)=\begin&#123;cases&#125;</span><br><span class="line">h_d(n) &amp; 0\le n\le M-1 \\</span><br><span class="line">0 &amp; elsewhere </span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">~~</span><br><span class="line">and</span><br><span class="line">~~</span><br><span class="line">\alpha = \frac&#123;M-1&#125;&#123;2&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><span class="math display">\[
h(n)=\begin{cases}
h_d(n) &amp; 0\le n\le M-1 \\\
0 &amp; elsewhere
\end{cases}
~~
and
~~
\alpha = \frac{M-1}{2}
\]</span></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mathjax的基本操作&quot;&gt;mathjax的基本操作&lt;/h1&gt;
&lt;p&gt;随着知识难度的加深，对于数学的依赖也不断增加，数学涉及到很多公式，老是用截图的方法总觉得不方便，很早以前就听说了LaTeX，正好博客的主体支持mathjax，就学习一下，拿来使用。&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="latex" scheme="http://greedyhao.cc/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>通信原理学习记录（一）</title>
    <link href="http://greedyhao.cc/2018/08/08/%E5%B7%A5%E4%BD%9C-wireless-2018-08-08-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://greedyhao.cc/2018/08/08/工作-wireless-2018-08-08-通信原理学习记录（一）/</id>
    <published>2018-08-08T09:34:52.000Z</published>
    <updated>2018-09-09T05:52:39.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通信原理学习记录一">通信原理学习记录（一）</h1>
<p>今天刚刚开始学习通信原理，了解了通信原理的知识点，大概是要学习模拟通信与数字通信，模拟通信技术在之前的高频学习中已经有了一定的基础了，对一些调制技术有了一定的认识和分析能力，因此，本学习的通信原理主要的难度在于数字通信技术。</p>
<a id="more"></a>
<p>为了更好的学习通信原理，提前学习是个不错的选择，在<a href="http://www.icourse163.org/learn/NUDT-316006?tid=1002694004&amp;from=study#/learn/content" target="_blank" rel="noopener">MOOC上有个通信原理的课程</a>，阅读原文提供传送门。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wireless/wireless_overview.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>一开始学习遇到了两个新的知识点：<strong>信息及其度量</strong>和<strong>通信系统主要性能指标</strong></p>
<h1 id="信息及其度量"><a href="#信息及其度量"></a>信息及其度量</h1>
<p>学过概率论的我们知道，事件的不确定程度可以用其出现的概率来描述。因此，消息中包含的信息量与消息发生的概率有关。消息出现的概率越小，蕴含的信息量越大。</p>
<p>使用<span class="math inline">\(P(x)\)</span>表示消息发生的概率，<span class="math inline">\(I\)</span>表示消息中的信息量</p>
<p><span class="math display">\[
I = log_a\frac{1}{P(x)} = -log_aP(x)
\]</span></p>
<p>通常使用单位为比特，公式可以简写为</p>
<p><span class="math display">\[
I = log_2\frac{1}{P(x)} = -log_2P(x)
\]</span></p>
<p>这种方法是使用算术平均的方法计算，还有另外一种是使用熵的概念计算</p>
<p><span class="math display">\[
H(x) = -\sum_{i=1}^M P(x_i) log_2 P(x_i)
\]</span></p>
<p>对于较多消息的信息量的计算选择熵的方式更好，因为使用熵的方式计算信息量更加准确，而且也更加方便。</p>
<p><strong>对信息度量的思考：</strong></p>
<p>我总感觉信息度量与密码学之间存在着联系，最简单的密码是通过查表实现的，比如将所有字母位置移1个位置，如A加1变换为B。</p>
<p>现在拥有一份这样加密的密文，统计发现其中某一个字母的出现次数最少，那么它拥有的信息量就最大，是不是就可以通过从这一个字母入手破解全篇的密文。</p>
<p>当然，这只是我的猜测而已，目前还并没有学习密码学的相关知识，在网上搜信息度量与密码学的关系也没搜出什么，估计也是我搜索的姿势不对。</p>
<h1 id="通信系统主要性能指标"><a href="#通信系统主要性能指标"></a>通信系统主要性能指标</h1>
<p>主要性能指标与<strong>有效性</strong>和<strong>可靠性</strong>有关</p>
<h2 id="有效性"><a href="#有效性"></a>有效性</h2>
<p>有效性的衡量与频带利用率有关</p>
<p>对于数字通信系统，频带利用率的定义为单位带宽内的传输速率</p>
<p><span class="math display">\[
\eta = \frac{R_B}{B} \ (Baud/Hz)
~~
or
~~
\eta_b = \frac{R_b}{B} \ (b/(s\cdot Hz))
\]</span></p>
<p>其中<span class="math inline">\(R_B\)</span>为码元传输速率，又称波特率。<span class="math inline">\(R_b\)</span>为信息传输速率，又称比特率。</p>
<p><em>ps: 突然看到波特率也是很兴奋的，学习串口通信那么久，终于看到了波特率的身影了；还有比特率也是好久以前听说的</em></p>
<p>码元速率与信息速率有以下关系</p>
<p><span class="math display">\[
R_b = R_B log_2 M \ (b/s)
\]</span></p>
<p>其中的M表示进制。例如，设码元速率为1200Baud，若采用八进制，则信息速率为3600b/s</p>
<p><em>ps:之前一直不知道MCU的串口通信中的波特率为什么越高，传输速度越快，现在终于知道了</em></p>
<h2 id="可靠性"><a href="#可靠性"></a>可靠性</h2>
<p>模拟通信系统的可靠性场用接收端输出信号与噪声功率比(S/N)来度量</p>
<p>数字通信系统的可靠性用差错概率来衡量。差错概率常用误码率和误信率表示。</p>
<p>误码率<span class="math inline">\(P_e\)</span>为错误码元数与传输总码元数之比</p>
<p>误信率<span class="math inline">\(P_b\)</span>为错误比特数与传输总比特数之比</p>
<hr>
<p>参考书籍：</p>
<ul>
<li>《通信原理》樊昌信第七版</li>
</ul>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;通信原理学习记录一&quot;&gt;通信原理学习记录（一）&lt;/h1&gt;
&lt;p&gt;今天刚刚开始学习通信原理，了解了通信原理的知识点，大概是要学习模拟通信与数字通信，模拟通信技术在之前的高频学习中已经有了一定的基础了，对一些调制技术有了一定的认识和分析能力，因此，本学习的通信原理主要的难度在于数字通信技术。&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="wireless" scheme="http://greedyhao.cc/tags/wireless/"/>
    
  </entry>
  
  <entry>
    <title>LCD-TFT控制总结</title>
    <link href="http://greedyhao.cc/2018/07/31/%E5%B7%A5%E4%BD%9C-stm32-2018-07-31-LCD-TFT%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://greedyhao.cc/2018/07/31/工作-stm32-2018-07-31-LCD-TFT控制总结/</id>
    <published>2018-07-31T09:09:26.000Z</published>
    <updated>2018-09-09T05:52:27.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lcd-tft控制总结">LCD-TFT控制总结</h1>
<p>最近学到LCD了，但是在将野火的代码转移到CubeMX时却遇到了大麻烦，屏幕一直是花的，只有一次正常显示一下下，但是过一段时间就又没了，好几天的时间都找不到问题。</p>
<a id="more"></a>
<h1 id="说说如何找到问题的">说说如何找到问题的</h1>
<p>找到问题的方法是我昨天才想到的，前些天就像无头苍蝇一样到处乱窜，花了很多时间，但是没有用对方法，都是无用功。</p>
<p>后来想到，LCD使用SDRAM最为显存，那么只需要读取SDRAM中的数据就知道为什么显示会有问题了。</p>
<p>通过访问SDRAM中的显存的地址，就可以直接得到SDRAM中的数据。</p>
<p>首先测试清屏函数，读取SDRAM中的数据在清屏前和清屏后的数据有什么不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%s\n&quot;,&quot;-----D000 after clear-----&quot;);</span><br><span class="line">uint32_t i;</span><br><span class="line">uint8_t ubReaddata_8b=0;</span><br><span class="line">for (i=0; i&lt;200; i++) &#123;</span><br><span class="line">  ubReaddata_8b = *(__IO uint8_t*)(0xD0000000 + i);</span><br><span class="line">  printf(&quot;%x &quot;,ubReaddata_8b);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n%s\n&quot;,&quot;-----D000 after clear-----&quot;);</span><br><span class="line">printf(&quot;%s\n&quot;,&quot;-----D020 after clear-----&quot;);</span><br><span class="line">for (i=0; i&lt;200; i++) &#123;</span><br><span class="line">  ubReaddata_8b = *(__IO uint8_t*)(0xD0200000 + i);</span><br><span class="line">  printf(&quot;%x &quot;,ubReaddata_8b);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n%s\n&quot;,&quot;-----D020 after clear-----&quot;);</span><br></pre></td></tr></table></figure>
<p>发现清屏前后数据没有变化，都是一些随机的数据，因此可以推断清屏函数出了问题。</p>
<p>再看看清屏函数(LCD_Clear)，调用了另外一个函数，可以推断应该是<strong>LL_FillBuffer</strong>这个函数出了问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void LL_FillBuffer(uint32_t LayerIndex, void *pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t ColorIndex)</span><br></pre></td></tr></table></figure>
<p>之前使用的DMA2D的R2M模式，我使用M2M模式显示图片发现正常，方法参照<a href="http://www.waveshare.net/study/article-661-1.html" target="_blank" rel="noopener">微雪课堂</a>，再次确认<strong>LL_FillBuffer</strong>这个函数出了问题。</p>
<p>看看<strong>LL_FillBuffer</strong>这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LL_FillBuffer</span><span class="params">(<span class="keyword">uint32_t</span> LayerIndex, <span class="keyword">void</span> *pDst, <span class="keyword">uint32_t</span> xSize, <span class="keyword">uint32_t</span> ySize, <span class="keyword">uint32_t</span> OffLine, <span class="keyword">uint32_t</span> ColorIndex)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Dma2d_Handler.Init.Mode         = DMA2D_R2M;</span><br><span class="line">  <span class="keyword">if</span>(Ltdc_Handler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)</span><br><span class="line">  &#123; </span><br><span class="line">    Dma2d_Handler.Init.ColorMode    = DMA2D_RGB565;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(Ltdc_Handler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* DMA2D 初始化 */</span></span><br><span class="line">  <span class="keyword">if</span>(HAL_DMA2D_Init(&amp;Dma2d_Handler) == HAL_OK) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(HAL_DMA2D_ConfigLayer(&amp;Dma2d_Handler, LayerIndex) == HAL_OK) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (HAL_DMA2D_Start(&amp;Dma2d_Handler, ColorIndex, (<span class="keyword">uint32_t</span>)pDst, xSize, ySize) == HAL_OK)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* DMA轮询传输 */</span>  </span><br><span class="line">        HAL_DMA2D_PollForTransfer(&amp;Dma2d_Handler, <span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它这里操作的是<strong>Dma2d_Handler</strong>这个结构体，但是我用CubeMX生成代码使用的是<strong>hdma2d</strong>这个结构体，再我将<strong>Dma2d_Handler</strong>替换为<strong>hdma2d</strong>后，程序运行正常。</p>
<h1 id="简单介绍一下lcd使用到的外设资源">简单介绍一下LCD使用到的外设资源</h1>
<h2 id="ltdc">LTDC</h2>
<p>液晶面板的信号线如下</p>
<table>
<thead>
<tr class="header">
<th>信号名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>R[7:0]</td>
<td>红色数据</td>
</tr>
<tr class="even">
<td>G[7:0]</td>
<td>绿色数据</td>
</tr>
<tr class="odd">
<td>B[7:0]</td>
<td>蓝色数据</td>
</tr>
<tr class="even">
<td>CLK</td>
<td>像素同步时钟信号</td>
</tr>
<tr class="odd">
<td>HSYNC</td>
<td>水平同步信号</td>
</tr>
<tr class="even">
<td>VSYNC</td>
<td>垂直同步信号</td>
</tr>
<tr class="odd">
<td>DE</td>
<td>数据使能信号</td>
</tr>
</tbody>
</table>
<p>LTDC作为液晶控制器可以使用SDRAM中的部分空间作为显存，直接控制液晶面板。</p>
<p>我们需要做的就是参考液晶屏的资料，将液晶屏的像素、控制时序等对LTDC进行初始化，LTDC就会自动对液晶屏进行刷新控制。</p>
<h2 id="dma2d">DMA2D</h2>
<p>DMA2D用于图像数据搬运、混合及格式转换</p>
<p>有四种模式：DMA2D_M2M、DMA2D_M2M_PFC、DMA2D_M2M_BLEND、DMA2D_R2M</p>
<p>暂时只用过M2M和R2M，觉得M2M最好用了，将图片转为数组，开启存储器到存储器的DMA，通过<strong>HAL_DMA2D_Start_IT</strong>传输就好了。</p>
<h2 id="fmc">FMC</h2>
<p>FMC用于操作SDRAM，通过不断刷新SDRAM保证数据的正确性</p>
<hr>
<p>代码已上传<a href="https://github.com/greedyhao/stm32/tree/master/LCD" target="_blank" rel="noopener">github</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lcd-tft控制总结&quot;&gt;LCD-TFT控制总结&lt;/h1&gt;
&lt;p&gt;最近学到LCD了，但是在将野火的代码转移到CubeMX时却遇到了大麻烦，屏幕一直是花的，只有一次正常显示一下下，但是过一段时间就又没了，好几天的时间都找不到问题。&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="stm32" scheme="http://greedyhao.cc/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>几种常见窗函数的特性</title>
    <link href="http://greedyhao.cc/2018/07/24/%E5%B7%A5%E4%BD%9C-dsp-2018-07-24-%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AA%97%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <id>http://greedyhao.cc/2018/07/24/工作-dsp-2018-07-24-几种常见窗函数的特性/</id>
    <published>2018-07-24T14:55:45.000Z</published>
    <updated>2018-09-09T06:11:32.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几种常见窗函数的特性">几种常见窗函数的特性</h1>
<h2 id="解决一下上一篇的遗留问题">解决一下上一篇的遗留问题</h2>
<p>上一篇谈了FIR滤波器的加窗是什么，但是自觉得还是有些地方没有说明白，就好比模拟加窗过程都没有讲明白。</p>
<a id="more"></a>
<p>不过今天再看书时，又有所得，忽然明白了为什么模拟加窗过程出了问题，这是由于我之前对于数字滤波器的设计过程还很模糊。</p>
<p><strong>窗函数设计法的设计思路：</strong></p>
<ul>
<li>给定要求的理想频响<span class="math inline">\(H_d(e^{j\omega})\)</span>，一般为分段常数</li>
<li>转为时域设计，所以需要求出<span class="math inline">\(h_d(n)\)</span></li>
</ul>
<p><span class="math display">\[h_d(n) = IDTFT[H_d(e^{j\omega})]\]</span></p>
<ul>
<li>由于<span class="math inline">\(h_d(n)\)</span>是无限时长的，所以需要加窗截断为<span class="math inline">\(h(n)\)</span>，窗的长度为N</li>
</ul>
<blockquote>
<p>因为窗函数是在时域内截断，所以需要将理想滤波器转换到时域来处理。</p>
</blockquote>
<p><span class="math display">\[h(n) = h_d(n)\cdotp w(n), \quad 0\le n\le N-1\]</span></p>
<ul>
<li>求出加窗后的实际频响<span class="math inline">\(H(e^{j\omega})\)</span></li>
</ul>
<p><span class="math display">\[H(e^{j\omega}) = DTFT[h(n)]\]</span></p>
<ul>
<li>检查<span class="math inline">\(H(e^{j\omega})\)</span>是否满足<span class="math inline">\(H_d(e^{j\omega})\)</span>，不满足就重复3、4步骤</li>
</ul>
<p>我使用的<a href="http://greedyhao.cc/2018/07/23/%E5%B7%A5%E4%BD%9C-dsp-2018-07-23-FIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E5%8A%A0%E7%AA%97%E6%98%AF%E4%BB%80%E4%B9%88/">子程序</a>是书上提供的，可以产生一个理想滤波器。</p>
<p>今天突然对这个程序有了新的理解。因为这个是子程序产生的时域的滤波器，为了能够在电脑中存储，本来就已经加了一个矩形窗，因此它的频域波形存在波纹；而我又加一个矩形窗，对这个已经加了矩形窗的滤波器当然是一点效果都没有咯。</p>
<h2 id="几种常见窗函数">几种常见窗函数</h2>
<p>回到今天的主题，今天探讨一下几种常见滤波器的特性和使用场景。</p>
<p>翻了很多遍书，发现对于滤波器的设计，主要关心的是<strong>过渡带宽(Transition bandwidth)</strong>、<strong>通带边沿衰减(Passband ripple)</strong>、<strong>阻带最小衰减(Minimum stopband attenuation)</strong>，而且大部分的参数都是用dB作单位。</p>
<p>使用dB做单位的好处有：</p>
<ul>
<li>数值变小。由于分贝是取对数值，所以能很方便的表示大的数量的变化</li>
<li>运算方便。放大器级联时，总的放大倍数是各级相乘。用分贝做单位时，总增益就是相加。</li>
<li>方便感知。人对强度（光照、声音）的感知，接近于于强度的对数的正比。</li>
</ul>
<p>至于为什么要这么多种窗呢？那是因为不同的窗特性不一样，比如最简单的矩形窗，虽然完成了截断工作，但是通带衰减大、阻带衰减小，导致能量的浪费；而之后的多种窗则或多或少的弥补了这些缺点。</p>
<h3 id="矩形窗">矩形窗</h3>
<p>矩形窗的定义为</p>
<p><span class="math display">\[
w(n) = \begin{cases}
1, &amp; 0\le n \le M-1 \\\
0, &amp; otherwise
\end{cases}
\]</span></p>
<p>频率响应函数为</p>
<p><span class="math display">\[
W(e^{j\omega}) = W(\omega)e^{j\theta(\omega)} =
\frac{\sin(\omega M /2)}{\sin(\omega /2)}e^{-j\frac{N-1}{2}\omega}
\]</span></p>
<p>因此</p>
<p><span class="math display">\[
W(\omega) = \frac{\sin(\omega M /2)}{\sin(\omega /2)}
\]</span></p>
<p>下面分析窗函数的主要参数：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/rectwin_rp.bmp" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>幅度响应<span class="math inline">\(W_r(\omega)\)</span>第一个零点在<span class="math inline">\(\omega=\omega_1\)</span>，</li>
</ul>
<p><span class="math display">\[
\frac{\omega_1 M}{2} = \pi
~~
or
~~
\omega_1 = \frac{2\pi}{M}
\]</span></p>
<p>因此，主瓣宽度为为<span class="math inline">\(2\omega_1 = 4\pi /M\)</span>，因此传输带宽近似于<span class="math inline">\(4\pi /M\)</span></p>
<ul>
<li>第一个旁瓣大概在<span class="math inline">\(\omega=3\pi/M\)</span>的位置，因此它的幅值为</li>
</ul>
<p><span class="math display">\[
\left| W_r\left(\omega = \frac{3\pi}{M}\right)\right| = \left|\frac{\sin(3\pi /2)}{\sin(3\pi /2M)}\right| \simeq \frac{2M}{3\pi}
\]</span></p>
<p>对比主瓣的幅值，旁瓣幅值峰值为</p>
<p><span class="math display">\[
\frac{2}{3\pi} \approx 21.22\% \equiv 13 dB
\]</span></p>
<h3 id="三角形窗">三角形窗</h3>
<p>由于吉布斯现象，矩形窗存在一个0到1的越变；而三角形窗则提供了一个比较缓慢的变化，它的定义式为：</p>
<p><span class="math display">\[
w(n) =
\begin{cases}
\frac{2n}{M-1}, &amp; 0\le n \le\frac{M-1}{2} \\\
2-\frac{2n}{M-1}, &amp; \frac{M-1}{2}\le n\le M-1 \\\
0, &amp; otherwise
\end{cases}
\]</span></p>
<p>谱密度函数表达式如下，’≈’仅当<span class="math inline">\(M\gg 1\)</span>时成立</p>
<p><span class="math display">\[
W(\omega) \approx \frac{2}{M} \frac{\sin(M\omega/4)}{\sin(\omega/4)}
\]</span></p>
<p>主瓣宽度为<span class="math inline">\(8\pi /M\)</span>，旁瓣峰值衰减为25dB</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/triang_rp.bmp" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="汉宁窗hanning">汉宁窗（Hanning）</h3>
<p>这是一个升余弦窗，被定义为</p>
<p><span class="math display">\[
w(n) =
\begin{cases}
0.5\left[1-\cos\left(\frac{2\pi n}{M-1}\right)\right] &amp; 0\le n \le M-1 \\\
0 &amp; otherwise
\end{cases}
\]</span></p>
<p>主瓣宽度为<span class="math inline">\(8\pi /M\)</span>，旁瓣峰值衰减为31dB</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/hann_rp.bmp" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="海明窗hamming">海明窗（Hamming）</h3>
<p>海明窗和汉宁窗很像，不同的是它有一部分是不连续的，被定义为</p>
<p><span class="math display">\[
w(n)=
\begin{cases}
0.54 - 0.46\cos\left(\frac{2\pi n}{M-1}\right) &amp; 0\le n \le M-1 \\\
0 &amp; otherwise
\end{cases}
\]</span></p>
<p>主瓣宽度为<span class="math inline">\(8\pi /M\)</span>，旁瓣峰值衰减为41d</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/hamm_rp.bmp" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="布莱克曼窗blackman">布莱克曼窗（Blackman）</h3>
<p>这个窗函数和前两个窗函数很像，不过增加了升余弦的二次谐波分量，被定义为</p>
<p><span class="math display">\[
w(n) =
\begin{cases}
0.42 - 0.5\cos\left(\frac{2\pi n}{M-1}\right) + 0.08\cos\left(\frac{4\pi n}{M-1}\right) &amp; 0\le n \le M-1 \\\
0 &amp; otherwise
\end{cases}
\]</span></p>
<p>主瓣宽度为<span class="math inline">\(12\pi /M\)</span>，旁瓣峰值衰减为57dB</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/black_rp.bmp" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="凯泽窗kaiser">凯泽窗（Kaiser）</h3>
<p>这是一个非常有用的窗函数，它可以同时调整主瓣宽度与旁瓣宽度，这是其他窗函数不具备的，被定义为</p>
<p><span class="math display">\[
w(n) =
\frac{I_0\left[\beta \sqrt{1-\left(1-\frac{2n}{M-1}\right)^2}\right]}{I_0[\beta]}
\]</span></p>
<p><span class="math inline">\(I_0\)</span>是第一类零阶贝塞尔函数，<span class="math inline">\(\beta\)</span>是用来调整窗函数性能的参数</p>
<p>本人使用的<span class="math inline">\(\beta = 8.5\)</span></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/kaiser_rp.bmp" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="如何选择窗函数">如何选择窗函数</h2>
<p>选择窗函数可以参考前文中的窗函数设计法</p>
<p>先确定自己的需求，然后根据窗函数的极限性能，做出选择，最后再验证这个窗函数是否符合需求</p>
<hr>
<p>本文中的代码已上传<a href="https://github.com/greedyhao/DSP/tree/master/windowing" target="_blank" rel="noopener">本人的github</a></p>
<hr>
<p>参考书籍：</p>
<ul>
<li>_DigitalSignalProcessingUsingMatlabv4.0_JohnG.Proakis</li>
<li>《数字信号处理教程》程佩青</li>
</ul>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;几种常见窗函数的特性&quot;&gt;几种常见窗函数的特性&lt;/h1&gt;
&lt;h2 id=&quot;解决一下上一篇的遗留问题&quot;&gt;解决一下上一篇的遗留问题&lt;/h2&gt;
&lt;p&gt;上一篇谈了FIR滤波器的加窗是什么，但是自觉得还是有些地方没有说明白，就好比模拟加窗过程都没有讲明白。&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="dsp" scheme="http://greedyhao.cc/tags/dsp/"/>
    
  </entry>
  
  <entry>
    <title>FIR滤波器的加窗是什么</title>
    <link href="http://greedyhao.cc/2018/07/23/%E5%B7%A5%E4%BD%9C-dsp-2018-07-23-FIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E5%8A%A0%E7%AA%97%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://greedyhao.cc/2018/07/23/工作-dsp-2018-07-23-FIR滤波器的加窗是什么/</id>
    <published>2018-07-23T06:09:58.000Z</published>
    <updated>2018-09-09T06:22:27.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fir滤波器的加窗是什么">FIR滤波器的加窗是什么</h1>
<p>窗函数法是一种设计FIR滤波器的方法，FIR全称为Finite impulse response，即有限冲激响应滤波器。</p>
<a id="more"></a>
<p>通带为<span class="math inline">\(\omega_c\lt\pi\)</span>的理想低通滤波器的系统函数为</p>
<p><span class="math display">\[
H_d(e^{j\omega})=\begin{cases}
1\cdotp e^{j\alpha\omega} &amp; |\omega|\le\omega_e \
0 &amp; \omega_e\lt\pi
\end{cases}
\]</span></p>
<p>反变换求它的冲激响应为</p>
<p><span class="math display">\[
\begin {aligned}
h_d(n) 
&amp; = \mathcal{F}^{-1}\bigl[H_d(e^{j\omega})\bigr] = \frac{1}{2\pi} \int_{-\pi}^\pi H_d(e^{j\omega})e^{j\omega n}d\omega \\\
&amp; = \frac{1}{2\pi} \int_{-\omega_e}^{\omega_e} 1\cdot e^{-j\alpha\omega} e^{j\omega n}d\omega \\\
&amp; = \frac{\sin\left[\omega_e(n-\alpha)\right]}{\pi(n-\alpha)}
\end {aligned}
\]</span></p>
<p>可以看出，这是一个sinc函数</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/89/Sinc_function_%28both%29.svg/1280px-Sinc_function_%28both%29.svg.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>可以看出，<span class="math inline">\(h_d(n)\)</span>的冲激响应在时域上是无限长的，不符合FIR滤波器的要求，所以需要对它截断，也就是加窗。</p>
<p>为了得到一个长度为M的因果的线性相位的FIR滤波器<span class="math inline">\(h(n)\)</span>，我们需要</p>
<p><span class="math display">\[
h(n)=\begin{cases}
h_d(n) &amp; 0\le n\le M-1 \\\
0 &amp; elsewhere
\end{cases}
~~
and
~~
\alpha = \frac{M-1}{2}
\]</span></p>
<p>也就是让<span class="math inline">\(h_d(n)\)</span>的<span class="math inline">\(0\le n\le M-1\)</span>之外的值全为0，这就是加窗。这个过程可以表示为</p>
<p><span class="math display">\[
h(n) = h_d(n)w(n)
\]</span></p>
<p><span class="math inline">\(w(n)\)</span>即为窗函数</p>
<p><span class="math display">\[
w(n) =
\begin{cases}
some\ symmetric\ function\ with\ respect\ to \\\
\alpha\ over\ 0\le n\le M-1 \\\
0,\ otherwise
\end{cases}
\]</span></p>
<p>在这里我们将<span class="math inline">\(w(n)\)</span>定义为</p>
<p><span class="math display">\[
w(n) =
\begin{cases}
1 &amp; 0\le n\le M-1 \\
0 &amp; otherwise
\end{cases}
\]</span></p>
<p>再看看频域，使用<span class="math inline">\(H(e^{j\omega})\)</span>表示因果FIR滤波器的响应，<span class="math inline">\(H_d(e^{j\omega})\)</span>表示理想滤波器，<span class="math inline">\(W(e^{j\omega})\)</span>表示窗函数响应。</p>
<p>时域相乘，频域卷积，这里是圆周卷积。(圆周卷积以后也会介绍)</p>
<p><span class="math display">\[
\begin {aligned}
H(e^{j\omega}) &amp; = H_d(e^{j\omega})\bigodot W(e^{j\omega}) \\
&amp; = \frac{1}{2\pi}\int_{-\pi}^\pi W(e^{j\omega})H(e^{j(\omega - \lambda)})
\end {aligned} 
\]</span></p>
<p>我想在MATLAB中模拟这个加窗的过程，但是一直弄不出来，就把书上的图拿过来吧。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/windowing_operation.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>我不知道为什么我卷积出来的频域波形和窗函数的频域波形是一样的，很尴尬。</p>
<p>不过窗函数的原理基本还是理解了，直接生成书上卷积出来的频域波形不难，在matlab中直接生成一个FIR滤波器（相当于加了矩形窗），然后求它的频响。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/rect_fr.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alpha = (M-1)/2;</span><br><span class="line">n = [0:1:(M-1)];</span><br><span class="line">m = n - alpha + eps;        % add smallest number to avoid divide by zero</span><br><span class="line">hd = sin(wc*m) ./ (pi*m);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wc = 0.2*pi;</span><br><span class="line">M = 60;</span><br><span class="line">hd = ideal_lp(wc,M);</span><br><span class="line">w_rect = (rectwin(M))&amp;#39;;</span><br><span class="line">h = hd .* w_rect;</span><br><span class="line">fvtool(h);</span><br></pre></td></tr></table></figure>
<hr>
<p>参考书籍：</p>
<ul>
<li>_DigitalSignalProcessingUsingMatlabv4.0_JohnG.Proakis</li>
<li>《数字信号处理教程》程佩青</li>
</ul>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;fir滤波器的加窗是什么&quot;&gt;FIR滤波器的加窗是什么&lt;/h1&gt;
&lt;p&gt;窗函数法是一种设计FIR滤波器的方法，FIR全称为Finite impulse response，即有限冲激响应滤波器。&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="dsp" scheme="http://greedyhao.cc/tags/dsp/"/>
    
  </entry>
  
  <entry>
    <title>说说我最近做了什么</title>
    <link href="http://greedyhao.cc/2018/07/21/%E7%94%9F%E6%B4%BB-small-talk-2018-07-21-%E8%AF%B4%E8%AF%B4%E6%88%91%E6%9C%80%E8%BF%91%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://greedyhao.cc/2018/07/21/生活-small-talk-2018-07-21-说说我最近做了什么/</id>
    <published>2018-07-21T01:46:17.000Z</published>
    <updated>2018-09-09T04:56:41.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说说我最近做了什么">说说我最近做了什么</h1>
<p>每天早上学习半个小时到一个小时的时间英语，买了两本书《恋练有词》和《恋练不忘》两本书，配套朱伟老师的视频学习。不得不说，这个课程挺不错的，朱伟老师人很幽默，思路清晰，讲的知识点很到位，值得推荐。</p>
<p>此外就是对数字信号处理的学习了，暂时计划是通过在中国大学MOOC上看视频，先快速过一遍，然后使用MATLAB配合书本进一步深入学习，最后如果能通过学习到的相关知识自己做一个示波器就更好了。</p>
<p>时域-&gt;z域</p>
<p>z变换 z逆变换</p>
<p>DTFT DFS DFT</p>
<p>FFT的方法</p>
<p>数字滤波器的设计</p>
<p>IIR的设计方法</p>
<p>FIR的设计方法 窗函数</p>
<p>目前已经完成第一阶段的目标（定力有点不好，拖了几天才看完），稍微了解了一点数字信号处理的知识。</p>
<p>个人觉得数字信号处理的应用在于设计各种数字滤波器，而各种变换域的方法就是数字信号处理的分析，数字信号处理离不开分析与应用。</p>
<p>数字滤波器的设计要一开始就要明确设计的目的，设计好通频、损耗等等</p>
<p>分析上主要就是s域与z域同时间域之间的转换了，然后用FFT加速变换</p>
<p>不过我觉得我第一阶段做的不够好，首先是有点拖，浪费了很多时间；其次就是没有把问题记录下来，这个问题很致命。在看视频的时候，经常会冒出来一些问题，比如说窗函数各自的作用是什么、巴特沃斯等逼近是什么原理等等，很多问题当时突然就冒出来，但是没有记录就忘了，要是能把问题记录下来，之后带着问题再看书，效果应该会好很多。</p>
<p>在知乎上看到的，数字信号处理推荐的书籍，在公众号的菜单中有下载链接</p>
<ul>
<li>DigitalSignalProcessing(4thEdition)4thEditionbyJohnG.Proakis(Author)</li>
<li>Oppenheim:DiscretSignalProcessingbyAlanV.Oppenheim</li>
<li>数字信号处理教程程佩青</li>
</ul>
<hr>
<div class="figure">
<img src="/img/wechat_official_accounts.jpg">

</div>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说说我最近做了什么&quot;&gt;说说我最近做了什么&lt;/h1&gt;
&lt;p&gt;每天早上学习半个小时到一个小时的时间英语，买了两本书《恋练有词》和《恋练不忘》两本书，配套朱伟老师的视频学习。不得不说，这个课程挺不错的，朱伟老师人很幽默，思路清晰，讲的知识点很到位，值得推荐。&lt;/p&gt;
&lt;
    
    </summary>
    
    
      <category term="small-talk" scheme="http://greedyhao.cc/tags/small-talk/"/>
    
  </entry>
  
  <entry>
    <title>焊接总结</title>
    <link href="http://greedyhao.cc/2018/07/18/Hardware-2018-07-18-%E7%84%8A%E6%8E%A5%E6%80%BB%E7%BB%93/"/>
    <id>http://greedyhao.cc/2018/07/18/Hardware-2018-07-18-焊接总结/</id>
    <published>2018-07-18T06:12:43.000Z</published>
    <updated>2018-09-09T04:54:00.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="焊接总结">焊接总结</h1>
<p>前段时间去做实习。</p>
<p>新来的嘛，自然不会给什么重要的事情做，就叫焊板；不过也好，很久没有动烙铁了，正好，可以再熟悉一下。</p>
<h1 id="焊接一般的贴片封装">焊接一般的贴片封装</h1>
<h2 id="焊接步骤">焊接步骤：</h2>
<ul>
<li>先在一边焊盘上锡</li>
<li>用镊子夹取需要焊接的元件并放置到焊盘</li>
<li>先在有锡的焊盘上固定元件的一头</li>
<li>再给元件的另一头上锡固定</li>
</ul>
<h2 id="经验总结">经验总结</h2>
<p>我一开始就是以这个步骤焊接的，不过在焊接完之后，以水平角度看板子上的元件发现，有虚焊的情况。</p>
<p>而且虚焊的情况主要是发生在后上锡的一头，这主要应该是和我用烙铁头给元件另一头上锡的动作有问题有关。</p>
<p>因此我改变了上锡的动作。原先焊插接件总是在焊完后习惯的把烙铁头顺着引脚，往上提。</p>
<p>不过我发现这个动作在焊贴片的时候不太好，会导致锡沾不上焊盘；所以我将自己之前忘上提的动作改为了往下压的动作。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/hardware/soldering_general_smd.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>另外就是，为了确保一开始焊的那头不会虚焊，可以在焊完后拔一拔，试试焊实了没有。虚焊的元件一拔就掉了。</p>
<h1 id="焊接qfp等管脚比较多的元件">焊接QFP等管脚比较多的元件</h1>
<h2 id="焊接步骤-1">焊接步骤</h2>
<ul>
<li>先在焊盘上上点锡固定元件</li>
<li>堆锡</li>
<li>刮锡</li>
</ul>
<h2 id="经验总结-1">经验总结</h2>
<p>要这么做，一个好的烙铁头很重要！那种不沾锡的烙铁头就算了吧，会怀疑人生的。</p>
<p>焊完后检查一下管脚是否有短路，有时候没注意就有那么两三个管脚还是短路在一起的。</p>
<p>如果有锡刮不下来就上点助锡膏吧，没有这个东西搞不定的元件。</p>
<p>上一些焊接的图吧</p>
<p><img src="/img/hardware/soldering_1.png" alt="固定元件"><img src="/img/hardware/soldering_2.png" alt="堆锡"></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/hardware/soldering_qfp.gif" alt="刮锡" title="">
                </div>
                <div class="image-caption">刮锡</div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;焊接总结&quot;&gt;焊接总结&lt;/h1&gt;
&lt;p&gt;前段时间去做实习。&lt;/p&gt;
&lt;p&gt;新来的嘛，自然不会给什么重要的事情做，就叫焊板；不过也好，很久没有动烙铁了，正好，可以再熟悉一下。&lt;/p&gt;
&lt;h1 id=&quot;焊接一般的贴片封装&quot;&gt;焊接一般的贴片封装&lt;/h1&gt;
&lt;h2 id=&quot;
    
    </summary>
    
      <category term="Hardware" scheme="http://greedyhao.cc/categories/Hardware/"/>
    
    
  </entry>
  
  <entry>
    <title>解释为什么旋转的物体有时看着像在倒转</title>
    <link href="http://greedyhao.cc/2018/07/09/%E5%B7%A5%E4%BD%9C-dsp-2018-07-09-%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%8B%E8%BD%AC%E7%9A%84%E7%89%A9%E4%BD%93%E6%9C%89%E6%97%B6%E7%9C%8B%E7%9D%80%E5%83%8F%E5%9C%A8%E5%80%92%E8%BD%AC/"/>
    <id>http://greedyhao.cc/2018/07/09/工作-dsp-2018-07-09-解释为什么旋转的物体有时看着像在倒转/</id>
    <published>2018-07-09T02:11:54.000Z</published>
    <updated>2018-09-09T04:50:26.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解释为什么旋转的物体有时看着像在倒转">解释为什么旋转的物体有时看着像在倒转</h1>
<blockquote>
<p>动态图的原视频可以点击阅读原文观看，是十个不错的Arduino项目</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/欠采样.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h1 id="描述现象">描述现象</h1>
<p>相信大家都有过这么的经历，旋转的物体，有时候看着觉得在倒转。</p>
<p>比如汽车的车轮，从静止开始发动汽车，这个过程中，汽车的车轮看起来就是从正转到反转或停止，当汽车减速的时候，汽车车轮看起来就又恢复成正转了。</p>
<p>学过信号与系统的或许知道奈奎斯特采样定律————最小采样频率是信号频率的两倍。</p>
<p>我在一开始也是不理解的，为什么刚刚好就要两倍，感觉很随意一样，别人家的黄金分割比都是小数0.618，听起来也酷，为什么香农家的是整数。</p>
<p>虽然我也知道以低于两倍信号频率采样的时候，会欠采样，丢失信号信息，但是具体怎么个丢失法，也是不了解的，直到我开始学习数字信号处理（DSP），才总算是晓得了这么个东西。</p>
<h1 id="解释原理">解释原理</h1>
<blockquote>
<p>以下材料来自中国大学MOOC <a href="https://www.icourse163.org/learn/UESTC-236010?tid=1002753005#/learn/announce" class="uri" target="_blank" rel="noopener">https://www.icourse163.org/learn/UESTC-236010?tid=1002753005#/learn/announce</a></p>
</blockquote>
<p>有点懒得自己用Matlab画图（其实是自己学的不够好），就使用我在网上学习的课程中使用的图来解释吧。</p>
<p>图中是使用Fs=10Hz的信号对3Hz、7Hz、13Hz的信号采样的结果</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/欠采样_1.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>采样间隔为0.1s，采样得到的序列为g1[n]=cos(0.6πn) g2[n]=cos(1.4πn) g1[n]=cos(2.6πn)，从图中的采样点可以看出，采样点为三个信号的交点，所以采样得到的信号都是一样的，这种现象就是<strong>欠采样的效果：混叠现象</strong></p>
<p>从频域上进行分析</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/dsp/欠采样_2.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>使用10Hz的信号采样的效果相当于，将一个信号在频谱上分别向左和右搬移了20π。对于7Hz的信号来说，14π-20π=-6π，-14π+20π=6π，而3Hz的信号的频谱也在-6π和6π，所以无法分别到底是3Hz的信号还是7Hz的信号。如果将采样结果还原，得到的也只有3Hz的信号。同理可得13Hz信号的结果。</p>
<h1 id="解释现象">解释现象</h1>
<p>一般来说，人眼能感受到的闪烁频率最高到60Hz，汽车车轮直径大概在737.6mm。也就是说，汽车车轮转动的频率超过30Hz，人眼就会出现“幻觉”了。</p>
<p>根据路程-速度-时间的关系，可以知道这个出现“幻觉”的速度为：v=30_737.6_10^(-3)=22.128(m/s)=79.6608(km/s)</p>
<p>所以说，一旦汽车的速度到了差不多80km/h的速度后，在人眼看来，车轮就有倒转的现象。</p>
<h1 id="再现混叠现象">再现混叠现象</h1>
<p>如果没条件把汽车架起来测试这个效果，可以选择平民化的测试方法。</p>
<p>手机摄像头的采集视频的刷新速度比人眼低很多，可以用手机摄像头对着电风扇拍视频，可以明显的看见电风扇也出现了“倒转”现象。</p>
<h1 id="解决方法">解决方法</h1>
<p>在数字信号处理这个领域，为了解决这个问题，一般会在采样的前级加上一个抗混叠滤波器，通带为±二分之一的采样率，避免无法完全采样的频率“混叠”频谱。</p>
<div class="figure">
<img src="/img/dsp/flow_for_dsp.png">

</div>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;解释为什么旋转的物体有时看着像在倒转&quot;&gt;解释为什么旋转的物体有时看着像在倒转&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;动态图的原视频可以点击阅读原文观看，是十个不错的Arduino项目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="dsp" scheme="http://greedyhao.cc/tags/dsp/"/>
    
  </entry>
  
</feed>
