<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhuhao&#39;s Blog</title>
  
  <subtitle>I am the captain of my ship and the master of my fate.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://greedyhao.cc/"/>
  <updated>2018-11-24T14:08:21.247Z</updated>
  <id>http://greedyhao.cc/</id>
  
  <author>
    <name>Greedyhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>另一种模拟傅里叶变换的方式</title>
    <link href="http://greedyhao.cc/2018/11/24/%E5%B7%A5%E4%BD%9C-dsp-2018-11-24-%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://greedyhao.cc/2018/11/24/工作-dsp-2018-11-24-另一种模拟傅里叶变换的方式/</id>
    <published>2018-11-24T14:02:50.000Z</published>
    <updated>2018-11-24T14:08:21.247Z</updated>
    
    <content type="html"><![CDATA[<p>这是好久之前写的，忘记发了，另一种模拟傅里叶变换的方式。相关阅读：<a href="http://greedyhao.cc/2018/10/21/%E5%B7%A5%E4%BD%9C-dsp-2018-10-21-Matlab%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/">Matlab模拟傅里叶变换</a></p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="http://greedyhao.cc/2018/10/21/%E5%B7%A5%E4%BD%9C-dsp-2018-10-21-Matlab%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/">前文</a>进行了傅里叶变换的分析，以及在Matlab上模拟傅里叶变换，但是使用的是矩阵向乘法，这里提供另外一种模拟的方法。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>我就是在<a href="https://www.csun.edu/~skatz/ece460/matlab_tut_two.pdf" target="_blank" rel="noopener">Evaluating Fourier Transforms with MATLAB</a>这篇文章中找到答案的。</p><p>我发现在这篇文章中，使用了一个Matlab built-in function—trapz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">help</span> trapz</span><br><span class="line"> trapz  Trapezoidal numerical integration.</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>简单来说，这个函数的作用是做积分，之前没有使用这个函数的时候，使用的就是求和的方法，也不知道之前的方法对复指数信号不适合的原因是不是求和导致了信息丢失。</p><p>下面进入主题</p><h1 id="分析与实现"><a href="#分析与实现" class="headerlink" title="分析与实现"></a>分析与实现</h1><p>首先还是看到傅里叶变换上来</p><p>$$<br>X_a(j\Omega)=\int x_a(t)e^{-j\Omega t}dt<br>$$</p><p>思路很清晰，就是对$x_a(t)e^{-j2\pi ft}$积分而已</p><p>我们需要使用到的trapz的更详细的描述如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q = trapz(X,Y) 根据 X 指定的坐标或标量间距对 Y 进行积分。</span><br><span class="line">如果 X 是坐标向量，则 length(X) 必须等于 Y 的大小不等于 1 的第一个维度的大小。</span><br><span class="line">如果 X 是标量间距，则 trapz(X,Y) 等于 X*trapz(Y)。</span><br></pre></td></tr></table></figure><p>根据文档，使用trapz(X,Y)时，让X为t，Y为积分部分就行</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trapz(t,x.*<span class="built_in">exp</span>(-<span class="built_in">j</span>*<span class="number">2</span>*<span class="built_in">pi</span>*f*t))</span><br></pre></td></tr></table></figure><h2 id="一个简单的trapz例子"><a href="#一个简单的trapz例子" class="headerlink" title="一个简单的trapz例子"></a>一个简单的trapz例子</h2><p>接下来就使用trapz来做一个简单的函数的变换</p><p>$$<br>X(jf)=\int^2_2 1e^{-j2\pi f} dt<br>$$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">t=<span class="number">-2</span>:<span class="number">.01</span>:<span class="number">2</span>;</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> f=<span class="number">-5</span>:<span class="number">.01</span>:<span class="number">5</span></span><br><span class="line">    k=k+<span class="number">1</span>;</span><br><span class="line">    X(k)=trapz(t,<span class="built_in">exp</span>(-<span class="built_in">j</span>*<span class="number">2</span>*<span class="built_in">pi</span>*f*t));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f=<span class="number">-5</span>:<span class="number">.01</span>:<span class="number">5</span>;</span><br><span class="line"><span class="built_in">plot</span>(f,X)</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/ctft_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这是对一个非周期脉宽信号的变换，得到的结果是我们很熟悉的sinc信号，而且结果是符合理论的。</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是好久之前写的，忘记发了，另一种模拟傅里叶变换的方式。相关阅读：&lt;a href=&quot;http://greedyhao.cc/2018/10/21/%E5%B7%A5%E4%BD%9C-dsp-2018-10-21-Matlab%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/&quot;&gt;Matlab模拟傅里叶变换&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="DSP" scheme="http://greedyhao.cc/tags/DSP/"/>
    
      <category term="Matlab" scheme="http://greedyhao.cc/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>18年11月总结</title>
    <link href="http://greedyhao.cc/2018/11/24/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2018-11-24-18%E5%B9%B411%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>http://greedyhao.cc/2018/11/24/学习总结-2018-11-24-18年11月总结/</id>
    <published>2018-11-24T14:02:13.000Z</published>
    <updated>2018-11-24T14:03:37.378Z</updated>
    
    <content type="html"><![CDATA[<p>最近有点飘，尝试了一下小说，没想到会难以自拔，准备重新改变看小说这个习惯中。</p><p>表面上小说好像带来了一些冷门的知识，但事实上浪费的时间比想象中的多，搞到我连博客都不想写了，所以还是得改。</p><p>下面进入主题，介绍一下最近接触的东西。</p><h1 id="RT-Thread"><a href="#RT-Thread" class="headerlink" title="RT-Thread"></a>RT-Thread</h1><p>之前报名参加了rtt的大学生培训活动，目前已经进行到了内核移植阶段。</p><p>培训内容是从熟悉内核开始的，先后学习了线程的创建启动、各种线程间通信同步的方式。我看了看野火的rtt的书，从目录来看，两者的教程很相似，由于对两者的接触很浅，所以具体的异同还要细看后才好说。</p><p>就我目前见识到的，各种操作系统的基本功能都差不多，都有对线程的操作、线程间通信、内存管理等功能，不过具体实现各有特点。</p><h1 id="DSP"><a href="#DSP" class="headerlink" title="DSP"></a>DSP</h1><p>幅值、相位、实部、虚部是不一样的，可惜我学了很久直到不就前才注意到，之前在画频谱时，只知道要用abs取绝对值，但不知道为什么；不过后来慢慢知道频域中一般研究的是幅值和相位，实部和虚部的研究在时域中出现的比较多。</p><h1 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h1><p>通信原理是我目前最头疼的一门学科了，这个月感觉根本没有学到什么…不过这也主要和我这个月态度太差了有关，既然之前没有学好，只能现在开始补了</p><h1 id="对下个月的打算"><a href="#对下个月的打算" class="headerlink" title="对下个月的打算"></a>对下个月的打算</h1><p>首先是会尽快将这周的rtt培训任务完成，任务需要将rtt内核移植到自己的开发板上，我准备先使用rtt nano版的移植，再做env的移植。目前还没有对rtt在linux上的编译链接了解太多，准备到时候使用Truestudio开发吧。</p><p>然后自然就是学习数字信号处理和通信原理了，毕竟专业学科不能落下，这两门学科学起来还是不容易。</p><p>接下来我会改变目前的状态，只要有点所得就写下发出来，就当是给自己动力把。</p><h1 id="专业词汇"><a href="#专业词汇" class="headerlink" title="专业词汇"></a>专业词汇</h1><ul><li>Finite-duration impulse response (FIR) </li><li>Infinite-duration impulse response (FIR) </li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有点飘，尝试了一下小说，没想到会难以自拔，准备重新改变看小说这个习惯中。&lt;/p&gt;
&lt;p&gt;表面上小说好像带来了一些冷门的知识，但事实上浪费的时间比想象中的多，搞到我连博客都不想写了，所以还是得改。&lt;/p&gt;
&lt;p&gt;下面进入主题，介绍一下最近接触的东西。&lt;/p&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="总结" scheme="http://greedyhao.cc/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Matlab模拟傅里叶变换</title>
    <link href="http://greedyhao.cc/2018/10/21/%E5%B7%A5%E4%BD%9C-dsp-2018-10-21-Matlab%E6%A8%A1%E6%8B%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <id>http://greedyhao.cc/2018/10/21/工作-dsp-2018-10-21-Matlab模拟傅里叶变换/</id>
    <published>2018-10-21T07:45:09.000Z</published>
    <updated>2018-11-22T07:55:11.631Z</updated>
    
    <content type="html"><![CDATA[<p>傅里叶变换是我们最早开始接触的时频域变换方法，虽然经常使用，知道怎么用纸笔计算，但是还从来没有在电脑中模拟过，正好现在开始学习数字信号处理，借着这个机会再学习如何在电脑上模拟傅里叶变换。</p><a id="more"></a><blockquote><p>以下大部分内容来自<em>Digital Signal Processing Using Matlab</em>和<em>数字信号处理教程 程佩青</em></p></blockquote><p>此次选择的软件平台为Matlab。</p><p>由于Matlab无法处理无限长序列，所以需要处理的信号必须是有限长的。</p><h1 id="连续时间傅里叶变换"><a href="#连续时间傅里叶变换" class="headerlink" title="连续时间傅里叶变换"></a>连续时间傅里叶变换</h1><p>傅里叶变换的公式为：</p><p>$$<br>X_a(j\Omega)=\int x_a(t)e^{-j\Omega t}dt<br>$$</p><p>为了在计算机中模拟傅里叶变换，我们将积分变为求和的方式，上下限也从正无穷到负无穷变为一段长度M，dt需要尽可能小</p><p>$$<br>X_a(j\Omega) = \sum_m x_a(m\Delta t)e^{-j\Omega m\Delta t}\Delta t<br>$$</p><p>在Matlab中，函数的自变量因变量的集合都是使用矩阵来存储的，从矩阵的角度来看傅里叶变换的公式如下：</p><p>$$<br>[X_a(0)\ X_a(1)\ X_a(2)\ ..] = [x_a(0)\ x_a(1)\ x_a(2)\ ..]<br>\left[<br>\begin{matrix}<br> e^{-j\omega_0 t_0} &amp; e^{-j\omega_1 t_0} &amp; \cdots &amp; e^{-j\omega_K t_0}      \<br> e^{-j\omega_0 t_1} &amp; e^{-j\omega_1 t_1} &amp; \cdots &amp; e^{-j\omega_K t_1}      \<br> \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br> e^{-j\omega_0 t_N} &amp; e^{-j\omega_1 t_N} &amp; \cdots &amp; e^{-j\omega_K t_N}      \<br>\end{matrix}<br>\right]<br>$$</p><p>角频率向量定义为$\omega=[\omega_0\ \omega_1\ …\ \omega_K]$</p><p>时间向量定义为$t=[t_0 :\Delta t: t_N]$</p><p>因此矩阵指数可写为$-j<em>t’</em>\omega$</p><p>整个傅里叶变换可写为<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xa = xa * <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">j</span>*t'*W) * Dt;</span><br></pre></td></tr></table></figure></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>其实下面这个例子是<em>Digital Signal Processing Using Matlab</em>中的，来自P64页，不过想到都看到这里了还要读者翻书不太好，就一起放上来了。</p><p>定义$x_a(t) = e^{-1000|t|}$</p><p>先进行数学上的分析，</p><p>$$<br>\begin {aligned}<br>X_a(j \Omega) &amp;= \int^\infty_{-\infty}x_a(t)e^{-j\Omega t}dt \<br>&amp;= \int^0_{-\infty}e^{1000t}e^{-j\Omega t}dt + \int^\infty_0 e^{-1000t}e^{-j\Omega t}dt \<br>&amp;= \frac{0.002}{1+(\frac{\Omega}{1000})^2}<br>\end {aligned}<br>$$</p><p>MATLAB实现如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Analog Signal</span></span><br><span class="line">Dt = <span class="number">0.00005</span>;</span><br><span class="line">t = <span class="number">-0.005</span>:Dt:<span class="number">0.005</span>;</span><br><span class="line">xa = <span class="built_in">exp</span>(<span class="number">-1000</span>*<span class="built_in">abs</span>(t));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Continuous-time Fourier Transform</span></span><br><span class="line">Wmax = <span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">2000</span>;</span><br><span class="line">K = <span class="number">500</span>;</span><br><span class="line">k = <span class="number">0</span>:<span class="number">1</span>:K;</span><br><span class="line">W = k*Wmax/K;</span><br><span class="line"></span><br><span class="line">Xa = xa * <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">j</span>*t'*W) * Dt;</span><br><span class="line">Xa = <span class="built_in">abs</span>(Xa);</span><br><span class="line"></span><br><span class="line">W = [-<span class="built_in">fliplr</span>(W), W(<span class="number">2</span>:<span class="number">501</span>)];</span><br><span class="line">Xa = [<span class="built_in">fliplr</span>(Xa), Xa(<span class="number">2</span>:<span class="number">501</span>)];</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>); </span><br><span class="line"><span class="built_in">plot</span>(t*<span class="number">1000</span>,xa);</span><br><span class="line">xlabel(<span class="string">'t in msec.'</span>); </span><br><span class="line">ylabel(<span class="string">'xa(t)'</span>);</span><br><span class="line">title(<span class="string">'Analog Signal'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>); </span><br><span class="line"><span class="built_in">plot</span>(W/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">1000</span>),Xa*<span class="number">1000</span>);</span><br><span class="line">xlabel(<span class="string">'Frequency in KHz'</span>); ylabel(<span class="string">'Xa(jW)*1000'</span>);</span><br><span class="line">title(<span class="string">'Continuous-time Fourier Transform'</span>);</span><br></pre></td></tr></table></figure><p>运行效果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/ctft_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果想确认变换的正确性，可以在运行完上面这个脚本后，在命令行输入</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(W/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">1000</span>),(<span class="number">0.002</span>./(<span class="number">1</span>+(W./<span class="number">1000</span>).^<span class="number">2</span>))*<span class="number">1000</span>);</span><br><span class="line">xlabel(<span class="string">'Frequency in KHz'</span>); ylabel(<span class="string">'Xa(jW)*1000'</span>);</span><br></pre></td></tr></table></figure><p>运行效果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/source/dsp/ctft_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这时会发现，根据上面推导的变换公式直接plot出的图形和变换后得到的图形是一样的，这样可以确定变换的正确性。</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>目前存在的问题是，对于复函数的变换结果不正确。我想了很多天都找不出问题所在，只能暂时放弃，等以后有机会再研究。</p><h1 id="离散时间傅里叶变换"><a href="#离散时间傅里叶变换" class="headerlink" title="离散时间傅里叶变换"></a>离散时间傅里叶变换</h1><p>下面是对上一个例子中的模拟输入信号做离散化，然后再进行离散傅里叶变换。</p><p>为了体现Nyquist定理，将使用两种不同的采样频率</p><ol><li>使用Fs=5000sam/sec采样来获得x1(n)</li><li>使用Fs=1000sam/sec采样来获得x2(n)</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Analog Signal</span></span><br><span class="line">Dt = <span class="number">0.00005</span>;</span><br><span class="line">t = <span class="number">-0.005</span>:Dt:<span class="number">0.005</span>;</span><br><span class="line">xa = <span class="built_in">exp</span>(<span class="number">-1000</span>*<span class="built_in">abs</span>(t));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Discrete-time Signal </span></span><br><span class="line">Ts = <span class="number">0.0002</span>;</span><br><span class="line">n = <span class="number">-25</span>:<span class="number">1</span>:<span class="number">25</span>;</span><br><span class="line">x = <span class="built_in">exp</span>(<span class="number">-1000</span>*<span class="built_in">abs</span>(n*Ts));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Discrete-time Fourier transform</span></span><br><span class="line">K = <span class="number">500</span>;</span><br><span class="line">k = <span class="number">0</span>:<span class="number">1</span>:K;</span><br><span class="line">w = <span class="built_in">pi</span>*k/K;</span><br><span class="line"></span><br><span class="line">X = x*<span class="built_in">exp</span>(-<span class="built_in">j</span>*n'*w); X = <span class="built_in">real</span>(X);</span><br><span class="line"></span><br><span class="line">w = [-<span class="built_in">fliplr</span>(w), w(<span class="number">2</span>:K+<span class="number">1</span>)];</span><br><span class="line">X = [<span class="built_in">fliplr</span>(X), X(<span class="number">2</span>:K+<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="built_in">plot</span>(t*<span class="number">1000</span>,xa);</span><br><span class="line">xlabel(<span class="string">'t in msec.'</span>); </span><br><span class="line">ylabel(<span class="string">'x1(n)'</span>);</span><br><span class="line">title(<span class="string">'Discrete Signal'</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">stem(n*Ts*<span class="number">1000</span>,<span class="built_in">real</span>(x));gtext(<span class="string">'Ts=0.2 msec'</span>);<span class="built_in">hold</span> off;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);<span class="built_in">plot</span>(w/<span class="built_in">pi</span>,X);</span><br><span class="line">xlabel(<span class="string">'Frequency in pi units'</span>);ylabel(<span class="string">'X1(w)'</span>);</span><br><span class="line">title(<span class="string">'Discrete-time Fourier Transform'</span>);</span><br></pre></td></tr></table></figure><h2 id="Fs-5000sam-sec"><a href="#Fs-5000sam-sec" class="headerlink" title="Fs=5000sam/sec"></a>Fs=5000sam/sec</h2><p>xa(t)的频率为2KHz，因此它的Nyquist频率为4KHz，而它的采样频率为5KHz，所以是满足Nyquist采样定律的，此时不会发生混叠。</p><p>运行效果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/dtft_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Fs-1000sam-sec"><a href="#Fs-1000sam-sec" class="headerlink" title="Fs=1000sam/sec"></a>Fs=1000sam/sec</h2><p>这里使用的采样频率为1KHz，不满足Nyquist条件，因此会发生混叠。观察一下就会发生，1KHz采样得到的序列的频域波形和前面的频域波形不同，这就是混叠导致的，而且过低的采样率采集的信号的变换的不可逆的。</p><p>运行效果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/dtft_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;傅里叶变换是我们最早开始接触的时频域变换方法，虽然经常使用，知道怎么用纸笔计算，但是还从来没有在电脑中模拟过，正好现在开始学习数字信号处理，借着这个机会再学习如何在电脑上模拟傅里叶变换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DSP" scheme="http://greedyhao.cc/tags/DSP/"/>
    
      <category term="Matlab" scheme="http://greedyhao.cc/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>c语言scanf输入问题</title>
    <link href="http://greedyhao.cc/2018/10/17/%E5%B7%A5%E4%BD%9C-c-language-2018-10-17-c%E8%AF%AD%E8%A8%80scanf%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://greedyhao.cc/2018/10/17/工作-c-language-2018-10-17-c语言scanf输入问题/</id>
    <published>2018-10-17T10:28:22.000Z</published>
    <updated>2018-10-17T10:28:59.212Z</updated>
    
    <content type="html"><![CDATA[<p>经常有学弟学妹问到一个max函数(从两个数中找出最大的数)的问题，现在统一作答。</p><a id="more"></a><p>我将他们的代码放出来<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d,%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    c = max(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max=%d\n"</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) z = x;</span><br><span class="line">    <span class="keyword">else</span> z = y;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ gcc error.c </span><br><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ ./a.out </span><br><span class="line">1，8</span><br><span class="line">max=1</span><br></pre></td></tr></table></figure></p><p>这里输出结果视编译器不同而不同。</p><p>之所以出现这样的问题，是因为输入数据的时候，格式化使用的逗号是中文导致的问题，重新使用英文逗号尝试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ ./a.out </span><br><span class="line">1,8</span><br><span class="line">max=8</span><br></pre></td></tr></table></figure><p>会发现程序运行正常了</p><p>在这里建议各位，在scanf格式化的时候，别使用逗号做分隔符，使用空格就可以避免类似的问题了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scanf("%d,%d",&amp;a,&amp;b);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br></pre></td></tr></table></figure><p>修改后的程序使用示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ gcc error.c </span><br><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~/Desktop$ ./a.out </span><br><span class="line">1 8</span><br><span class="line">max=8</span><br></pre></td></tr></table></figure></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常有学弟学妹问到一个max函数(从两个数中找出最大的数)的问题，现在统一作答。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c语言" scheme="http://greedyhao.cc/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Sysgen-license-checkout-failed</title>
    <link href="http://greedyhao.cc/2018/10/11/%E5%B7%A5%E4%BD%9C-fpga-2018-10-11-Sysgen-license-checkout-failed/"/>
    <id>http://greedyhao.cc/2018/10/11/工作-fpga-2018-10-11-Sysgen-license-checkout-failed/</id>
    <published>2018-10-11T09:00:45.000Z</published>
    <updated>2018-10-11T09:00:48.939Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reported by:</span><br><span class="line">Unspecified</span><br><span class="line"></span><br><span class="line">Details:</span><br><span class="line">Sysgen license checkout failed.</span><br><span class="line">XILINXD_LICENSE_FILE = C:/Xilinx/Vivado/2016.1/data/sysgen/hwcosim_compiler/pp_ethernet</span><br><span class="line">Environment variable LM_LICENSE_FILE is not set.</span><br><span class="line">License search path: C:\.Xilinx;C:\Xilinx\Vivado\2016.1\data\sysgen\hwcosim_compiler\pp_ethernet;C:\Xilinx\Vivado\2016.1\data\ipcore_licenses</span><br></pre></td></tr></table></figure><p>这个错误是由于找不到license导致的</p><p>由于我无法复原错误了，所以就去网上找了一个差不多的出错信息</p><p>这个错误信息是windows下的，我的系统是ubuntu18.04，不过操作过程是差不多的</p><p>在错误信息中，可以看见<strong>XILINXD_LICENSE_FILE</strong>的位置，cd到这个位置，把自己的license复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x *.lic</span><br></pre></td></tr></table></figure><p>再次运行Sysgen会发现，没有再报错了</p><h1 id="windows下操作"><a href="#windows下操作" class="headerlink" title="windows下操作"></a>windows下操作</h1><p>找到你的<strong>XILINXD_LICENSE_FILE</strong>位置，然后找到你的vivado的license位置，把这个license复制到<strong>XILINXD_LICENSE_FILE</strong>位置</p><h1 id="license下载"><a href="#license下载" class="headerlink" title="license下载"></a>license下载</h1><p>虽然说是支持正版，不过这种软件一般的个人还是负担不起的，主要还是靠公司买单。</p><p>没钱的穷孩子可以下载<a href="https://github.com/greedyhao/some_useful_files/tree/master/vivado-license" target="_blank" rel="noopener">vivado-license全部功能破解</a></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
  </entry>
  
  <entry>
    <title>对Xil_Out32未定义的引用</title>
    <link href="http://greedyhao.cc/2018/09/29/%E5%B7%A5%E4%BD%9C-fpga-2018-09-29-%E5%AF%B9Xil-Out32%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <id>http://greedyhao.cc/2018/09/29/工作-fpga-2018-09-29-对Xil-Out32未定义的引用/</id>
    <published>2018-09-29T12:48:10.000Z</published>
    <updated>2018-09-29T12:48:34.037Z</updated>
    
    <content type="html"><![CDATA[<p>第一次在HLS中遇见一个官方的函数未定义问题，这就把解决方法记录下来。</p><a id="more"></a><p>在创建好工程，写完工程代码后，发现报错如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./src/led_controller_test_tut_4A.o：在函数‘main’中：</span><br><span class="line">/home/greedyhao/Projects/LearningAndWorking/led_controller/led_controller.sdk/LED_Controller_test/Debug/../src/led_controller_test_tut_4A.c:44：对‘Xil_Out32’未定义的引用</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">makefile:39: recipe for target &apos;LED_Controller_test.elf&apos; failed</span><br><span class="line">make: *** [LED_Controller_test.elf] Error 1</span><br></pre></td></tr></table></figure><p>一眼就知道<strong>Xil_Out32</strong>这个函数，绝对是官方定义的啊。</p><p>找到它的定义在<em>xil_io.h</em>这个文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> INLINE <span class="keyword">void</span> <span class="title">Xil_Out32</span><span class="params">(UINTPTR Addr, u32 Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在网上查到有人说，因为这个函数是static的，所以将这个头文件include到主函数的文件就可以了</p><p>于是在主函数文件添加<strong>#include “xil_io.h”</strong>并保存好，工程正常</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次在HLS中遇见一个官方的函数未定义问题，这就把解决方法记录下来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
  </entry>
  
  <entry>
    <title>Vivado生成Bitstream失败的解决方法</title>
    <link href="http://greedyhao.cc/2018/09/29/%E5%B7%A5%E4%BD%9C-fpga-2018-09-29-Vivado%E7%94%9F%E6%88%90Bitstream%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://greedyhao.cc/2018/09/29/工作-fpga-2018-09-29-Vivado生成Bitstream失败的解决方法/</id>
    <published>2018-09-29T09:18:12.000Z</published>
    <updated>2018-09-29T09:18:27.204Z</updated>
    
    <content type="html"><![CDATA[<p>跟着实验指导书，难得的又遇到问题了，在最后生成Bitstream的时候出错了，无法生成Bitstream。</p><a id="more"></a><p>报错信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[DRC NSTD-1] Unspecified I/O Standard: 4 out of 134 logical ports use I/O standard (IOSTANDARD) value &apos;DEFAULT&apos;, instead of a user assigned specific value. This may cause I/O contention or incompatibility with the board power or connectivity affecting performance, signal integrity or in extreme cases cause damage to the device or the components to which it is connected. To correct this violation, specify all I/O standards. This design will fail to generate a bitstream unless all logical ports have a user specified I/O standard value defined. To allow bitstream creation with unspecified I/O standard values (not recommended), use this command: set_property SEVERITY &#123;Warning&#125; [get_drc_checks NSTD-1].  NOTE: When using the Vivado Runs infrastructure (e.g. launch_runs Tcl command), add this command to a .tcl file and add that file as a pre-hook for write_bitstream step for the implementation run. Problem ports: LEDs_out_0[3:0].</span><br><span class="line"></span><br><span class="line">[DRC UCIO-1] Unconstrained Logical Port: 4 out of 134 logical ports have no user assigned specific location constraint (LOC). ... Problem ports: LEDs_out_0[3:0].</span><br></pre></td></tr></table></figure><p>在我绝望的时候在网上搜到了解决方法，问题还是出在了XDC文件上</p><p>我是直接复制的实验指导书中的XDC文件中的内容，但是在生成ked_controller这个ip核的port的时候，生成的port的名字和实验中的并不一样。</p><p>xdc文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set_property PACKAGE_PIN M14            [get_ports &#123;LEDs_out[0]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;LEDs_out[0]&#125;]</span><br><span class="line">set_property PACKAGE_PIN M15 [get_ports &#123;LEDs_out[1]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;LEDs_out[1]&#125;]</span><br><span class="line">set_property PACKAGE_PIN G14     [get_ports &#123;LEDs_out[2]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;LEDs_out[2]&#125;]</span><br><span class="line">set_property PACKAGE_PIN D18 [get_ports &#123;LEDs_out[3]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;LEDs_out[3]&#125;]</span><br></pre></td></tr></table></figure></p><p>注意下我的DRC报错信息就会发现一个重要的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Problem ports: LEDs_out_0[3:0].</span><br></pre></td></tr></table></figure></p><p>这报错的port似乎有点不对劲，和约束文件中声明的port不一样，这也是为什么报错说LEDs_out_0这个port unspecified的原因，因为你XDC中声明的是LEDs_out啊。</p><p>解决方法很简单，把这个port的名字改了就好，更改方法如图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_E4a_BitERR.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟着实验指导书，难得的又遇到问题了，在最后生成Bitstream的时候出错了，无法生成Bitstream。&lt;/p&gt;
    
    </summary>
    
      <category term="入门学习" scheme="http://greedyhao.cc/categories/%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
      <category term="Zybo" scheme="http://greedyhao.cc/tags/Zybo/"/>
    
  </entry>
  
  <entry>
    <title>ZynqBook实验二的实践</title>
    <link href="http://greedyhao.cc/2018/09/21/%E5%B7%A5%E4%BD%9C-fpga-2018-09-21-ZynqBook%E5%AE%9E%E9%AA%8C%E4%BA%8C%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>http://greedyhao.cc/2018/09/21/工作-fpga-2018-09-21-ZynqBook实验二的实践/</id>
    <published>2018-09-21T15:50:54.000Z</published>
    <updated>2018-09-22T05:18:07.317Z</updated>
    
    <content type="html"><![CDATA[<p>首先自然是跟着实验指导书做实验了</p><a id="more"></a><h1 id="实验2B"><a href="#实验2B" class="headerlink" title="实验2B"></a>实验2B</h1><p>然后发现别人添加另外一个gpio的方法是需要重新添加一个gpio的ip核的，而不是直接用同一个ip核的另外一个gpio口</p><p> ~而且感觉在SDK上编程的体验还是不太佳，没有代码自动补全能力~~ ，网上搜索了一下，发现代码补全的能力是有的，快捷键<strong>alt+/</strong></p><p>这个实验的目标是使用中断检测按键输入，然后控制led灯的变换，按键(btns)按下时，对应leds的那一位加1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InterruptSystemSetup</span><span class="params">(XScuGic *XScuGicInstancePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Enable interrupt</span></span><br><span class="line">XGpio_InterruptEnable(&amp;BTNInst, BTN_INT);</span><br><span class="line">XGpio_InterruptGlobalEnable(&amp;BTNInst);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IntcInitFunction</span><span class="params">(u16 DeviceId, XGpio *GpioInstancePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    status = XScuGic_Connect(&amp;INTCInst,</span><br><span class="line">                            INTC_GPIO_INTERRUPT_ID,</span><br><span class="line">                            (Xil_ExceptionHandler)BTN_Intr_Handler,</span><br><span class="line">                            (<span class="keyword">void</span> *)GpioInstancePtr);</span><br><span class="line"><span class="keyword">if</span>(status != XST_SUCCESS) <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable GPIO interrupts interrupt</span></span><br><span class="line">XGpio_InterruptEnable(GpioInstancePtr, <span class="number">1</span>);</span><br><span class="line">XGpio_InterruptGlobalEnable(GpioInstancePtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable GPIO and timer interrupts in the controller</span></span><br><span class="line">XScuGic_Enable(&amp;INTCInst, INTC_GPIO_INTERRUPT_ID);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zynq的ps这边使用中断和以前mcu开发时很像，也都是需要先对中断注册，然后开中断，最后才能使用。</p><p>中断能用了，还要声明一个处理中断的函数，这个例程中的<em>BTN_Intr_Handler</em>就是一个处理中断的函数，在初始化中断的时候就注册好了。</p><p>效果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_E2b.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="实验2B总结"><a href="#实验2B总结" class="headerlink" title="实验2B总结"></a>实验2B总结</h2><p>通过这个部分的实验，学会了如何在Vivado中，开启一个ip的中断，又是怎么与zynq的ps核连接。</p><p>还学习到，要想在ps中使用这个中断，需要注册初始化这个中断和声明一个处理中断的函数。</p><h1 id="实验2D"><a href="#实验2D" class="headerlink" title="实验2D"></a>实验2D</h1><p>这个实验是教我们添加更多的中断源，很现实的一个例子。</p><p>目前来看，ps添加多个中断源，需要增加一个mask，通过判定加了mask后的中断号，来判定是哪一个外设产生的中断。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_E2b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个实验添加了一个定时器中断源，在上一个实验的基础上使用了定时器中断，每三次定时器中断会让leds的值加1，控制定时器中断时间的，是<em>TMRInst</em>这个变量，每达到设置的0xF8000000这个值，触发一次中断</p><p>效果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_E2d.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="实验2D总结"><a href="#实验2D总结" class="headerlink" title="实验2D总结"></a>实验2D总结</h2><p>学习了怎么添加多个中断源</p><p>学习了xilinx中的定时器的使用</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先自然是跟着实验指导书做实验了&lt;/p&gt;
    
    </summary>
    
      <category term="入门学习" scheme="http://greedyhao.cc/categories/%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
      <category term="Zybo" scheme="http://greedyhao.cc/tags/Zybo/"/>
    
  </entry>
  
  <entry>
    <title>ZynqBook实验一延伸部分</title>
    <link href="http://greedyhao.cc/2018/09/21/%E5%B7%A5%E4%BD%9C-fpga-2018-09-21-ZynqBook%E5%AE%9E%E9%AA%8C%E4%B8%80%E5%BB%B6%E4%BC%B8%E9%83%A8%E5%88%86/"/>
    <id>http://greedyhao.cc/2018/09/21/工作-fpga-2018-09-21-ZynqBook实验一延伸部分/</id>
    <published>2018-09-21T14:46:44.000Z</published>
    <updated>2018-09-22T06:42:53.161Z</updated>
    
    <content type="html"><![CDATA[<p>实验一的内容主要就是如何为zybo创建工程，然后如何烧写这第一个程序。尽管只是一个简单的LED闪烁的程序，但是对学习开发zybo的帮助还是很大的。</p><a id="more"></a><p>上次的实验，是直接使用zynqbook提供的代码，是让led 0 3位和1 2位的交替闪烁</p><p>根据实验指导书建议的，自己修改led的闪烁方式</p><p>我将它的闪烁方式改成了类似流水灯的闪烁方式、</p><p>原理就是和一个移动的位异或，然后循环左移这个位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Definitions */</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED 0x0<span class="comment">/* Initial LED value - X00X */</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LEDOutputExample</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Loop forever blinking the LED. */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Flip LEDs. */</span></span><br><span class="line"><span class="comment">//led = ~led;</span></span><br><span class="line">led = led ^ (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">4</span>) i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait a small amount of time so that the LED blinking is visible. */</span></span><br><span class="line"><span class="keyword">for</span> (Delay = <span class="number">0</span>; Delay &lt; LED_DELAY; Delay++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> XST_SUCCESS; <span class="comment">/* Should be unreachable */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_E1x.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>至于第三个建议扩展一个io的部分，我没有实现</p><p>因为我在block design中添加gpio2后，在sdk中没有生成gpio2的定义</p><p>于是我决定在第二个实验中寻找答案</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实验一的内容主要就是如何为zybo创建工程，然后如何烧写这第一个程序。尽管只是一个简单的LED闪烁的程序，但是对学习开发zybo的帮助还是很大的。&lt;/p&gt;
    
    </summary>
    
      <category term="入门学习" scheme="http://greedyhao.cc/categories/%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
      <category term="Zybo" scheme="http://greedyhao.cc/tags/Zybo/"/>
    
  </entry>
  
  <entry>
    <title>linux命令行运行第三方软件</title>
    <link href="http://greedyhao.cc/2018/09/18/%E5%B7%A5%E4%BD%9C-Linux-2018-09-18-linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6/"/>
    <id>http://greedyhao.cc/2018/09/18/工作-Linux-2018-09-18-linux命令行运行第三方软件/</id>
    <published>2018-09-18T07:41:50.000Z</published>
    <updated>2018-09-18T08:30:46.514Z</updated>
    
    <content type="html"><![CDATA[<p>linux的宗旨是万物皆文件，所以很多不在源中的程序就是解包即用，但这样使用起来有些不方便，需要cd到可执行文件目录，然后再运行，显得有些麻烦。</p><a id="more"></a><p>就以最近下载的一个软件为例</p><p>它的执行命令为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar proxyee-down-main.jar</span><br></pre></td></tr></table></figure></p><p>保存到proxyee-down后，发现无法运行，就给权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x proxyee-down</span><br></pre></td></tr></table></figure><p>但是发现这样的话，还是只能在这个jar包的位置才能正常执行这个文件</p><p>想到shell下可以使用pwd查看当前目录</p><p>于是首先先加上标记，告诉系统使用bash<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">java -jar $(<span class="built_in">pwd</span>)/proxyee-down-main.jar</span><br></pre></td></tr></table></figure></p><p>但是发现pwd给的是当前目录，而不是脚本的目录，于是改用dirname</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">work_path=$(dirname $(readlink -f <span class="variable">$0</span>))</span><br><span class="line">java -jar <span class="variable">$&#123;work_path&#125;</span>/proxyee-down-main.jar</span><br></pre></td></tr></table></figure><p>在命令行测试成功</p><hr><p><strong>参考资料</strong></p><ul><li><a href="http://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">Shell 教程</a></li><li><a href="https://blog.csdn.net/qq_18150497/article/details/76600828" target="_blank" rel="noopener">shell 当前工作目录的绝对路径</a></li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux的宗旨是万物皆文件，所以很多不在源中的程序就是解包即用，但这样使用起来有些不方便，需要cd到可执行文件目录，然后再运行，显得有些麻烦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://greedyhao.cc/tags/Linux/"/>
    
      <category term="Shell" scheme="http://greedyhao.cc/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>zybo初体验</title>
    <link href="http://greedyhao.cc/2018/09/17/%E5%B7%A5%E4%BD%9C-fpga-2018-09-17-zybo%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://greedyhao.cc/2018/09/17/工作-fpga-2018-09-17-zybo初体验/</id>
    <published>2018-09-17T14:15:21.000Z</published>
    <updated>2018-09-22T05:18:03.881Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间过生日，亲戚给了些钱让我自己买生日礼物，早就想搞一块zynq的板了，但是淘宝一看太贵，于是去咸鱼上淘了一块二手的ZYBO(谁知道是不是二手，反正看着挺新)来玩玩。</p><a id="more"></a><p>学习肯定是从官方资料开始的，<em>The Zynq Book</em>了解下，作者都是牛人，他们的介绍看<a href="http://www.zynqbook.com/authors.html" target="_blank" rel="noopener">这里</a>，反正跟着大牛学就没有错，可以避免很多坑。</p><p><em>The Zynq Book</em>系统的讲解了Zynq的相关知识，比如Zynq的架构、应用等，主要偏理论，它的配套书籍<em>The Zynq Book Tutorial</em>，就是实战内容了，可以跟着Tutorial动手，一步步完成实验，对学习使用Zynq和它的开发软件Vivado很有帮助。</p><p>目前我刚刚学习完第一个练习，很开心，迫不及待的跑过来分享一下我的体验。</p><p>首先，开发板越多人使用越好，最好要选择大公司，他们的生态比小公司生产的开发板要好很多。就像我这次，在第一个实验就出现了问题，明明按照Tutorial说明的实验步骤操作的，但是结果却不正确，搜索了很久找不到结果(可能是没找到点上)，然后去Digilent的论坛上发帖提问，才过了几个小时就有人解决了我的问题，原来是我配置GPIO借口时粗心了，配置到btns 4bits去了，导致程序不能正常工作。</p><p>然后就是，Xilinx的体验感觉比Altera的体验要好。Altera的文档不好找，之前使用Altera，翻文档的经历不好受，想找的东西就是找不到；而且tutorial也做的不好。Xilinx做的就比Altera明显好得多了，对文档做了打包，用DocNav管理文档，而且文档有了更新下载很方便；最重要的是新手教程很不错，<em>The Zynq Book</em>很好用。</p><p>最后献上我的体验效果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_E1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/xilinx/zybo_led_blink.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>本文所提及的教程已经上传百度云，回复</p><p><strong>下载|Zynq_Book</strong></p><p>获取下载链接</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间过生日，亲戚给了些钱让我自己买生日礼物，早就想搞一块zynq的板了，但是淘宝一看太贵，于是去咸鱼上淘了一块二手的ZYBO(谁知道是不是二手，反正看着挺新)来玩玩。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
      <category term="Zynq" scheme="http://greedyhao.cc/tags/Zynq/"/>
    
      <category term="Zybo" scheme="http://greedyhao.cc/tags/Zybo/"/>
    
  </entry>
  
  <entry>
    <title>代码重定位</title>
    <link href="http://greedyhao.cc/2018/09/13/%E5%B7%A5%E4%BD%9C-x210-2018-09-13-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
    <id>http://greedyhao.cc/2018/09/13/工作-x210-2018-09-13-代码重定位/</id>
    <published>2018-09-13T08:25:18.000Z</published>
    <updated>2018-09-13T11:21:05.240Z</updated>
    
    <content type="html"><![CDATA[<p>代码重定位可以将一段代码镜像到另一个地址，有点像链接，不过镜像位置所占空间大小和原代码位置所占大小相同。</p><a id="more"></a><p>那么为什么要这么做呢</p><p>我们知道，越是高速的设备越贵，因此为了节约成本，这些高速设备空间都比较小，比如像S5PV210中的SRAM，只有96KB的大小，但是不需要初始化；SDRAM虽然可以做到很大，多以G做单位，但是需要软件初始化。</p><p>产品中使用的bootloader可能可以裁剪到几十K的大小，但是如果想使用uboot的话，就会发现，才几十K的空间根本不够用；为了解决这个办法，只好使用重定位的方法，将uboot的代码重定位到容量比较大，速度又还过得去的SDRAM中，在SDRAM中运行系统。</p><h1 id="长跳转与短跳转"><a href="#长跳转与短跳转" class="headerlink" title="长跳转与短跳转"></a>长跳转与短跳转</h1><p>在镜像后，运行时地址相关函数地址也会被映射到镜像地址处，要想执行镜像代码处的函数，就需要使用长跳转ldr，而不是短跳转bl。</p><h1 id="adr短加载和ldr长加载的不同"><a href="#adr短加载和ldr长加载的不同" class="headerlink" title="adr短加载和ldr长加载的不同"></a>adr短加载和ldr长加载的不同</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//file: .S</span><br><span class="line">...</span><br><span class="line">adr r0, _start</span><br><span class="line">ldr r1, =_start</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//file: .dis</span><br><span class="line">...</span><br><span class="line">d002401c:e24f0024 subr0, pc, #36; 0x24</span><br><span class="line">d0024020:e59f1048 ldrr1, [pc, #72]; d0024070 &lt;run_on_dram+0x10&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="清bss"><a href="#清bss" class="headerlink" title="清bss"></a>清bss</h1><p>把链接地址处把bss段清零，这是为了避免脏数据，万一连接处的bss段不为０，会导致c语言中的全局变量不为０。</p><p>运行处的bss段不需要清0，编译器已经帮忙清0过了。</p><h1 id="需要重定位的长度为代码段＋数据段"><a href="#需要重定位的长度为代码段＋数据段" class="headerlink" title="需要重定位的长度为代码段＋数据段"></a>需要重定位的长度为代码段＋数据段</h1><h1 id="两级流水线导致pc的值指向前２两个字节"><a href="#两级流水线导致pc的值指向前２两个字节" class="headerlink" title="两级流水线导致pc的值指向前２两个字节"></a>两级流水线导致pc的值指向前２两个字节</h1><p>而且pc指针指向的是当前地址，而不是被链接到的地址，实际pc的地址为当前地址加两个字节</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码重定位可以将一段代码镜像到另一个地址，有点像链接，不过镜像位置所占空间大小和原代码位置所占大小相同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="x210" scheme="http://greedyhao.cc/tags/x210/"/>
    
  </entry>
  
  <entry>
    <title>运行c代码前发生了什么</title>
    <link href="http://greedyhao.cc/2018/09/13/%E5%B7%A5%E4%BD%9C-c-language-2018-09-13-%E8%BF%90%E8%A1%8Cc%E4%BB%A3%E7%A0%81%E5%89%8D%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://greedyhao.cc/2018/09/13/工作-c-language-2018-09-13-运行c代码前发生了什么/</id>
    <published>2018-09-13T01:56:04.000Z</published>
    <updated>2018-09-13T11:16:41.364Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，c代码也是一种比较高级的语言了，机器是没有办法直接运行的，机器所能理解的只有机器码–那一串0和1而已。</p><a id="more"></a><p>虽然早就知道c代码是先经过编译链接最后才放在机器上执行，但是在这么一个过程中究竟发生了什么，最近在学习嵌入式裸机开发中，才又有了更深入的了解。</p><h1 id="简单描述一下生成机器代码过程"><a href="#简单描述一下生成机器代码过程" class="headerlink" title="简单描述一下生成机器代码过程"></a>简单描述一下生成机器代码过程</h1><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>编译过程是以前就知道了的，预编译会对一些带#号的预编译命令处理，如#define等，编译器会对他们进行替换得到.i文件，然后进一步编译得到.o文件。</p><h2 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h2><p>在将源文件编译成可执行文件时，有一个过程是链接。</p><p>其实我以前就对这个链接过程感觉有些不解的，这个链接过程到底是怎么把这些.o文件链接在一起，是有一种什么样的规则呢，总不可能随便链接的吧，随便链接的话怎么解决依赖问题。</p><p>直到之前了解了一下alios系统，在学习的过程中发现，在芯片架构的支持中，有一个elf文件，里面定义了一些地址，当时还不知道有什么用；最近学习裸机开发中，也遇到了这么一个类似的lds文件。</p><p>通过学习，才知道，原来这种文件定义了各个段如代码段、数据段等的地址，这样编译器在链接的过程中，就知道了要把各种.o文件以什么样的顺序链接，链接在什么地址处。</p><h1 id="准备c语言运行环境"><a href="#准备c语言运行环境" class="headerlink" title="准备c语言运行环境"></a>准备c语言运行环境</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/c_language/StartupCode.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这是我在网上找的图，从图中可以看出，为了使c程序可以执行在目标处理器，链接的过程中，还混入了一些其他的东西，比如Startup Code。</p><p>在Startup Code中，会做一系列的事，比如关中断、重定位、申请栈空间等等，具体过程和硬件相关。</p><p>最后跳转到main()。</p><p>网上有一篇基于ARM介绍这些相关知识的，非常建议去看看，可以解决自己以前嵌入式编程的很多疑惑。</p><p><a href="http://www.bravegnu.org/gnu-eprog/c-startup.html" target="_blank" rel="noopener">http://www.bravegnu.org/gnu-eprog/c-startup.html</a></p><h1 id="篇外话"><a href="#篇外话" class="headerlink" title="篇外话"></a>篇外话</h1><p>这篇博文是在接触到了一些启动代码后突然有的想法，就开始整理自己的思路，写的同时，在谷歌上查找自己疑惑的地方，从runtime environment查到startup code，结果发现自己疑惑的地方却更多了O__O “…，好好的一篇科普文变成了推荐阅读文(手动笑哭)</p><p>非常建议看看下面给出的参考资料，相信对初学者会有很大帮助。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.bravegnu.org/gnu-eprog/c-startup.html" target="_blank" rel="noopener">C Startup</a></li><li><a href="http://microchipdeveloper.com/tls2101:c-runtime-environment" target="_blank" rel="noopener">Microchip Developer Help</a></li><li><a href="https://stackoverflow.com/questions/3393611/flow-of-startup-code-in-an-embedded-system-concept-of-boot-loader" target="_blank" rel="noopener">Flow of Startup code in an embedded system , concept of boot loader?</a></li><li><a href="https://www.zhihu.com/question/49580321" target="_blank" rel="noopener">C 如何编译出一个不需要操作系统的程序？</a></li><li><a href="http://www.cnblogs.com/pengdonglin137/p/3234367.html" target="_blank" rel="noopener">数据段、代码段、堆栈段、BSS段的区别</a></li><li><a href="https://blog.csdn.net/koozxcv/article/details/49533731" target="_blank" rel="noopener">Linux进程的五个段（数据段、代码段、bss、堆栈段）</a></li></ul><hr><p><img src="/img/wechat_official_accounts.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，c代码也是一种比较高级的语言了，机器是没有办法直接运行的，机器所能理解的只有机器码–那一串0和1而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="x210" scheme="http://greedyhao.cc/tags/x210/"/>
    
  </entry>
  
  <entry>
    <title>Vivado无法连接到开发板</title>
    <link href="http://greedyhao.cc/2018/09/12/%E5%B7%A5%E4%BD%9C-fpga-2018-09-12-Vivado%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    <id>http://greedyhao.cc/2018/09/12/工作-fpga-2018-09-12-Vivado无法连接到开发板/</id>
    <published>2018-09-12T03:09:48.000Z</published>
    <updated>2018-09-12T03:12:52.983Z</updated>
    
    <content type="html"><![CDATA[<p>从咸鱼上淘了一块二手的ZYBO来玩，因为出了新版开发板ZYBO-Z7，所以旧版的还是比较便宜，才600来块</p><p>在使用Hardware Manage的auto connect连接开发板的时候发现，无论开发板是使用QSPI还是JTAG模式，都无法连接到电脑</p><p>参考自<a href="https://forums.xilinx.com/t5/Installation-and-Licensing/Vivado-2015-2-Cable-driver-installation-problem/td-p/642140" target="_blank" rel="noopener">Vivado 2015.2 Cable driver installation problem</a></p><p>发现我缺少了驱动的安装</p><p>步骤如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;Vivado installation dir&gt;/data/xicom/cable_drivers/lin64/install_script/install_drivers/</span><br><span class="line">./install_drivers</span><br></pre></td></tr></table></figure></p><p>下面是我的输出结果，不知道为什么有个CRITICAL WARNING，暂时没有找到解决方法，也没有遇见问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:/usr/<span class="built_in">local</span>/Xilinx/Vivado/2018.2/data/xicom/cable_drivers/lin64/install_script/install_drivers$ sudo ./install_drivers </span><br><span class="line">[sudo] greedyhao 的密码： </span><br><span class="line">INFO: Installing cable drivers.</span><br><span class="line">INFO: Script name = ./install_drivers</span><br><span class="line">INFO: HostName = greedyhao-HP-Pavilion-Notebook</span><br><span class="line">INFO: Current working dir = /usr/<span class="built_in">local</span>/Xilinx/Vivado/2018.2/data/xicom/cable_drivers/lin64/install_script/install_drivers</span><br><span class="line">INFO: Kernel version = 4.15.0-34-generic.</span><br><span class="line">INFO: Arch = x86_64.</span><br><span class="line">Successfully installed Digilent Cable Drivers</span><br><span class="line">--File /etc/udev/rules.d/52-xilinx-ftdi-usb.rules does not exist.</span><br><span class="line">--File version of /etc/udev/rules.d/52-xilinx-ftdi-usb.rules = 0000.</span><br><span class="line">--Updating rules file.</span><br><span class="line">--File /etc/udev/rules.d/52-xilinx-pcusb.rules does not exist.</span><br><span class="line">--File version of /etc/udev/rules.d/52-xilinx-pcusb.rules = 0000.</span><br><span class="line">--Updating rules file.</span><br><span class="line"></span><br><span class="line">INFO: Digilent Return code = 0</span><br><span class="line">INFO: Xilinx Return code = 0</span><br><span class="line">INFO: Xilinx FTDI Return code = 0</span><br><span class="line">INFO: Return code = 0</span><br><span class="line">INFO: Driver installation successful.</span><br><span class="line">CRITICAL WARNING: Cable(s) on the system must be unplugged <span class="keyword">then</span> plugged back <span class="keyword">in</span> order <span class="keyword">for</span> the driver scripts to update the cables.</span><br></pre></td></tr></table></figure><p>参考资料</p><ul><li><a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2018_1/ug973-vivado-release-notes-install-license.pdf" target="_blank" rel="noopener">ug973-vivado-release-notes-install-license</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从咸鱼上淘了一块二手的ZYBO来玩，因为出了新版开发板ZYBO-Z7，所以旧版的还是比较便宜，才600来块&lt;/p&gt;
&lt;p&gt;在使用Hardware Manage的auto connect连接开发板的时候发现，无论开发板是使用QSPI还是JTAG模式，都无法连接到电脑&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="FPGA" scheme="http://greedyhao.cc/tags/FPGA/"/>
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
  </entry>
  
  <entry>
    <title>Vivado启动遇见QSslSocket系列问题</title>
    <link href="http://greedyhao.cc/2018/09/12/%E5%B7%A5%E4%BD%9C-fpga-2018-09-12-Vivado%E5%90%AF%E5%8A%A8%E9%81%87%E8%A7%81QSslSocket%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>http://greedyhao.cc/2018/09/12/工作-fpga-2018-09-12-Vivado启动遇见QSslSocket系列问题/</id>
    <published>2018-09-12T02:34:11.000Z</published>
    <updated>2018-09-12T02:57:19.601Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">greedyhao@greedyhao-HP-Pavilion-Notebook:~$ vivado</span><br><span class="line"></span><br><span class="line">****** Vivado v2018.2 (64-bit)</span><br><span class="line">  **** SW Build 2258646 on Thu Jun 14 20:02:38 MDT 2018</span><br><span class="line">  **** IP Build 2256618 on Thu Jun 14 22:10:49 MDT 2018</span><br><span class="line">    ** Copyright 1986-2018 Xilinx, Inc. All Rights Reserved.</span><br><span class="line"></span><br><span class="line">start_gui</span><br><span class="line"></span><br><span class="line">QSslSocket: cannot resolve CRYPTO_num_locks</span><br><span class="line">QSslSocket: cannot resolve CRYPTO_set_id_callback</span><br><span class="line">QSslSocket: cannot resolve CRYPTO_set_locking_callback</span><br><span class="line">QSslSocket: cannot resolve sk_free</span><br><span class="line">QSslSocket: cannot resolve sk_num</span><br><span class="line">QSslSocket: cannot resolve sk_pop_free</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我发现我每次启动vivado时，都会弹出这些错误信息，而且Hardware Manage的auto connect无法识别我的开发板ZYBO，就想着先解决这些报错信息。</p><p>解决方法来自<a href="https://github.com/wkhtmltopdf/wkhtmltopdf/issues/3001" target="_blank" rel="noopener">QSslSocket: cannot resolve SSLv3_client_method / SSLv3_server_method</a></p><p>原文是这么说的</p><blockquote><p>For Debian Stretch users and others with the QSslSocket: cannot resolve $func issue, you just need to install the package libssl1.0-dev (or similar package in your distro).</p></blockquote><p>打开终端<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libssl1.0-dev</span><br></pre></td></tr></table></figure></p><p>安装完成后就会发现，不会再有报错信息出现了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="FPGA" scheme="http://greedyhao.cc/tags/FPGA/"/>
    
      <category term="Xilinx" scheme="http://greedyhao.cc/tags/Xilinx/"/>
    
  </entry>
  
  <entry>
    <title>如何使用matlab进行频域分析</title>
    <link href="http://greedyhao.cc/2018/08/24/%E5%B7%A5%E4%BD%9C-dsp-2018-08-24-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8matlab%E8%BF%9B%E8%A1%8C%E9%A2%91%E5%9F%9F%E5%88%86%E6%9E%90/"/>
    <id>http://greedyhao.cc/2018/08/24/工作-dsp-2018-08-24-如何使用matlab进行频域分析/</id>
    <published>2018-08-24T11:33:08.000Z</published>
    <updated>2018-10-22T07:44:31.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何使用matlab进行频域分析"><a href="#如何使用matlab进行频域分析" class="headerlink" title="如何使用matlab进行频域分析"></a>如何使用matlab进行频域分析</h1><p>Matlab可以说是一个非常有用且功能齐全的工具，在通信、自控、金融等方面有广泛的应用。</p><p>本文讨论使用Matlab对信号进行频域分析的方法。</p><a id="more"></a><p>说到频域，不可避免的会提到傅里叶变换，傅里叶变换提供了一个将信号从时域转变到频域的方法。之所以要有信号的频域分析，是因为很多信号在时域不明显的特征可以在频域下得到很好的展现，可以更加容易的进行分析和处理。</p><h1 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a><a href="#FFT"></a>FFT</h1><p>Matlab提供的傅里叶变换的函数是FFT，中文名叫做快速傅里叶变换。快速傅里叶变换的提出是伟大的，使得处理器处理数字信号的能力大大提升，也使我们生活向数字化迈了一大步。</p><p>接下来就谈谈如何使用这个函数。</p><p>fft使用很简单，但是一般信号都有x和y两个向量，而fft只会处理y向量，所以想让频域分析变得有意义，那么就需要用户自己处理x向量</p><h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a><a href="#一个简单的例子"></a>一个简单的例子</h1><p>从一个简单正弦信号开始吧，正弦信号定义为：</p><p>$$<br>y(t) = 2\sin (2\pi f_0 t)<br>$$</p><p>我们现在通过以下代码在Matlab中画出这个正弦曲线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fo = 4;   %frequency of the sine wave</span><br><span class="line">Fs = 100; %sampling rate</span><br><span class="line">Ts = 1/Fs; %sampling time interval</span><br><span class="line">t = 0:Ts:1-Ts; %sampling period</span><br><span class="line">n = length(t); %number of samples</span><br><span class="line">y = 2*sin(2*pi*fo*t); %the sine curve</span><br><span class="line"></span><br><span class="line">%plot the cosine curve in the time domain</span><br><span class="line">sinePlot = figure;</span><br><span class="line">plot(t,y)</span><br><span class="line">xlabel(&apos;time (seconds)&apos;)</span><br><span class="line">ylabel(&apos;y(t)&apos;)</span><br><span class="line">title(&apos;Sample Sine Wave&apos;)</span><br><span class="line">grid</span><br></pre></td></tr></table></figure><p>这就是我们得到的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/how_to_use_fft_1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当我们对这条曲线fft时，我们希望在频域得到以下频谱（基于傅里叶变换理论，我们希望看见一个幅值为1的峰值在-4Hz处，另一个在+4Hz处）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/how_to_use_fft_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="使用FFT命令"><a href="#使用FFT命令" class="headerlink" title="使用FFT命令"></a><a href="#使用FFT命令"></a>使用FFT命令</h1><p>我们知道目标是什么了，那么现在使用Matlab的内建的FFT函数来重新生成频谱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%plot the frequency spectrum using the MATLAB fft command</span><br><span class="line">matlabFFT = figure;  %create a new figure</span><br><span class="line">YfreqDomain = fft(y); %take the fft of our sin wave, y(t)</span><br><span class="line"></span><br><span class="line">stem(abs(YfreqDomain));  %use abs command to get the magnitude</span><br><span class="line">%similary, we would use angle command to get the phase plot!</span><br><span class="line">%we&apos;ll discuss phase in another post though!</span><br><span class="line"></span><br><span class="line">xlabel(&apos;Sample Number&apos;)</span><br><span class="line">ylabel(&apos;Amplitude&apos;)</span><br><span class="line">title(&apos;Using the Matlab fft command&apos;)</span><br><span class="line">grid</span><br><span class="line">axis([0,100,0,120])</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/how_to_use_fft_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>但是注意一下，这并不是我们真正想要的，有一些信息是缺失的</strong></p><ul><li>x轴本来应该给我们提供频率信息，但是你能读出频率吗？</li><li>幅度都是100</li><li>没有让频谱中心为0</li></ul><h1 id="为FFT定义一个函数来获取双边频谱"><a href="#为FFT定义一个函数来获取双边频谱" class="headerlink" title="为FFT定义一个函数来获取双边频谱"></a><a href="#为FFT定义一个函数来获取双边频谱"></a>为FFT定义一个函数来获取双边频谱</h1><p>以下代码可以简化获取双边频谱的过程，复制并保存到你的.m文件中</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[X,freq]</span>=<span class="title">centeredFFT</span><span class="params">(x,Fs)</span></span></span><br><span class="line"><span class="comment">%this is a custom function that helps in plotting the two-sided spectrum</span></span><br><span class="line"><span class="comment">%x is the signal that is to be transformed</span></span><br><span class="line"><span class="comment">%Fs is the sampling rate</span></span><br><span class="line">N=<span class="built_in">length</span>(x);</span><br><span class="line"><span class="comment">%this part of the code generates that frequency axis</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">mod</span>(N,<span class="number">2</span>)==<span class="number">0</span></span><br><span class="line">    k=-N/<span class="number">2</span>:N/<span class="number">2</span><span class="number">-1</span>; <span class="comment">% N even</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    k=-(N<span class="number">-1</span>)/<span class="number">2</span>:(N<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">% N odd</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">T=N/Fs;</span><br><span class="line">freq=k/T;  <span class="comment">%the frequency axis</span></span><br><span class="line"><span class="comment">%takes the fft of the signal, and adjusts the amplitude accordingly</span></span><br><span class="line">X=fft(x)/N; <span class="comment">% normalize the data</span></span><br><span class="line">X=fftshift(X); <span class="comment">%shifts the fft data so that it is centered</span></span><br></pre></td></tr></table></figure><p>这个函数输出正确的频域范围和变换后的信号，它需要输入需要变换的信号和采样率。</p><p>接下来使用前文的正弦信号做一个简单的示例，注意你的示例.m文件要和centeredFFT.m文件在一个目录下</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[YfreqDomain,frequencyRange] = centeredFFT(y,Fs);</span><br><span class="line">centeredFFT = <span class="built_in">figure</span>;</span><br><span class="line"><span class="comment">%remember to take the abs of YfreqDomain to get the magnitude!</span></span><br><span class="line">stem(frequencyRange,<span class="built_in">abs</span>(YfreqDomain));</span><br><span class="line">xlabel(<span class="string">'Freq (Hz)'</span>)</span><br><span class="line">ylabel(<span class="string">'Amplitude'</span>)</span><br><span class="line">title(<span class="string">'Using the centeredFFT function'</span>)</span><br><span class="line">grid</span><br><span class="line">axis([<span class="number">-6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1.5</span>])</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/how_to_use_fft_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这张图就满足了我们的需求,我们得到了在+4和-4处的峰值，而且幅值为1.</p><h1 id="为FFT定义一个函数来获取右边频谱"><a href="#为FFT定义一个函数来获取右边频谱" class="headerlink" title="为FFT定义一个函数来获取右边频谱"></a><a href="#为FFT定义一个函数来获取右边频谱"></a>为FFT定义一个函数来获取右边频谱</h1><p>从上图可以看出，FFT变换得到的频谱是左右对称的，因此，我们只需要其中一边就能获得信号的所有信息，我们一般保留正频率一侧。</p><p>以下的函数对上面的自定义函数做了一些修改，让它可以帮助我们只画出信号的正频率一侧</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[X,freq]</span>=<span class="title">positiveFFT</span><span class="params">(x,Fs)</span></span></span><br><span class="line">N=<span class="built_in">length</span>(x); <span class="comment">%get the number of points</span></span><br><span class="line">k=<span class="number">0</span>:N<span class="number">-1</span>;     <span class="comment">%create a vector from 0 to N-1</span></span><br><span class="line">T=N/Fs;      <span class="comment">%get the frequency interval</span></span><br><span class="line">freq=k/T;    <span class="comment">%create the frequency range</span></span><br><span class="line">X=fft(x)/N; <span class="comment">% normalize the data</span></span><br><span class="line"><span class="comment">%only want the first half of the FFT, since it is redundant</span></span><br><span class="line">cutOff = <span class="built_in">ceil</span>(N/<span class="number">2</span>);</span><br><span class="line"><span class="comment">%take only the first half of the spectrum</span></span><br><span class="line">X = X(<span class="number">1</span>:cutOff);</span><br><span class="line">freq = freq(<span class="number">1</span>:cutOff);</span><br></pre></td></tr></table></figure><p>和前面一样，使用正弦信号做一个示例，下面是示例代码</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[YfreqDomain,frequencyRange] = positiveFFT(y,Fs);</span><br><span class="line">positiveFFT = <span class="built_in">figure</span>;</span><br><span class="line">stem(frequencyRange,<span class="built_in">abs</span>(YfreqDomain));</span><br><span class="line">set(positiveFFT,<span class="string">'Position'</span>,[<span class="number">500</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">300</span>])</span><br><span class="line">xlabel(<span class="string">'Freq (Hz)'</span>)</span><br><span class="line">ylabel(<span class="string">'Amplitude'</span>)</span><br><span class="line">title(<span class="string">'Using the positiveFFT function'</span>)</span><br><span class="line">grid</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">20</span>,<span class="number">0</span>,<span class="number">1.5</span>])</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/matlab/how_to_use_fft_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>本文内容主要来自Matlab官方FFT教程，但是我找不到原链接了，就把我电脑上的文件上传到了百度云盘，公众号后台回复</p><p><strong>下载|FFT_tutorial</strong></p><p>获取下载链接</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何使用matlab进行频域分析&quot;&gt;&lt;a href=&quot;#如何使用matlab进行频域分析&quot; class=&quot;headerlink&quot; title=&quot;如何使用matlab进行频域分析&quot;&gt;&lt;/a&gt;如何使用matlab进行频域分析&lt;/h1&gt;&lt;p&gt;Matlab可以说是一个非常有用且功能齐全的工具，在通信、自控、金融等方面有广泛的应用。&lt;/p&gt;
&lt;p&gt;本文讨论使用Matlab对信号进行频域分析的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="DSP" scheme="http://greedyhao.cc/tags/DSP/"/>
    
      <category term="Matlab" scheme="http://greedyhao.cc/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>简单说说卷积的作用</title>
    <link href="http://greedyhao.cc/2018/08/12/%E5%B7%A5%E4%BD%9C-dsp-2018-08-12-%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%E5%8D%B7%E7%A7%AF%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://greedyhao.cc/2018/08/12/工作-dsp-2018-08-12-简单说说卷积的作用/</id>
    <published>2018-08-11T22:53:32.000Z</published>
    <updated>2018-10-22T07:44:34.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单说说卷积的作用"><a href="#简单说说卷积的作用" class="headerlink" title="简单说说卷积的作用"></a>简单说说卷积的作用</h1><p>卷积是一个耳熟能详的的词，自从我开始学习信号与系统以后，就一直没有离开过它，不过只是把它当成一个运算符号来看待。</p><a id="more"></a><p>不过闲着的时候，也会去想，卷积到底有什么作用。</p><p><img src="/img/dsp/思考卷积.jpg" alt=""></p><h1 id="提供一种方便的频域处理方式"><a href="#提供一种方便的频域处理方式" class="headerlink" title="提供一种方便的频域处理方式"></a><a href="#提供一种方便的频域处理方式"></a>提供一种方便的频域处理方式</h1><p><strong>时域卷积频域相乘</strong></p><p>这条法则想必大家都知道，作用非常大，可以轻松的对信号的频域做处理</p><p>简单的应用就是频域滤波</p><p>$$<br>g(x) =  \mathscr{F}^{-1}\left[H(x)F(x)\right]<br>$$</p><p>F(x)代表输入信号，H(x)代表滤波函数，g(x)代表滤波（输出）信号。</p><p>转换到时域则是</p><p>$$<br>g(x) = h(x) \ast f(x)<br>$$</p><p>以下是一个声音信号处理的例子，给matlab自带鸟叫声加了一个低通滤波器。</p><p>效果如下：</p><p>滤波前：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/chirp_bf.bmp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>滤波后：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dsp/chirp_af.bmp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% 主函数</span><br><span class="line">close all;</span><br><span class="line">load chirp;</span><br><span class="line">Hd = getFilter; % 使用Filter Builder设计的FIR</span><br><span class="line">X = filter(Hd,y); % 等同于conv(y,Hd.Numerator)</span><br><span class="line"></span><br><span class="line">DrawFFT(y,Fs); % 自定义函数用于画频谱</span><br><span class="line">DrawFFT(X,Fs);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Hd = getFilter</span><br><span class="line">%GETFILTER Returns a discrete-time filter object.</span><br><span class="line"></span><br><span class="line">% MATLAB Code</span><br><span class="line">% Generated by MATLAB(R) 9.4 and DSP System Toolbox 9.6.</span><br><span class="line">% Generated on: 11-Aug-2018 21:15:57</span><br><span class="line"></span><br><span class="line">Fpass = 2500;  % Passband Frequency</span><br><span class="line">Fstop = 3000;  % Stopband Frequency</span><br><span class="line">Apass = 1;     % Passband Ripple (dB)</span><br><span class="line">Astop = 60;    % Stopband Attenuation (dB)</span><br><span class="line">Fs    = 8192;  % Sampling Frequency</span><br><span class="line"></span><br><span class="line">h = fdesign.lowpass( &apos;fp,fst,ap,ast &apos;, Fpass, Fstop, Apass, Astop, Fs);</span><br><span class="line"></span><br><span class="line">Hd = design(h,  &apos;equiripple &apos;, ...</span><br><span class="line">     &apos;MinOrder &apos;,  &apos;any &apos;, ...</span><br><span class="line">     &apos;StopbandShape &apos;,  &apos;flat &apos;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function [  ] = DrawFFT( x, Fs )</span><br><span class="line">% DrawFFT 对输入信号进行快速傅里叶变换</span><br><span class="line">% 输入参数：x ：输入信号；   Fs：采样频率</span><br><span class="line">% by Yang Xiaokang , 2016-02</span><br><span class="line"></span><br><span class="line">L = length(x);</span><br><span class="line"></span><br><span class="line">NFFT = 2^nextpow2(L);          %确定FFT变换的长度</span><br><span class="line">y = fft(x, NFFT)/L;</span><br><span class="line">f = Fs/2*linspace(0,1,NFFT/2+1);%频率向量</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line"></span><br><span class="line">plot(f, 2*abs(y(1:NFFT/2+1)));%绘制频域图像</span><br><span class="line">title( &apos;幅度谱 &apos;);</span><br><span class="line">xlabel( &apos;Frequency (Hz) &apos;);</span><br><span class="line">ylabel( &apos;|y(f)| &apos;);</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% 作者：TaylorSe</span><br><span class="line">% 链接：https://www.zhihu.com/question/46038488/answer/144244073</span><br><span class="line">% 来源：知乎</span><br><span class="line">% 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单说说卷积的作用&quot;&gt;&lt;a href=&quot;#简单说说卷积的作用&quot; class=&quot;headerlink&quot; title=&quot;简单说说卷积的作用&quot;&gt;&lt;/a&gt;简单说说卷积的作用&lt;/h1&gt;&lt;p&gt;卷积是一个耳熟能详的的词，自从我开始学习信号与系统以后，就一直没有离开过它，不过只是把它当成一个运算符号来看待。&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="DSP" scheme="http://greedyhao.cc/tags/DSP/"/>
    
  </entry>
  
  <entry>
    <title>mathjax的基本操作</title>
    <link href="http://greedyhao.cc/2018/08/11/%E5%B7%A5%E4%BD%9C-latex-2018-08-11-mathjax%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://greedyhao.cc/2018/08/11/工作-latex-2018-08-11-mathjax的基本操作/</id>
    <published>2018-08-11T08:04:26.000Z</published>
    <updated>2018-10-21T07:55:12.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mathjax的基本操作"><a href="#mathjax的基本操作" class="headerlink" title="mathjax的基本操作"></a>mathjax的基本操作</h1><p>随着知识难度的加深，对于数学的依赖也不断增加，数学涉及到很多公式，老是用截图的方法总觉得不方便，很早以前就听说了LaTeX，正好博客的主体支持mathjax，就学习一下，拿来使用。</p><a id="more"></a><p>我使用的是VSCode编辑，为了方便编辑，我安装了一个Markdown+Math的插件，这个插件可以渲染LaTeX的公式，打开预览就可以实时查看自己文章的效果。</p><h2 id="可参考资料"><a href="#可参考资料" class="headerlink" title="可参考资料"></a>可参考资料</h2><ul><li><a href="https://pic.plover.com/MISC/symbols.pdf" target="_blank" rel="noopener">this shorter listing</a></li><li><a href="https://artofproblemsolving.com/wiki/index.php/LaTeX:Symbols" target="_blank" rel="noopener">LaTeX:Symbols</a></li><li><a href="https://blog.csdn.net/bendanban/article/details/44221279" target="_blank" rel="noopener">使用LaTeX写矩阵</a></li></ul><h2 id="实现分段函数"><a href="#实现分段函数" class="headerlink" title="实现分段函数"></a>实现分段函数</h2><p>这是我在网上搜索到的一个人总结的<strong>分段函数的写法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$ 函数名=\begin&#123;cases&#125;</span><br><span class="line">公式1 &amp; 条件1 \\</span><br><span class="line">公式2 &amp; 条件2 \\</span><br><span class="line">公式3 &amp; 条件3 </span><br><span class="line">\end&#123;cases&#125;$$</span><br></pre></td></tr></table></figure><p><strong>&amp;表示对齐，\用来表示换行</strong></p><p>一个通带为$\omega_c\lt\pi$的理想低通滤波器的系统函数的示例如下</p><p>$$<br>H_d(e^{j\omega})=\begin{cases}<br>1\cdotp e^{j\alpha\omega} &amp; |\omega|\le\omega_e \\<br>0 &amp; \omega_e\lt\pi<br>\end{cases}<br>$$</p><h2 id="公式推导过程"><a href="#公式推导过程" class="headerlink" title="公式推导过程"></a>公式推导过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin &#123;aligned&#125;</span><br><span class="line">A&amp;=B \\</span><br><span class="line">&amp;=C \\</span><br><span class="line">&amp;=D</span><br><span class="line">\end &#123;aligned&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>$$<br>\begin {aligned}<br>A&amp;=B \\<br>&amp;=C \\<br>&amp;=D<br>\end {aligned}<br>$$</p><h2 id="并排显示两个公式"><a href="#并排显示两个公式" class="headerlink" title="并排显示两个公式"></a>并排显示两个公式</h2><p>可以使用\quad \qquad ~~ ~~~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">h(n)=\begin&#123;cases&#125;</span><br><span class="line">h_d(n) &amp; 0\le n\le M-1 \\</span><br><span class="line">0 &amp; elsewhere </span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">~~</span><br><span class="line">and</span><br><span class="line">~~</span><br><span class="line">\alpha = \frac&#123;M-1&#125;&#123;2&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>$$<br>h(n)=\begin{cases}<br>h_d(n) &amp; 0\le n\le M-1 \\<br>0 &amp; elsewhere<br>\end{cases}<br>~~<br>and<br>~~<br>\alpha = \frac{M-1}{2}<br>$$</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mathjax的基本操作&quot;&gt;&lt;a href=&quot;#mathjax的基本操作&quot; class=&quot;headerlink&quot; title=&quot;mathjax的基本操作&quot;&gt;&lt;/a&gt;mathjax的基本操作&lt;/h1&gt;&lt;p&gt;随着知识难度的加深，对于数学的依赖也不断增加，数学涉及到很多公式，老是用截图的方法总觉得不方便，很早以前就听说了LaTeX，正好博客的主体支持mathjax，就学习一下，拿来使用。&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="latex" scheme="http://greedyhao.cc/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>通信原理学习记录（一）</title>
    <link href="http://greedyhao.cc/2018/08/08/%E5%B7%A5%E4%BD%9C-wireless-2018-08-08-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://greedyhao.cc/2018/08/08/工作-wireless-2018-08-08-通信原理学习记录（一）/</id>
    <published>2018-08-08T09:34:52.000Z</published>
    <updated>2018-09-09T05:52:39.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通信原理学习记录（一）"><a href="#通信原理学习记录（一）" class="headerlink" title="通信原理学习记录（一）"></a>通信原理学习记录（一）</h1><p>今天刚刚开始学习通信原理，了解了通信原理的知识点，大概是要学习模拟通信与数字通信，模拟通信技术在之前的高频学习中已经有了一定的基础了，对一些调制技术有了一定的认识和分析能力，因此，本学习的通信原理主要的难度在于数字通信技术。</p><a id="more"></a><p>为了更好的学习通信原理，提前学习是个不错的选择，在<a href="http://www.icourse163.org/learn/NUDT-316006?tid=1002694004&amp;from=study#/learn/content" target="_blank" rel="noopener">MOOC上有个通信原理的课程</a>，阅读原文提供传送门。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wireless/wireless_overview.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一开始学习遇到了两个新的知识点：<strong>信息及其度量</strong>和<strong>通信系统主要性能指标</strong></p><h1 id="信息及其度量"><a href="#信息及其度量" class="headerlink" title="信息及其度量"></a><a href="#信息及其度量"></a>信息及其度量</h1><p>学过概率论的我们知道，事件的不确定程度可以用其出现的概率来描述。因此，消息中包含的信息量与消息发生的概率有关。消息出现的概率越小，蕴含的信息量越大。</p><p>使用$P(x)$表示消息发生的概率，$I$表示消息中的信息量</p><p>$$<br>I = log_a\frac{1}{P(x)} = -log_aP(x)<br>$$</p><p>通常使用单位为比特，公式可以简写为</p><p>$$<br>I = log_2\frac{1}{P(x)} = -log_2P(x)<br>$$</p><p>这种方法是使用算术平均的方法计算，还有另外一种是使用熵的概念计算</p><p>$$<br>H(x) = -\sum_{i=1}^M P(x_i) log_2 P(x_i)<br>$$</p><p>对于较多消息的信息量的计算选择熵的方式更好，因为使用熵的方式计算信息量更加准确，而且也更加方便。</p><p><strong>对信息度量的思考：</strong></p><p>我总感觉信息度量与密码学之间存在着联系，最简单的密码是通过查表实现的，比如将所有字母位置移1个位置，如A加1变换为B。</p><p>现在拥有一份这样加密的密文，统计发现其中某一个字母的出现次数最少，那么它拥有的信息量就最大，是不是就可以通过从这一个字母入手破解全篇的密文。</p><p>当然，这只是我的猜测而已，目前还并没有学习密码学的相关知识，在网上搜信息度量与密码学的关系也没搜出什么，估计也是我搜索的姿势不对。</p><h1 id="通信系统主要性能指标"><a href="#通信系统主要性能指标" class="headerlink" title="通信系统主要性能指标"></a><a href="#通信系统主要性能指标"></a>通信系统主要性能指标</h1><p>主要性能指标与<strong>有效性</strong>和<strong>可靠性</strong>有关</p><h2 id="有效性"><a href="#有效性" class="headerlink" title="有效性"></a><a href="#有效性"></a>有效性</h2><p>有效性的衡量与频带利用率有关</p><p>对于数字通信系统，频带利用率的定义为单位带宽内的传输速率</p><p>$$<br>\eta = \frac{R_B}{B} \ (Baud/Hz)<br>~~<br>or<br>~~<br>\eta_b = \frac{R_b}{B} \ (b/(s\cdot Hz))<br>$$</p><p>其中$R_B$为码元传输速率，又称波特率。$R_b$为信息传输速率，又称比特率。</p><p><em>ps: 突然看到波特率也是很兴奋的，学习串口通信那么久，终于看到了波特率的身影了；还有比特率也是好久以前听说的</em></p><p>码元速率与信息速率有以下关系</p><p>$$<br>R_b = R_B log_2 M \ (b/s)<br>$$</p><p>其中的M表示进制。例如，设码元速率为1200Baud，若采用八进制，则信息速率为3600b/s</p><p><em>ps:之前一直不知道MCU的串口通信中的波特率为什么越高，传输速度越快，现在终于知道了</em></p><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a><a href="#可靠性"></a>可靠性</h2><p>模拟通信系统的可靠性场用接收端输出信号与噪声功率比(S/N)来度量</p><p>数字通信系统的可靠性用差错概率来衡量。差错概率常用误码率和误信率表示。</p><p>误码率$P_e$为错误码元数与传输总码元数之比</p><p>误信率$P_b$为错误比特数与传输总比特数之比</p><hr><p>参考书籍：</p><ul><li>《通信原理》樊昌信第七版</li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;通信原理学习记录（一）&quot;&gt;&lt;a href=&quot;#通信原理学习记录（一）&quot; class=&quot;headerlink&quot; title=&quot;通信原理学习记录（一）&quot;&gt;&lt;/a&gt;通信原理学习记录（一）&lt;/h1&gt;&lt;p&gt;今天刚刚开始学习通信原理，了解了通信原理的知识点，大概是要学习模拟通信与数字通信，模拟通信技术在之前的高频学习中已经有了一定的基础了，对一些调制技术有了一定的认识和分析能力，因此，本学习的通信原理主要的难度在于数字通信技术。&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="wireless" scheme="http://greedyhao.cc/tags/wireless/"/>
    
  </entry>
  
  <entry>
    <title>LCD-TFT控制总结</title>
    <link href="http://greedyhao.cc/2018/07/31/%E5%B7%A5%E4%BD%9C-stm32-2018-07-31-LCD-TFT%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://greedyhao.cc/2018/07/31/工作-stm32-2018-07-31-LCD-TFT控制总结/</id>
    <published>2018-07-31T09:09:26.000Z</published>
    <updated>2018-09-09T05:52:27.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LCD-TFT控制总结"><a href="#LCD-TFT控制总结" class="headerlink" title="LCD-TFT控制总结"></a>LCD-TFT控制总结</h1><p>最近学到LCD了，但是在将野火的代码转移到CubeMX时却遇到了大麻烦，屏幕一直是花的，只有一次正常显示一下下，但是过一段时间就又没了，好几天的时间都找不到问题。</p><a id="more"></a><h1 id="说说如何找到问题的"><a href="#说说如何找到问题的" class="headerlink" title="说说如何找到问题的"></a>说说如何找到问题的</h1><p>找到问题的方法是我昨天才想到的，前些天就像无头苍蝇一样到处乱窜，花了很多时间，但是没有用对方法，都是无用功。</p><p>后来想到，LCD使用SDRAM最为显存，那么只需要读取SDRAM中的数据就知道为什么显示会有问题了。</p><p>通过访问SDRAM中的显存的地址，就可以直接得到SDRAM中的数据。</p><p>首先测试清屏函数，读取SDRAM中的数据在清屏前和清屏后的数据有什么不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%s\n&quot;,&quot;-----D000 after clear-----&quot;);</span><br><span class="line">uint32_t i;</span><br><span class="line">uint8_t ubReaddata_8b=0;</span><br><span class="line">for (i=0; i&lt;200; i++) &#123;</span><br><span class="line">  ubReaddata_8b = *(__IO uint8_t*)(0xD0000000 + i);</span><br><span class="line">  printf(&quot;%x &quot;,ubReaddata_8b);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n%s\n&quot;,&quot;-----D000 after clear-----&quot;);</span><br><span class="line">printf(&quot;%s\n&quot;,&quot;-----D020 after clear-----&quot;);</span><br><span class="line">for (i=0; i&lt;200; i++) &#123;</span><br><span class="line">  ubReaddata_8b = *(__IO uint8_t*)(0xD0200000 + i);</span><br><span class="line">  printf(&quot;%x &quot;,ubReaddata_8b);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n%s\n&quot;,&quot;-----D020 after clear-----&quot;);</span><br></pre></td></tr></table></figure><p>发现清屏前后数据没有变化，都是一些随机的数据，因此可以推断清屏函数出了问题。</p><p>再看看清屏函数(LCD_Clear)，调用了另外一个函数，可以推断应该是<strong>LL_FillBuffer</strong>这个函数出了问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void LL_FillBuffer(uint32_t LayerIndex, void *pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t ColorIndex)</span><br></pre></td></tr></table></figure><p>之前使用的DMA2D的R2M模式，我使用M2M模式显示图片发现正常，方法参照<a href="http://www.waveshare.net/study/article-661-1.html" target="_blank" rel="noopener">微雪课堂</a>，再次确认<strong>LL_FillBuffer</strong>这个函数出了问题。</p><p>看看<strong>LL_FillBuffer</strong>这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LL_FillBuffer</span><span class="params">(<span class="keyword">uint32_t</span> LayerIndex, <span class="keyword">void</span> *pDst, <span class="keyword">uint32_t</span> xSize, <span class="keyword">uint32_t</span> ySize, <span class="keyword">uint32_t</span> OffLine, <span class="keyword">uint32_t</span> ColorIndex)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Dma2d_Handler.Init.Mode         = DMA2D_R2M;</span><br><span class="line">  <span class="keyword">if</span>(Ltdc_Handler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)</span><br><span class="line">  &#123; </span><br><span class="line">    Dma2d_Handler.Init.ColorMode    = DMA2D_RGB565;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(Ltdc_Handler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* DMA2D 初始化 */</span></span><br><span class="line">  <span class="keyword">if</span>(HAL_DMA2D_Init(&amp;Dma2d_Handler) == HAL_OK) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(HAL_DMA2D_ConfigLayer(&amp;Dma2d_Handler, LayerIndex) == HAL_OK) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (HAL_DMA2D_Start(&amp;Dma2d_Handler, ColorIndex, (<span class="keyword">uint32_t</span>)pDst, xSize, ySize) == HAL_OK)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* DMA轮询传输 */</span>  </span><br><span class="line">        HAL_DMA2D_PollForTransfer(&amp;Dma2d_Handler, <span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它这里操作的是<strong>Dma2d_Handler</strong>这个结构体，但是我用CubeMX生成代码使用的是<strong>hdma2d</strong>这个结构体，再我将<strong>Dma2d_Handler</strong>替换为<strong>hdma2d</strong>后，程序运行正常。</p><h1 id="简单介绍一下LCD使用到的外设资源"><a href="#简单介绍一下LCD使用到的外设资源" class="headerlink" title="简单介绍一下LCD使用到的外设资源"></a>简单介绍一下LCD使用到的外设资源</h1><h2 id="LTDC"><a href="#LTDC" class="headerlink" title="LTDC"></a>LTDC</h2><p>液晶面板的信号线如下</p><table><thead><tr><th>信号名称</th><th>说明</th></tr></thead><tbody><tr><td>R[7:0]</td><td>红色数据</td></tr><tr><td>G[7:0]</td><td>绿色数据</td></tr><tr><td>B[7:0]</td><td>蓝色数据</td></tr><tr><td>CLK</td><td>像素同步时钟信号</td></tr><tr><td>HSYNC</td><td>水平同步信号</td></tr><tr><td>VSYNC</td><td>垂直同步信号</td></tr><tr><td>DE</td><td>数据使能信号</td></tr></tbody></table><p>LTDC作为液晶控制器可以使用SDRAM中的部分空间作为显存，直接控制液晶面板。</p><p>我们需要做的就是参考液晶屏的资料，将液晶屏的像素、控制时序等对LTDC进行初始化，LTDC就会自动对液晶屏进行刷新控制。</p><h2 id="DMA2D"><a href="#DMA2D" class="headerlink" title="DMA2D"></a>DMA2D</h2><p>DMA2D用于图像数据搬运、混合及格式转换</p><p>有四种模式：DMA2D_M2M、DMA2D_M2M_PFC、DMA2D_M2M_BLEND、DMA2D_R2M</p><p>暂时只用过M2M和R2M，觉得M2M最好用了，将图片转为数组，开启存储器到存储器的DMA，通过<strong>HAL_DMA2D_Start_IT</strong>传输就好了。</p><h2 id="FMC"><a href="#FMC" class="headerlink" title="FMC"></a>FMC</h2><p>FMC用于操作SDRAM，通过不断刷新SDRAM保证数据的正确性</p><hr><p>代码已上传<a href="https://github.com/greedyhao/stm32/tree/master/LCD" target="_blank" rel="noopener">github</a></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/wechat_official_accounts.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LCD-TFT控制总结&quot;&gt;&lt;a href=&quot;#LCD-TFT控制总结&quot; class=&quot;headerlink&quot; title=&quot;LCD-TFT控制总结&quot;&gt;&lt;/a&gt;LCD-TFT控制总结&lt;/h1&gt;&lt;p&gt;最近学到LCD了，但是在将野火的代码转移到CubeMX时却遇到了大麻烦，屏幕一直是花的，只有一次正常显示一下下，但是过一段时间就又没了，好几天的时间都找不到问题。&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://greedyhao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="stm32" scheme="http://greedyhao.cc/tags/stm32/"/>
    
  </entry>
  
</feed>
