{"meta":{"title":"Zhuhao's Blog","subtitle":"I am the captain of my ship and the master of my fate.","description":"linux,c,python,stm32","author":"Greedyhao","url":"http://greedyhao.cc"},"pages":[{"title":"","date":"2018-09-09T05:40:48.401Z","updated":"2018-08-24T12:37:09.000Z","comments":true,"path":"baidu_verify_eTysJsy3d2.html","permalink":"http://greedyhao.cc/baidu_verify_eTysJsy3d2.html","excerpt":"","text":"window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-104674648-1', 'auto'); ga('send', 'pageview'); var _hmt = _hmt || [] Zhuhao&#39;s Blog | I am the captain of my ship and the master of my fate. window.lazyScripts=[] 朱浩 hao_kr@163.com 主页 Archives Tags Categories Github eTysJsy3d2 赏 var GUEST_INFO = ['nick','mail','link']; var guest_info = 'nick,mail,link'.split(',').filter(function(item){ return GUEST_INFO.indexOf(item) > -1 }); new Valine({ el: '#comments', notify: 'true' == 'true', verify: 'true' == 'true', appId: \"QLtg0UrgJXrcQEBk4lTVRXPL-gzGzoHsz\", appKey: \"N5v4wlBlbrOoQnqwkkBvBc1g\", avatar: \"mm\", placeholder: \"在这里输入评论，可选择输入名字、邮箱...\", guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info, pageSize: \"10\" }) 谢谢大爷~ 微信 支付宝 站点总访客数： 站点总访问量： 博客内容遵循 知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议 朱浩 &copy; 2017 - 2018 Power by Hexo Theme indigo Hosted by Coding Pages 扫一扫，分享到微信 var BLOG = { ROOT: '/', SHARE: true, REWARD: true }; {title} {tags} {date} MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] } }); MathJax.Hub.Queue(function() { var all = MathJax.Hub.getAllJax(), i; for(i=0; i < all.length; i += 1) { all[i].SourceElement().parentNode.className += ' has-jax'; } }); (function() { var OriginTitile = document.title, titleTime; document.addEventListener('visibilitychange', function() { if (document.hidden) { document.title = '您有新消息...'; clearTimeout(titleTime); } else { document.title = '新消息就是我(#^.^#)'; titleTime = setTimeout(function() { document.title = OriginTitile; },2000); } }); })();"},{"title":"categories","date":"2017-08-13T16:01:30.000Z","updated":"2017-08-14T00:57:19.000Z","comments":false,"path":"categories/index.html","permalink":"http://greedyhao.cc/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-08-13T16:01:21.000Z","updated":"2017-08-14T00:57:27.000Z","comments":false,"path":"tags/index.html","permalink":"http://greedyhao.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"处理器在运行c代码前做了什么准备","slug":"处理器在运行c代码前做了什么准备","date":"2018-09-13T01:56:04.000Z","updated":"2018-09-13T02:03:30.346Z","comments":true,"path":"2018/09/13/处理器在运行c代码前做了什么准备/","link":"","permalink":"http://greedyhao.cc/2018/09/13/处理器在运行c代码前做了什么准备/","excerpt":"众所周知，c代码也是一种比较高级的语言了，机器是没有办法直接运行的，机器所能理解的只有机器码--那一串0和1而已。","text":"众所周知，c代码也是一种比较高级的语言了，机器是没有办法直接运行的，机器所能理解的只有机器码--那一串0和1而已。 虽然早就知道c代码是先经过编译链接最后才放在机器上执行，但是在这么一个过程中究竟发生了什么，最近在学习嵌入式裸机开发中，才又有了更深入的了解。 简单描述一下生成机器代码过程 编译过程 编译过程是以前就知道了的，预编译会对一些带#号的预编译命令处理，如#define等，编译器会对他们进行替换得到.i文件，然后进一步编译得到.o文件。 链接过程 在将源文件编译成可执行文件时，有一个过程是链接。 其实我以前就对这个链接过程感觉有些不解的，这个链接过程到底是怎么把这些.o文件链接在一起，是有一种什么样的规则呢，总不可能随便链接的吧，随便链接的话怎么解决依赖问题。 直到之前了解了一下alios系统，在学习的过程中发现，在芯片架构的支持中，有一个elf文件，里面定义了一些地址，当时还不知道有什么用；最近学习裸机开发中，也遇到了这么一个类似的lds文件。 通过学习，才知道，原来这种文件定义了各个段如代码段、数据段等的地址，这样编译器在链接的过程中，就知道了要把各种.o文件以什么样的顺序链接，链接在什么地址处。 准备c语言运行环境 这是我在网上找的图，从图中可以看出，为了使c程序可以执行在目标处理器，链接的过程中，还混入了一些其他的东西，比如Startup Code。 在Startup Code中，会做一系列的事，比如关中断、重定位、申请栈空间等等，具体过程和硬件相关。 最后跳转到main()。 网上有一篇基于ARM介绍这些相关知识的，非常建议去看看，可以解决自己以前嵌入式编程的很多疑惑。 http://www.bravegnu.org/gnu-eprog/c-startup.html 篇外话 这篇博文是在接触到了一些启动代码后突然有的想法，就开始整理自己的思路，写的同时，在谷歌上查找自己疑惑的地方，从runtime environment查到startup code，结果发现自己疑惑的地方却更多了(⊙o⊙) 非常建议看看下面给出的参考资料，相信对初学者会有很大帮助。 参考资料 C Startup Microchip Developer Help Flow of Startup code in an embedded system , concept of boot loader? C 如何编译出一个不需要操作系统的程序？","categories":[],"tags":[{"name":"x210","slug":"x210","permalink":"http://greedyhao.cc/tags/x210/"}]},{"title":"Vivado无法连接到开发板","slug":"工作-fpga-2018-09-12-Vivado无法连接到开发板","date":"2018-09-12T03:09:48.000Z","updated":"2018-09-12T03:12:52.983Z","comments":true,"path":"2018/09/12/工作-fpga-2018-09-12-Vivado无法连接到开发板/","link":"","permalink":"http://greedyhao.cc/2018/09/12/工作-fpga-2018-09-12-Vivado无法连接到开发板/","excerpt":"","text":"从咸鱼上淘了一块二手的ZYBO来玩，因为出了新版开发板ZYBO-Z7，所以旧版的还是比较便宜，才600来块 在使用Hardware Manage的auto connect连接开发板的时候发现，无论开发板是使用QSPI还是JTAG模式，都无法连接到电脑 参考自Vivado 2015.2 Cable driver installation problem 发现我缺少了驱动的安装 步骤如下： 12cd &lt;Vivado installation dir&gt;/data/xicom/cable_drivers/lin64/install_script/install_drivers/./install_drivers 下面是我的输出结果，不知道为什么有个CRITICAL WARNING，暂时没有找到解决方法，也没有遇见问题 12345678910111213141516171819202122greedyhao@greedyhao-HP-Pavilion-Notebook:/usr/local/Xilinx/Vivado/2018.2/data/xicom/cable_drivers/lin64/install_script/install_drivers$ sudo ./install_drivers [sudo] greedyhao 的密码： INFO: Installing cable drivers.INFO: Script name = ./install_driversINFO: HostName = greedyhao-HP-Pavilion-NotebookINFO: Current working dir = /usr/local/Xilinx/Vivado/2018.2/data/xicom/cable_drivers/lin64/install_script/install_driversINFO: Kernel version = 4.15.0-34-generic.INFO: Arch = x86_64.Successfully installed Digilent Cable Drivers--File /etc/udev/rules.d/52-xilinx-ftdi-usb.rules does not exist.--File version of /etc/udev/rules.d/52-xilinx-ftdi-usb.rules = 0000.--Updating rules file.--File /etc/udev/rules.d/52-xilinx-pcusb.rules does not exist.--File version of /etc/udev/rules.d/52-xilinx-pcusb.rules = 0000.--Updating rules file.INFO: Digilent Return code = 0INFO: Xilinx Return code = 0INFO: Xilinx FTDI Return code = 0INFO: Return code = 0INFO: Driver installation successful.CRITICAL WARNING: Cable(s) on the system must be unplugged then plugged back in order for the driver scripts to update the cables. 参考资料 + ug973-vivado-release-notes-install-license","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://greedyhao.cc/tags/FPGA/"},{"name":"Xilinx","slug":"Xilinx","permalink":"http://greedyhao.cc/tags/Xilinx/"}]},{"title":"Vivado启动遇见QSslSocket系列问题","slug":"工作-fpga-2018-09-12-Vivado启动遇见QSslSocket系列问题","date":"2018-09-12T02:34:11.000Z","updated":"2018-09-12T02:57:19.601Z","comments":true,"path":"2018/09/12/工作-fpga-2018-09-12-Vivado启动遇见QSslSocket系列问题/","link":"","permalink":"http://greedyhao.cc/2018/09/12/工作-fpga-2018-09-12-Vivado启动遇见QSslSocket系列问题/","excerpt":"","text":"12345678910111213141516greedyhao@greedyhao-HP-Pavilion-Notebook:~$ vivado****** Vivado v2018.2 (64-bit) **** SW Build 2258646 on Thu Jun 14 20:02:38 MDT 2018 **** IP Build 2256618 on Thu Jun 14 22:10:49 MDT 2018 ** Copyright 1986-2018 Xilinx, Inc. All Rights Reserved.start_guiQSslSocket: cannot resolve CRYPTO_num_locksQSslSocket: cannot resolve CRYPTO_set_id_callbackQSslSocket: cannot resolve CRYPTO_set_locking_callbackQSslSocket: cannot resolve sk_freeQSslSocket: cannot resolve sk_numQSslSocket: cannot resolve sk_pop_free... 我发现我每次启动vivado时，都会弹出这些错误信息，而且Hardware Manage的auto connect无法识别我的开发板ZYBO，就想着先解决这些报错信息。 解决方法来自QSslSocket: cannot resolve SSLv3_client_method / SSLv3_server_method 原文是这么说的 For Debian Stretch users and others with the QSslSocket: cannot resolve $func issue, you just need to install the package libssl1.0-dev (or similar package in your distro). 打开终端 1sudo apt install libssl1.0-dev 安装完成后就会发现，不会再有报错信息出现了。","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://greedyhao.cc/tags/FPGA/"},{"name":"Xilinx","slug":"Xilinx","permalink":"http://greedyhao.cc/tags/Xilinx/"}]},{"title":"如何使用matlab进行频域分析","slug":"工作-dsp-2018-08-24-如何使用matlab进行频域分析","date":"2018-08-24T11:33:08.000Z","updated":"2018-09-09T05:47:24.647Z","comments":true,"path":"2018/08/24/工作-dsp-2018-08-24-如何使用matlab进行频域分析/","link":"","permalink":"http://greedyhao.cc/2018/08/24/工作-dsp-2018-08-24-如何使用matlab进行频域分析/","excerpt":"如何使用matlab进行频域分析 Matlab可以说是一个非常有用且功能齐全的工具，在通信、自控、金融等方面有广泛的应用。 本文讨论使用Matlab对信号进行频域分析的方法。","text":"如何使用matlab进行频域分析 Matlab可以说是一个非常有用且功能齐全的工具，在通信、自控、金融等方面有广泛的应用。 本文讨论使用Matlab对信号进行频域分析的方法。 说到频域，不可避免的会提到傅里叶变换，傅里叶变换提供了一个将信号从时域转变到频域的方法。之所以要有信号的频域分析，是因为很多信号在时域不明显的特征可以在频域下得到很好的展现，可以更加容易的进行分析和处理。 FFT Matlab提供的傅里叶变换的函数是FFT，中文名叫做快速傅里叶变换。快速傅里叶变换的提出是伟大的，使得处理器处理数字信号的能力大大提升，也使我们生活向数字化迈了一大步。 接下来就谈谈如何使用这个函数。 fft使用很简单，但是一般信号都有x和y两个向量，而fft只会处理y向量，所以想让频域分析变得有意义，那么就需要用户自己处理x向量 一个简单的例子 从一个简单正弦信号开始吧，正弦信号定义为： \\[ y(t) = 2\\sin (2\\pi f_0 t) \\] 我们现在通过以下代码在Matlab中画出这个正弦曲线 1234567891011121314fo = 4; %frequency of the sine waveFs = 100; %sampling rateTs = 1/Fs; %sampling time intervalt = 0:Ts:1-Ts; %sampling periodn = length(t); %number of samplesy = 2*sin(2*pi*fo*t); %the sine curve %plot the cosine curve in the time domainsinePlot = figure;plot(t,y)xlabel(&apos;time (seconds)&apos;)ylabel(&apos;y(t)&apos;)title(&apos;Sample Sine Wave&apos;)grid 这就是我们得到的： 当我们对这条曲线fft时，我们希望在频域得到以下频谱（基于傅里叶变换理论，我们希望看见一个幅值为1的峰值在-4Hz处，另一个在+4Hz处） 使用FFT命令 我们知道目标是什么了，那么现在使用Matlab的内建的FFT函数来重新生成频谱 12345678910111213%plot the frequency spectrum using the MATLAB fft commandmatlabFFT = figure; %create a new figureYfreqDomain = fft(y); %take the fft of our sin wave, y(t)stem(abs(YfreqDomain)); %use abs command to get the magnitude%similary, we would use angle command to get the phase plot!%we&apos;ll discuss phase in another post though!xlabel(&apos;Sample Number&apos;)ylabel(&apos;Amplitude&apos;)title(&apos;Using the Matlab fft command&apos;)gridaxis([0,100,0,120]) 效果如下： 但是注意一下，这并不是我们真正想要的，有一些信息是缺失的 x轴本来应该给我们提供频率信息，但是你能读出频率吗？ 幅度都是100 没有让频谱中心为0 为FFT定义一个函数来获取双边频谱 以下代码可以简化获取双边频谱的过程，复制并保存到你的.m文件中 12345678910111213141516function [X,freq]=centeredFFT(x,Fs)%this is a custom function that helps in plotting the two-sided spectrum%x is the signal that is to be transformed%Fs is the sampling rateN=length(x);%this part of the code generates that frequency axisif mod(N,2)==0 k=-N/2:N/2-1; % N evenelse k=-(N-1)/2:(N-1)/2; % N oddendT=N/Fs;freq=k/T; %the frequency axis%takes the fft of the signal, and adjusts the amplitude accordinglyX=fft(x)/N; % normalize the dataX=fftshift(X); %shifts the fft data so that it is centered 这个函数输出正确的频域范围和变换后的信号，它需要输入需要变换的信号和采样率。 接下来使用前文的正弦信号做一个简单的示例，注意你的示例.m文件要和centeredFFT.m文件在一个目录下 123456789[YfreqDomain,frequencyRange] = centeredFFT(y,Fs);centeredFFT = figure;%remember to take the abs of YfreqDomain to get the magnitude!stem(frequencyRange,abs(YfreqDomain));xlabel('Freq (Hz)')ylabel('Amplitude')title('Using the centeredFFT function')gridaxis([-6,6,0,1.5]) 效果如下： 这张图就满足了我们的需求,我们得到了在+4和-4处的峰值，而且幅值为1. 为FFT定义一个函数来获取右边频谱 从上图可以看出，FFT变换得到的频谱是左右对称的，因此，我们只需要其中一边就能获得信号的所有信息，我们一般保留正频率一侧。 以下的函数对上面的自定义函数做了一些修改，让它可以帮助我们只画出信号的正频率一侧 1234567891011function [X,freq]=positiveFFT(x,Fs)N=length(x); %get the number of pointsk=0:N-1; %create a vector from 0 to N-1T=N/Fs; %get the frequency intervalfreq=k/T; %create the frequency rangeX=fft(x)/N; % normalize the data%only want the first half of the FFT, since it is redundantcutOff = ceil(N/2);%take only the first half of the spectrumX = X(1:cutOff);freq = freq(1:cutOff); 和前面一样，使用正弦信号做一个示例，下面是示例代码 123456789[YfreqDomain,frequencyRange] = positiveFFT(y,Fs);positiveFFT = figure;stem(frequencyRange,abs(YfreqDomain));set(positiveFFT,'Position',[500,500,500,300])xlabel('Freq (Hz)')ylabel('Amplitude')title('Using the positiveFFT function')gridaxis([0,20,0,1.5]) 效果如下： 本文内容主要来自Matlab官方FFT教程，但是我找不到原链接了，就把我电脑上的文件上传到了百度云盘，公众号后台回复 下载|FFT_tutorial 获取下载链接","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"dsp","slug":"dsp","permalink":"http://greedyhao.cc/tags/dsp/"}]},{"title":"简单说说卷积的作用","slug":"工作-dsp-2018-08-12-简单说说卷积的作用","date":"2018-08-11T22:53:32.000Z","updated":"2018-09-09T05:49:18.867Z","comments":true,"path":"2018/08/12/工作-dsp-2018-08-12-简单说说卷积的作用/","link":"","permalink":"http://greedyhao.cc/2018/08/12/工作-dsp-2018-08-12-简单说说卷积的作用/","excerpt":"简单说说卷积的作用 卷积是一个耳熟能详的的词，自从我开始学习信号与系统以后，就一直没有离开过它，不过只是把它当成一个运算符号来看待。","text":"简单说说卷积的作用 卷积是一个耳熟能详的的词，自从我开始学习信号与系统以后，就一直没有离开过它，不过只是把它当成一个运算符号来看待。 不过闲着的时候，也会去想，卷积到底有什么作用。 提供一种方便的频域处理方式 时域卷积频域相乘 这条法则想必大家都知道，作用非常大，可以轻松的对信号的频域做处理 简单的应用就是频域滤波 \\[ g(x) = \\mathscr{F}^{-1}\\left[H(x)F(x)\\right] \\] F(x)代表输入信号，H(x)代表滤波函数，g(x)代表滤波（输出）信号。 转换到时域则是 \\[ g(x) = h(x) \\ast f(x) \\] 以下是一个声音信号处理的例子，给matlab自带鸟叫声加了一个低通滤波器。 效果如下： 滤波前： 滤波后： 12345678% 主函数close all;load chirp;Hd = getFilter; % 使用Filter Builder设计的FIRX = filter(Hd,y); % 等同于conv(y,Hd.Numerator)DrawFFT(y,Fs); % 自定义函数用于画频谱DrawFFT(X,Fs); 123456789101112131415161718function Hd = getFilter%GETFILTER Returns a discrete-time filter object.% MATLAB Code% Generated by MATLAB(R) 9.4 and DSP System Toolbox 9.6.% Generated on: 11-Aug-2018 21:15:57Fpass = 2500; % Passband FrequencyFstop = 3000; % Stopband FrequencyApass = 1; % Passband Ripple (dB)Astop = 60; % Stopband Attenuation (dB)Fs = 8192; % Sampling Frequencyh = fdesign.lowpass( &apos;fp,fst,ap,ast &apos;, Fpass, Fstop, Apass, Astop, Fs);Hd = design(h, &apos;equiripple &apos;, ... &apos;MinOrder &apos;, &apos;any &apos;, ... &apos;StopbandShape &apos;, &apos;flat &apos;); 123456789101112131415161718192021222324function [ ] = DrawFFT( x, Fs )% DrawFFT 对输入信号进行快速傅里叶变换% 输入参数：x ：输入信号； Fs：采样频率% by Yang Xiaokang , 2016-02L = length(x);NFFT = 2^nextpow2(L); %确定FFT变换的长度y = fft(x, NFFT)/L;f = Fs/2*linspace(0,1,NFFT/2+1); %频率向量figure;plot(f, 2*abs(y(1:NFFT/2+1))); %绘制频域图像title( &apos;幅度谱 &apos;);xlabel( &apos;Frequency (Hz) &apos;);ylabel( &apos;|y(f)| &apos;);end% 作者：TaylorSe% 链接：https://www.zhihu.com/question/46038488/answer/144244073% 来源：知乎% 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"dsp","slug":"dsp","permalink":"http://greedyhao.cc/tags/dsp/"}]},{"title":"mathjax的基本操作","slug":"工作-latex-2018-08-11-mathjax的基本操作","date":"2018-08-11T08:04:26.000Z","updated":"2018-09-09T05:58:19.513Z","comments":true,"path":"2018/08/11/工作-latex-2018-08-11-mathjax的基本操作/","link":"","permalink":"http://greedyhao.cc/2018/08/11/工作-latex-2018-08-11-mathjax的基本操作/","excerpt":"mathjax的基本操作 随着知识难度的加深，对于数学的依赖也不断增加，数学涉及到很多公式，老是用截图的方法总觉得不方便，很早以前就听说了LaTeX，正好博客的主体支持mathjax，就学习一下，拿来使用。","text":"mathjax的基本操作 随着知识难度的加深，对于数学的依赖也不断增加，数学涉及到很多公式，老是用截图的方法总觉得不方便，很早以前就听说了LaTeX，正好博客的主体支持mathjax，就学习一下，拿来使用。 我使用的是VSCode编辑，为了方便编辑，我安装了一个Markdown+Math的插件，这个插件可以渲染LaTeX的公式，打开预览就可以实时查看自己文章的效果。 this shorter listing 实现分段函数 这是我在网上搜索到的一个人总结的分段函数的写法 12345$$ 函数名=\\begin&#123;cases&#125;公式1 &amp; 条件1 \\\\公式2 &amp; 条件2 \\\\公式3 &amp; 条件3 \\end&#123;cases&#125;$$ **&amp;表示对齐，* 一个通带为\\(\\omega_c\\lt\\pi\\)的理想低通滤波器的系统函数的示例如下 \\[ H_d(e^{j\\omega})=\\begin{cases} 1\\cdotp e^{j\\alpha\\omega} &amp; |\\omega|\\le\\omega_e \\\\\\ 0 &amp; \\omega_e\\lt\\pi \\end{cases} \\] 公式推导过程 1234567$$\\begin &#123;aligned&#125;A&amp;=B \\\\&amp;=C \\\\&amp;=D\\end &#123;aligned&#125;$$ 效果如下： \\[ \\begin {aligned} A&amp;=B \\\\\\ &amp;=C \\\\\\ &amp;=D \\end {aligned} \\] 并排显示两个公式 可以使用~~ ~ 12345678910$$h(n)=\\begin&#123;cases&#125;h_d(n) &amp; 0\\le n\\le M-1 \\\\0 &amp; elsewhere \\end&#123;cases&#125;~~and~~\\alpha = \\frac&#123;M-1&#125;&#123;2&#125;$$ 效果如下： \\[ h(n)=\\begin{cases} h_d(n) &amp; 0\\le n\\le M-1 \\\\\\ 0 &amp; elsewhere \\end{cases} ~~ and ~~ \\alpha = \\frac{M-1}{2} \\]","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"latex","slug":"latex","permalink":"http://greedyhao.cc/tags/latex/"}]},{"title":"通信原理学习记录（一）","slug":"工作-wireless-2018-08-08-通信原理学习记录（一）","date":"2018-08-08T09:34:52.000Z","updated":"2018-09-09T05:52:39.288Z","comments":true,"path":"2018/08/08/工作-wireless-2018-08-08-通信原理学习记录（一）/","link":"","permalink":"http://greedyhao.cc/2018/08/08/工作-wireless-2018-08-08-通信原理学习记录（一）/","excerpt":"通信原理学习记录（一） 今天刚刚开始学习通信原理，了解了通信原理的知识点，大概是要学习模拟通信与数字通信，模拟通信技术在之前的高频学习中已经有了一定的基础了，对一些调制技术有了一定的认识和分析能力，因此，本学习的通信原理主要的难度在于数字通信技术。","text":"通信原理学习记录（一） 今天刚刚开始学习通信原理，了解了通信原理的知识点，大概是要学习模拟通信与数字通信，模拟通信技术在之前的高频学习中已经有了一定的基础了，对一些调制技术有了一定的认识和分析能力，因此，本学习的通信原理主要的难度在于数字通信技术。 为了更好的学习通信原理，提前学习是个不错的选择，在MOOC上有个通信原理的课程，阅读原文提供传送门。 一开始学习遇到了两个新的知识点：信息及其度量和通信系统主要性能指标 信息及其度量 学过概率论的我们知道，事件的不确定程度可以用其出现的概率来描述。因此，消息中包含的信息量与消息发生的概率有关。消息出现的概率越小，蕴含的信息量越大。 使用\\(P(x)\\)表示消息发生的概率，\\(I\\)表示消息中的信息量 \\[ I = log_a\\frac{1}{P(x)} = -log_aP(x) \\] 通常使用单位为比特，公式可以简写为 \\[ I = log_2\\frac{1}{P(x)} = -log_2P(x) \\] 这种方法是使用算术平均的方法计算，还有另外一种是使用熵的概念计算 \\[ H(x) = -\\sum_{i=1}^M P(x_i) log_2 P(x_i) \\] 对于较多消息的信息量的计算选择熵的方式更好，因为使用熵的方式计算信息量更加准确，而且也更加方便。 对信息度量的思考： 我总感觉信息度量与密码学之间存在着联系，最简单的密码是通过查表实现的，比如将所有字母位置移1个位置，如A加1变换为B。 现在拥有一份这样加密的密文，统计发现其中某一个字母的出现次数最少，那么它拥有的信息量就最大，是不是就可以通过从这一个字母入手破解全篇的密文。 当然，这只是我的猜测而已，目前还并没有学习密码学的相关知识，在网上搜信息度量与密码学的关系也没搜出什么，估计也是我搜索的姿势不对。 通信系统主要性能指标 主要性能指标与有效性和可靠性有关 有效性 有效性的衡量与频带利用率有关 对于数字通信系统，频带利用率的定义为单位带宽内的传输速率 \\[ \\eta = \\frac{R_B}{B} \\ (Baud/Hz) ~~ or ~~ \\eta_b = \\frac{R_b}{B} \\ (b/(s\\cdot Hz)) \\] 其中\\(R_B\\)为码元传输速率，又称波特率。\\(R_b\\)为信息传输速率，又称比特率。 ps: 突然看到波特率也是很兴奋的，学习串口通信那么久，终于看到了波特率的身影了；还有比特率也是好久以前听说的 码元速率与信息速率有以下关系 \\[ R_b = R_B log_2 M \\ (b/s) \\] 其中的M表示进制。例如，设码元速率为1200Baud，若采用八进制，则信息速率为3600b/s ps:之前一直不知道MCU的串口通信中的波特率为什么越高，传输速度越快，现在终于知道了 可靠性 模拟通信系统的可靠性场用接收端输出信号与噪声功率比(S/N)来度量 数字通信系统的可靠性用差错概率来衡量。差错概率常用误码率和误信率表示。 误码率\\(P_e\\)为错误码元数与传输总码元数之比 误信率\\(P_b\\)为错误比特数与传输总比特数之比 参考书籍： 《通信原理》樊昌信第七版","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"wireless","slug":"wireless","permalink":"http://greedyhao.cc/tags/wireless/"}]},{"title":"LCD-TFT控制总结","slug":"工作-stm32-2018-07-31-LCD-TFT控制总结","date":"2018-07-31T09:09:26.000Z","updated":"2018-09-09T05:52:27.808Z","comments":true,"path":"2018/07/31/工作-stm32-2018-07-31-LCD-TFT控制总结/","link":"","permalink":"http://greedyhao.cc/2018/07/31/工作-stm32-2018-07-31-LCD-TFT控制总结/","excerpt":"LCD-TFT控制总结 最近学到LCD了，但是在将野火的代码转移到CubeMX时却遇到了大麻烦，屏幕一直是花的，只有一次正常显示一下下，但是过一段时间就又没了，好几天的时间都找不到问题。","text":"LCD-TFT控制总结 最近学到LCD了，但是在将野火的代码转移到CubeMX时却遇到了大麻烦，屏幕一直是花的，只有一次正常显示一下下，但是过一段时间就又没了，好几天的时间都找不到问题。 说说如何找到问题的 找到问题的方法是我昨天才想到的，前些天就像无头苍蝇一样到处乱窜，花了很多时间，但是没有用对方法，都是无用功。 后来想到，LCD使用SDRAM最为显存，那么只需要读取SDRAM中的数据就知道为什么显示会有问题了。 通过访问SDRAM中的显存的地址，就可以直接得到SDRAM中的数据。 首先测试清屏函数，读取SDRAM中的数据在清屏前和清屏后的数据有什么不同。 1234567891011121314printf(&quot;%s\\n&quot;,&quot;-----D000 after clear-----&quot;);uint32_t i;uint8_t ubReaddata_8b=0;for (i=0; i&lt;200; i++) &#123; ubReaddata_8b = *(__IO uint8_t*)(0xD0000000 + i); printf(&quot;%x &quot;,ubReaddata_8b);&#125;printf(&quot;\\n%s\\n&quot;,&quot;-----D000 after clear-----&quot;);printf(&quot;%s\\n&quot;,&quot;-----D020 after clear-----&quot;);for (i=0; i&lt;200; i++) &#123; ubReaddata_8b = *(__IO uint8_t*)(0xD0200000 + i); printf(&quot;%x &quot;,ubReaddata_8b);&#125;printf(&quot;\\n%s\\n&quot;,&quot;-----D020 after clear-----&quot;); 发现清屏前后数据没有变化，都是一些随机的数据，因此可以推断清屏函数出了问题。 再看看清屏函数(LCD_Clear)，调用了另外一个函数，可以推断应该是LL_FillBuffer这个函数出了问题。 1static void LL_FillBuffer(uint32_t LayerIndex, void *pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t ColorIndex) 之前使用的DMA2D的R2M模式，我使用M2M模式显示图片发现正常，方法参照微雪课堂，再次确认LL_FillBuffer这个函数出了问题。 看看LL_FillBuffer这个函数 1234567891011121314151617181920212223static void LL_FillBuffer(uint32_t LayerIndex, void *pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t ColorIndex) &#123; Dma2d_Handler.Init.Mode = DMA2D_R2M; if(Ltdc_Handler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565) &#123; Dma2d_Handler.Init.ColorMode = DMA2D_RGB565; &#125; else if(Ltdc_Handler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888) ... /* DMA2D 初始化 */ if(HAL_DMA2D_Init(&amp;Dma2d_Handler) == HAL_OK) &#123; if(HAL_DMA2D_ConfigLayer(&amp;Dma2d_Handler, LayerIndex) == HAL_OK) &#123; if (HAL_DMA2D_Start(&amp;Dma2d_Handler, ColorIndex, (uint32_t)pDst, xSize, ySize) == HAL_OK) &#123; /* DMA轮询传输 */ HAL_DMA2D_PollForTransfer(&amp;Dma2d_Handler, 100); &#125; &#125; &#125; &#125; 它这里操作的是Dma2d_Handler这个结构体，但是我用CubeMX生成代码使用的是hdma2d这个结构体，再我将Dma2d_Handler替换为hdma2d后，程序运行正常。 简单介绍一下LCD使用到的外设资源 LTDC 液晶面板的信号线如下 信号名称 说明 R[7:0] 红色数据 G[7:0] 绿色数据 B[7:0] 蓝色数据 CLK 像素同步时钟信号 HSYNC 水平同步信号 VSYNC 垂直同步信号 DE 数据使能信号 LTDC作为液晶控制器可以使用SDRAM中的部分空间作为显存，直接控制液晶面板。 我们需要做的就是参考液晶屏的资料，将液晶屏的像素、控制时序等对LTDC进行初始化，LTDC就会自动对液晶屏进行刷新控制。 DMA2D DMA2D用于图像数据搬运、混合及格式转换 有四种模式：DMA2D_M2M、DMA2D_M2M_PFC、DMA2D_M2M_BLEND、DMA2D_R2M 暂时只用过M2M和R2M，觉得M2M最好用了，将图片转为数组，开启存储器到存储器的DMA，通过HAL_DMA2D_Start_IT传输就好了。 FMC FMC用于操作SDRAM，通过不断刷新SDRAM保证数据的正确性 代码已上传github","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"几种常见窗函数的特性","slug":"工作-dsp-2018-07-24-几种常见窗函数的特性","date":"2018-07-24T14:55:45.000Z","updated":"2018-09-09T06:11:32.015Z","comments":true,"path":"2018/07/24/工作-dsp-2018-07-24-几种常见窗函数的特性/","link":"","permalink":"http://greedyhao.cc/2018/07/24/工作-dsp-2018-07-24-几种常见窗函数的特性/","excerpt":"几种常见窗函数的特性 解决一下上一篇的遗留问题 上一篇谈了FIR滤波器的加窗是什么，但是自觉得还是有些地方没有说明白，就好比模拟加窗过程都没有讲明白。","text":"几种常见窗函数的特性 解决一下上一篇的遗留问题 上一篇谈了FIR滤波器的加窗是什么，但是自觉得还是有些地方没有说明白，就好比模拟加窗过程都没有讲明白。 不过今天再看书时，又有所得，忽然明白了为什么模拟加窗过程出了问题，这是由于我之前对于数字滤波器的设计过程还很模糊。 窗函数设计法的设计思路： 给定要求的理想频响\\(H_d(e^{j\\omega})\\)，一般为分段常数 转为时域设计，所以需要求出\\(h_d(n)\\) \\[h_d(n) = IDTFT[H_d(e^{j\\omega})]\\] 由于\\(h_d(n)\\)是无限时长的，所以需要加窗截断为\\(h(n)\\)，窗的长度为N 因为窗函数是在时域内截断，所以需要将理想滤波器转换到时域来处理。 \\[h(n) = h_d(n)\\cdotp w(n), \\quad 0\\le n\\le N-1\\] 求出加窗后的实际频响\\(H(e^{j\\omega})\\) \\[H(e^{j\\omega}) = DTFT[h(n)]\\] 检查\\(H(e^{j\\omega})\\)是否满足\\(H_d(e^{j\\omega})\\)，不满足就重复3、4步骤 我使用的子程序是书上提供的，可以产生一个理想滤波器。 今天突然对这个程序有了新的理解。因为这个是子程序产生的时域的滤波器，为了能够在电脑中存储，本来就已经加了一个矩形窗，因此它的频域波形存在波纹；而我又加一个矩形窗，对这个已经加了矩形窗的滤波器当然是一点效果都没有咯。 几种常见窗函数 回到今天的主题，今天探讨一下几种常见滤波器的特性和使用场景。 翻了很多遍书，发现对于滤波器的设计，主要关心的是过渡带宽(Transition bandwidth)、通带边沿衰减(Passband ripple)、阻带最小衰减(Minimum stopband attenuation)，而且大部分的参数都是用dB作单位。 使用dB做单位的好处有： 数值变小。由于分贝是取对数值，所以能很方便的表示大的数量的变化 运算方便。放大器级联时，总的放大倍数是各级相乘。用分贝做单位时，总增益就是相加。 方便感知。人对强度（光照、声音）的感知，接近于于强度的对数的正比。 至于为什么要这么多种窗呢？那是因为不同的窗特性不一样，比如最简单的矩形窗，虽然完成了截断工作，但是通带衰减大、阻带衰减小，导致能量的浪费；而之后的多种窗则或多或少的弥补了这些缺点。 矩形窗 矩形窗的定义为 \\[ w(n) = \\begin{cases} 1, &amp; 0\\le n \\le M-1 \\\\\\ 0, &amp; otherwise \\end{cases} \\] 频率响应函数为 \\[ W(e^{j\\omega}) = W(\\omega)e^{j\\theta(\\omega)} = \\frac{\\sin(\\omega M /2)}{\\sin(\\omega /2)}e^{-j\\frac{N-1}{2}\\omega} \\] 因此 \\[ W(\\omega) = \\frac{\\sin(\\omega M /2)}{\\sin(\\omega /2)} \\] 下面分析窗函数的主要参数： 幅度响应\\(W_r(\\omega)\\)第一个零点在\\(\\omega=\\omega_1\\)， \\[ \\frac{\\omega_1 M}{2} = \\pi ~~ or ~~ \\omega_1 = \\frac{2\\pi}{M} \\] 因此，主瓣宽度为为\\(2\\omega_1 = 4\\pi /M\\)，因此传输带宽近似于\\(4\\pi /M\\) 第一个旁瓣大概在\\(\\omega=3\\pi/M\\)的位置，因此它的幅值为 \\[ \\left| W_r\\left(\\omega = \\frac{3\\pi}{M}\\right)\\right| = \\left|\\frac{\\sin(3\\pi /2)}{\\sin(3\\pi /2M)}\\right| \\simeq \\frac{2M}{3\\pi} \\] 对比主瓣的幅值，旁瓣幅值峰值为 \\[ \\frac{2}{3\\pi} \\approx 21.22\\% \\equiv 13 dB \\] 三角形窗 由于吉布斯现象，矩形窗存在一个0到1的越变；而三角形窗则提供了一个比较缓慢的变化，它的定义式为： \\[ w(n) = \\begin{cases} \\frac{2n}{M-1}, &amp; 0\\le n \\le\\frac{M-1}{2} \\\\\\ 2-\\frac{2n}{M-1}, &amp; \\frac{M-1}{2}\\le n\\le M-1 \\\\\\ 0, &amp; otherwise \\end{cases} \\] 谱密度函数表达式如下，’≈’仅当\\(M\\gg 1\\)时成立 \\[ W(\\omega) \\approx \\frac{2}{M} \\frac{\\sin(M\\omega/4)}{\\sin(\\omega/4)} \\] 主瓣宽度为\\(8\\pi /M\\)，旁瓣峰值衰减为25dB 汉宁窗（Hanning） 这是一个升余弦窗，被定义为 \\[ w(n) = \\begin{cases} 0.5\\left[1-\\cos\\left(\\frac{2\\pi n}{M-1}\\right)\\right] &amp; 0\\le n \\le M-1 \\\\\\ 0 &amp; otherwise \\end{cases} \\] 主瓣宽度为\\(8\\pi /M\\)，旁瓣峰值衰减为31dB 海明窗（Hamming） 海明窗和汉宁窗很像，不同的是它有一部分是不连续的，被定义为 \\[ w(n)= \\begin{cases} 0.54 - 0.46\\cos\\left(\\frac{2\\pi n}{M-1}\\right) &amp; 0\\le n \\le M-1 \\\\\\ 0 &amp; otherwise \\end{cases} \\] 主瓣宽度为\\(8\\pi /M\\)，旁瓣峰值衰减为41d 布莱克曼窗（Blackman） 这个窗函数和前两个窗函数很像，不过增加了升余弦的二次谐波分量，被定义为 \\[ w(n) = \\begin{cases} 0.42 - 0.5\\cos\\left(\\frac{2\\pi n}{M-1}\\right) + 0.08\\cos\\left(\\frac{4\\pi n}{M-1}\\right) &amp; 0\\le n \\le M-1 \\\\\\ 0 &amp; otherwise \\end{cases} \\] 主瓣宽度为\\(12\\pi /M\\)，旁瓣峰值衰减为57dB 凯泽窗（Kaiser） 这是一个非常有用的窗函数，它可以同时调整主瓣宽度与旁瓣宽度，这是其他窗函数不具备的，被定义为 \\[ w(n) = \\frac{I_0\\left[\\beta \\sqrt{1-\\left(1-\\frac{2n}{M-1}\\right)^2}\\right]}{I_0[\\beta]} \\] \\(I_0\\)是第一类零阶贝塞尔函数，\\(\\beta\\)是用来调整窗函数性能的参数 本人使用的\\(\\beta = 8.5\\) 如何选择窗函数 选择窗函数可以参考前文中的窗函数设计法 先确定自己的需求，然后根据窗函数的极限性能，做出选择，最后再验证这个窗函数是否符合需求 本文中的代码已上传本人的github 参考书籍： _DigitalSignalProcessingUsingMatlabv4.0_JohnG.Proakis 《数字信号处理教程》程佩青","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"dsp","slug":"dsp","permalink":"http://greedyhao.cc/tags/dsp/"}]},{"title":"FIR滤波器的加窗是什么","slug":"工作-dsp-2018-07-23-FIR滤波器的加窗是什么","date":"2018-07-23T06:09:58.000Z","updated":"2018-09-09T06:22:27.059Z","comments":true,"path":"2018/07/23/工作-dsp-2018-07-23-FIR滤波器的加窗是什么/","link":"","permalink":"http://greedyhao.cc/2018/07/23/工作-dsp-2018-07-23-FIR滤波器的加窗是什么/","excerpt":"FIR滤波器的加窗是什么 窗函数法是一种设计FIR滤波器的方法，FIR全称为Finite impulse response，即有限冲激响应滤波器。","text":"FIR滤波器的加窗是什么 窗函数法是一种设计FIR滤波器的方法，FIR全称为Finite impulse response，即有限冲激响应滤波器。 通带为\\(\\omega_c\\lt\\pi\\)的理想低通滤波器的系统函数为 \\[ H_d(e^{j\\omega})=\\begin{cases} 1\\cdotp e^{j\\alpha\\omega} &amp; |\\omega|\\le\\omega_e \\ 0 &amp; \\omega_e\\lt\\pi \\end{cases} \\] 反变换求它的冲激响应为 \\[ \\begin {aligned} h_d(n) &amp; = \\mathcal{F}^{-1}\\bigl[H_d(e^{j\\omega})\\bigr] = \\frac{1}{2\\pi} \\int_{-\\pi}^\\pi H_d(e^{j\\omega})e^{j\\omega n}d\\omega \\\\\\ &amp; = \\frac{1}{2\\pi} \\int_{-\\omega_e}^{\\omega_e} 1\\cdot e^{-j\\alpha\\omega} e^{j\\omega n}d\\omega \\\\\\ &amp; = \\frac{\\sin\\left[\\omega_e(n-\\alpha)\\right]}{\\pi(n-\\alpha)} \\end {aligned} \\] 可以看出，这是一个sinc函数 可以看出，\\(h_d(n)\\)的冲激响应在时域上是无限长的，不符合FIR滤波器的要求，所以需要对它截断，也就是加窗。 为了得到一个长度为M的因果的线性相位的FIR滤波器\\(h(n)\\)，我们需要 \\[ h(n)=\\begin{cases} h_d(n) &amp; 0\\le n\\le M-1 \\\\\\ 0 &amp; elsewhere \\end{cases} ~~ and ~~ \\alpha = \\frac{M-1}{2} \\] 也就是让\\(h_d(n)\\)的\\(0\\le n\\le M-1\\)之外的值全为0，这就是加窗。这个过程可以表示为 \\[ h(n) = h_d(n)w(n) \\] \\(w(n)\\)即为窗函数 \\[ w(n) = \\begin{cases} some\\ symmetric\\ function\\ with\\ respect\\ to \\\\\\ \\alpha\\ over\\ 0\\le n\\le M-1 \\\\\\ 0,\\ otherwise \\end{cases} \\] 在这里我们将\\(w(n)\\)定义为 \\[ w(n) = \\begin{cases} 1 &amp; 0\\le n\\le M-1 \\\\ 0 &amp; otherwise \\end{cases} \\] 再看看频域，使用\\(H(e^{j\\omega})\\)表示因果FIR滤波器的响应，\\(H_d(e^{j\\omega})\\)表示理想滤波器，\\(W(e^{j\\omega})\\)表示窗函数响应。 时域相乘，频域卷积，这里是圆周卷积。(圆周卷积以后也会介绍) \\[ \\begin {aligned} H(e^{j\\omega}) &amp; = H_d(e^{j\\omega})\\bigodot W(e^{j\\omega}) \\\\ &amp; = \\frac{1}{2\\pi}\\int_{-\\pi}^\\pi W(e^{j\\omega})H(e^{j(\\omega - \\lambda)}) \\end {aligned} \\] 我想在MATLAB中模拟这个加窗的过程，但是一直弄不出来，就把书上的图拿过来吧。 我不知道为什么我卷积出来的频域波形和窗函数的频域波形是一样的，很尴尬。 不过窗函数的原理基本还是理解了，直接生成书上卷积出来的频域波形不难，在matlab中直接生成一个FIR滤波器（相当于加了矩形窗），然后求它的频响。 代码如下： 1234alpha = (M-1)/2;n = [0:1:(M-1)];m = n - alpha + eps; % add smallest number to avoid divide by zerohd = sin(wc*m) ./ (pi*m); 123456wc = 0.2*pi;M = 60;hd = ideal_lp(wc,M);w_rect = (rectwin(M))&amp;#39;;h = hd .* w_rect;fvtool(h); 参考书籍： _DigitalSignalProcessingUsingMatlabv4.0_JohnG.Proakis 《数字信号处理教程》程佩青","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"dsp","slug":"dsp","permalink":"http://greedyhao.cc/tags/dsp/"}]},{"title":"说说我最近做了什么","slug":"生活-small-talk-2018-07-21-说说我最近做了什么","date":"2018-07-21T01:46:17.000Z","updated":"2018-09-09T04:56:41.518Z","comments":true,"path":"2018/07/21/生活-small-talk-2018-07-21-说说我最近做了什么/","link":"","permalink":"http://greedyhao.cc/2018/07/21/生活-small-talk-2018-07-21-说说我最近做了什么/","excerpt":"","text":"说说我最近做了什么 每天早上学习半个小时到一个小时的时间英语，买了两本书《恋练有词》和《恋练不忘》两本书，配套朱伟老师的视频学习。不得不说，这个课程挺不错的，朱伟老师人很幽默，思路清晰，讲的知识点很到位，值得推荐。 此外就是对数字信号处理的学习了，暂时计划是通过在中国大学MOOC上看视频，先快速过一遍，然后使用MATLAB配合书本进一步深入学习，最后如果能通过学习到的相关知识自己做一个示波器就更好了。 时域-&gt;z域 z变换 z逆变换 DTFT DFS DFT FFT的方法 数字滤波器的设计 IIR的设计方法 FIR的设计方法 窗函数 目前已经完成第一阶段的目标（定力有点不好，拖了几天才看完），稍微了解了一点数字信号处理的知识。 个人觉得数字信号处理的应用在于设计各种数字滤波器，而各种变换域的方法就是数字信号处理的分析，数字信号处理离不开分析与应用。 数字滤波器的设计要一开始就要明确设计的目的，设计好通频、损耗等等 分析上主要就是s域与z域同时间域之间的转换了，然后用FFT加速变换 不过我觉得我第一阶段做的不够好，首先是有点拖，浪费了很多时间；其次就是没有把问题记录下来，这个问题很致命。在看视频的时候，经常会冒出来一些问题，比如说窗函数各自的作用是什么、巴特沃斯等逼近是什么原理等等，很多问题当时突然就冒出来，但是没有记录就忘了，要是能把问题记录下来，之后带着问题再看书，效果应该会好很多。 在知乎上看到的，数字信号处理推荐的书籍，在公众号的菜单中有下载链接 DigitalSignalProcessing(4thEdition)4thEditionbyJohnG.Proakis(Author) Oppenheim:DiscretSignalProcessingbyAlanV.Oppenheim 数字信号处理教程程佩青","categories":[],"tags":[{"name":"small-talk","slug":"small-talk","permalink":"http://greedyhao.cc/tags/small-talk/"}]},{"title":"焊接总结","slug":"Hardware-2018-07-18-焊接总结","date":"2018-07-18T06:12:43.000Z","updated":"2018-09-09T04:54:00.122Z","comments":true,"path":"2018/07/18/Hardware-2018-07-18-焊接总结/","link":"","permalink":"http://greedyhao.cc/2018/07/18/Hardware-2018-07-18-焊接总结/","excerpt":"","text":"焊接总结 前段时间去做实习。 新来的嘛，自然不会给什么重要的事情做，就叫焊板；不过也好，很久没有动烙铁了，正好，可以再熟悉一下。 焊接一般的贴片封装 焊接步骤： 先在一边焊盘上锡 用镊子夹取需要焊接的元件并放置到焊盘 先在有锡的焊盘上固定元件的一头 再给元件的另一头上锡固定 经验总结 我一开始就是以这个步骤焊接的，不过在焊接完之后，以水平角度看板子上的元件发现，有虚焊的情况。 而且虚焊的情况主要是发生在后上锡的一头，这主要应该是和我用烙铁头给元件另一头上锡的动作有问题有关。 因此我改变了上锡的动作。原先焊插接件总是在焊完后习惯的把烙铁头顺着引脚，往上提。 不过我发现这个动作在焊贴片的时候不太好，会导致锡沾不上焊盘；所以我将自己之前忘上提的动作改为了往下压的动作。 另外就是，为了确保一开始焊的那头不会虚焊，可以在焊完后拔一拔，试试焊实了没有。虚焊的元件一拔就掉了。 焊接QFP等管脚比较多的元件 焊接步骤 先在焊盘上上点锡固定元件 堆锡 刮锡 经验总结 要这么做，一个好的烙铁头很重要！那种不沾锡的烙铁头就算了吧，会怀疑人生的。 焊完后检查一下管脚是否有短路，有时候没注意就有那么两三个管脚还是短路在一起的。 如果有锡刮不下来就上点助锡膏吧，没有这个东西搞不定的元件。 上一些焊接的图吧 刮锡","categories":[{"name":"Hardware","slug":"Hardware","permalink":"http://greedyhao.cc/categories/Hardware/"}],"tags":[]},{"title":"解释为什么旋转的物体有时看着像在倒转","slug":"工作-dsp-2018-07-09-解释为什么旋转的物体有时看着像在倒转","date":"2018-07-09T02:11:54.000Z","updated":"2018-09-09T04:50:26.609Z","comments":true,"path":"2018/07/09/工作-dsp-2018-07-09-解释为什么旋转的物体有时看着像在倒转/","link":"","permalink":"http://greedyhao.cc/2018/07/09/工作-dsp-2018-07-09-解释为什么旋转的物体有时看着像在倒转/","excerpt":"","text":"解释为什么旋转的物体有时看着像在倒转 动态图的原视频可以点击阅读原文观看，是十个不错的Arduino项目 描述现象 相信大家都有过这么的经历，旋转的物体，有时候看着觉得在倒转。 比如汽车的车轮，从静止开始发动汽车，这个过程中，汽车的车轮看起来就是从正转到反转或停止，当汽车减速的时候，汽车车轮看起来就又恢复成正转了。 学过信号与系统的或许知道奈奎斯特采样定律————最小采样频率是信号频率的两倍。 我在一开始也是不理解的，为什么刚刚好就要两倍，感觉很随意一样，别人家的黄金分割比都是小数0.618，听起来也酷，为什么香农家的是整数。 虽然我也知道以低于两倍信号频率采样的时候，会欠采样，丢失信号信息，但是具体怎么个丢失法，也是不了解的，直到我开始学习数字信号处理（DSP），才总算是晓得了这么个东西。 解释原理 以下材料来自中国大学MOOC https://www.icourse163.org/learn/UESTC-236010?tid=1002753005#/learn/announce 有点懒得自己用Matlab画图（其实是自己学的不够好），就使用我在网上学习的课程中使用的图来解释吧。 图中是使用Fs=10Hz的信号对3Hz、7Hz、13Hz的信号采样的结果 采样间隔为0.1s，采样得到的序列为g1[n]=cos(0.6πn) g2[n]=cos(1.4πn) g1[n]=cos(2.6πn)，从图中的采样点可以看出，采样点为三个信号的交点，所以采样得到的信号都是一样的，这种现象就是欠采样的效果：混叠现象 从频域上进行分析 使用10Hz的信号采样的效果相当于，将一个信号在频谱上分别向左和右搬移了20π。对于7Hz的信号来说，14π-20π=-6π，-14π+20π=6π，而3Hz的信号的频谱也在-6π和6π，所以无法分别到底是3Hz的信号还是7Hz的信号。如果将采样结果还原，得到的也只有3Hz的信号。同理可得13Hz信号的结果。 解释现象 一般来说，人眼能感受到的闪烁频率最高到60Hz，汽车车轮直径大概在737.6mm。也就是说，汽车车轮转动的频率超过30Hz，人眼就会出现“幻觉”了。 根据路程-速度-时间的关系，可以知道这个出现“幻觉”的速度为：v=30_737.6_10^(-3)=22.128(m/s)=79.6608(km/s) 所以说，一旦汽车的速度到了差不多80km/h的速度后，在人眼看来，车轮就有倒转的现象。 再现混叠现象 如果没条件把汽车架起来测试这个效果，可以选择平民化的测试方法。 手机摄像头的采集视频的刷新速度比人眼低很多，可以用手机摄像头对着电风扇拍视频，可以明显的看见电风扇也出现了“倒转”现象。 解决方法 在数字信号处理这个领域，为了解决这个问题，一般会在采样的前级加上一个抗混叠滤波器，通带为±二分之一的采样率，避免无法完全采样的频率“混叠”频谱。","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"dsp","slug":"dsp","permalink":"http://greedyhao.cc/tags/dsp/"}]},{"title":"SDRAM使用总结","slug":"工作-stm32-2018-07-08-SDRAM使用总结","date":"2018-07-08T00:28:36.000Z","updated":"2018-09-09T04:47:00.168Z","comments":true,"path":"2018/07/08/工作-stm32-2018-07-08-SDRAM使用总结/","link":"","permalink":"http://greedyhao.cc/2018/07/08/工作-stm32-2018-07-08-SDRAM使用总结/","excerpt":"","text":"SDRAM使用总结 最近stm32学到使用SDRAM了，板载SDRAM为IS42S16400J。 SDRAM为一种可以运行存储在存储器上的代码的存储器，stm32内部有2M的代码运行空间，一般都是够用的，如果不够用的时候就可以用SDRAM扩大代码运行空间。 SDRAM是通过FMC连接后直接映射到stm32内部寻址空间，与IIC和SPI需要操作总线不一样，操作SDRAM只需要在程序中定义一个指向这个空间的指针，通过指针直接修改存储单元内容，FMC外设会自动完成数据访问过程。 为了使FMC完成这些数据访问操作，需要在程序一开始进行初始化过程，一共包括对GPIO管脚时钟的初始化、FMC的初始化、SDRAM时序初始化。 SDRAM我觉得最重要的就是初始化过程了，初始化顺序一定要注意，一定要按照GPIO-&gt;FMC-&gt;SDRAM这个顺序初始化。 使用CubeMX创建的stm32工程需要注意，SDRAM时序初始化不能放在HAL_SDRAM_MspInit里，因为CubeMX生成的程序初始化过程是这样的，MX_FMC_Init-&gt;HAL_SDRAM_Init-&gt;HAL_SDRAM_MspInit，如果SDRAM时序初始化放在HAL_SDRAM_MspInit里，会由于FMC还没有初始化成功而导致SDRAM时序初始化失败。 我一开始就是由于不清楚这个初始化顺序，导致程序一直卡在SDRAM读写处。 读写SDRAM的话，只需要用一个指向这个空间地址的指针，然后操作这个指针指向的内容就好了。一个简单的读的例子如下。 1234567uint32_t *pSDRAM;uint32_t RadomBuffer[10000];#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SDRAM_BANK_ADDR ((uint32_t)0xD0000000)*pSDRAM=RadomBuffer[count];","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"c王国的诞生_零","slug":"系列-2018-07-08-c王国的诞生-零","date":"2018-07-08T00:27:42.000Z","updated":"2018-09-09T04:41:52.088Z","comments":true,"path":"2018/07/08/系列-2018-07-08-c王国的诞生-零/","link":"","permalink":"http://greedyhao.cc/2018/07/08/系列-2018-07-08-c王国的诞生-零/","excerpt":"","text":"c王国的诞生_零 欢迎来到创造世界游戏。在创世者赵无名面前的是一个刚刚被创造出来的世界，不过由于没有导入规则，一切都是静止的。 这片世界的上方悬浮着，请输入世界基本规则！ “就选麦克斯韦方程吧”赵无名说道。 这片世界的基本规则诞生了，伟大的麦克斯韦方程！从此，这片世界开始运转起来了，这片世界的电子运动形成变换的电流，变换的电流又形成了磁场，这些众多的电磁场就成了这片世界的搬运工，承载着这片世界的所有信息。 “总让这些电子乱跑可不行，玩游戏可是要钱的，得让他们给我做事才行”，正说着，赵无名给这片世界输入了布尔逻辑，并放入了晶体管来承载布尔规则；随后将这片世界从中间切割开来，上者为天，下者为地，再将大量的铜贯穿到地面作为电磁场的承载，将混乱的电磁场的一部分约束起来，保证其中的信息不会紊乱。 晶体管是一种可以阻挡电子运动的大门，他一般分为双极性三极管、场效应三极管，一般有P和N两种型号，有三个端口，靠中间的端口控制另外两个端口的关断。 从此以后，这片世界的大部分电子就被通过晶体管控制起来了，为了方便管理，将电子运动的反方向定义为电流运动的正方向，再定义电流运动方向上电势下降,通过电势差来控制晶体管的关断。 再将不同的晶体管以不同的方式组合，就形成了最基本的门电路——与或非门电路，完美的诠释了布尔逻辑。再将与或非门电路相互组合，便形成了与非、或非、与或非、异或、异或非门等。使用这些门电路便可以实现逻辑运算。 “使用门电路还是太麻烦了，连线都可以绕这块大陆十圈了，还是再对门电路做一层抽象吧。”无名说道，随后将不同功能的门电路组合成了译码器、编码器、数据选择器、加法器、触发器，再引入电容，制作时钟源；至此，就有了各种功能的逻辑电路，将不同功能的逻辑电路拼接，就可以制成不同位数的计算器。 ps:早期的计算机就是用各种门电路制成的，而且当时的封装技术很差，各种元件体积很大，所以当时的计算机效率低，体积大 巨像电脑 巨像电脑 这是一个介绍手工制作CPU的视频：https://www.bilibili.com/video/av26382148/ ，原文在https://eater.net/8bit/ 手工制作CPU “好吧，现在终于可以拥有自己的计算机了，不过每次都要手动开关这些晶体管来设置初值也太麻烦了，而且要记忆这么多的晶体管的功能太累了，我需要一个编译器。” 编译器的作用是将一种语言编译成机器码，机器码的作用就是指导计算机进行布尔运算，控制电路关断的。而且编译器的一个非常伟大之处在于，降低了编程的门槛，使得普通人也可以学编程，而且可以不怎么需要了解计算机原理。 ps:第一个编译器是由美国女性计算机科学家葛丽丝·霍普（Grace Murray Hopper）于1952年为A-0系统编写的，现代的编译器也可以追溯到A-0 “好了，就这样吧，用这个编译器编译的语言就叫做C语言吧” 想了解更多关于计算机原理的知识可以参考下面的链接 http://www.instructables.com/id/How-to-Build-an-8-Bit-Computer/ http://www.homebrewcpu.com/ https://eater.net/8bit/","categories":[{"name":"C王国的诞生","slug":"C王国的诞生","permalink":"http://greedyhao.cc/categories/C王国的诞生/"}],"tags":[]},{"title":"如何在Keil中提高代码的可读性","slug":"工作-stm32-2018-07-07-如何在Keil中提高代码的可读性","date":"2018-07-07T07:24:27.000Z","updated":"2018-09-09T04:38:31.188Z","comments":true,"path":"2018/07/07/工作-stm32-2018-07-07-如何在Keil中提高代码的可读性/","link":"","permalink":"http://greedyhao.cc/2018/07/07/工作-stm32-2018-07-07-如何在Keil中提高代码的可读性/","excerpt":"","text":"如何在Keil中提高代码的可读性 写代码犹如挖坑，挖坑容易，填坑难。一旦代码遇到BUG，需要慢慢调试时，你就会发现代码的可读性非常重要了，代码不整齐、命名不规范等等问题会导致代码像一团屎，看着恶心，检查起来更是悲伤。 所以，写代码前，最好先把代码的整体结构布置好，比如include放什么地方，define放什么地方，需要export的变量、函数放什么地方，最好又要保持自己所有的代码都保持这种模式，这时候，创建一个代码模板就非常有效了。 创建一个代码模板需要注意哪些方面呢？没有什么好的想法的话可以参考一下优秀的开源代码。 上面的代码风格从左到右，分别是FreeRTOS、FatFs、ST的代码风格，都很优秀，而且这些优秀的代码的共同点是，注释跟代码量差不多，甚至超过代码量。 因为的本身也在使用Keil，而且ST的注释很有逻辑，就选择了ST的注释风格。选择了注释风格后，就是创建代码模板了。 创建代码模板步骤如下 下载HAL库，并解压，打开Cube_FW_F7_V1.11.07533（也可以是其他文件夹下的），删除所有的代码，只留下注释 在自己的工程中新建一个文件，复制到新建的文件中 打开工具栏的Configuration，选择TextCompletion 新建一个Template，将模板复制进去 重复以上步骤，创建头文件的代码模板 使用代码模板方法 新建一个文件，要包含在项目中 在左侧的工具栏选择Templates 点击先前创建的代码模板 最后附上我创建的代码模板 头文件的代码模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* Define to prevent recursive inclusion -------------------------------------*/#ifndef #define #ifdef __cplusplus extern \"C\" &#123;#endif /* Includes ------------------------------------------------------------------*//** @addtogroup BSP * @&#123; */ /** @addtogroup Components * @&#123; */ /** @addtogroup ST7735 * @&#123; *//** @defgroup ST7735_Exported_Types * @&#123; */ /** * @&#125; */ /** @defgroup ST7735_Exported_Constants * @&#123; */ /** * @&#125; *//** @defgroup ADAFRUIT_SPI_LCD_Exported_Functions * @&#123; */ /** * @&#125; */#ifdef __cplusplus&#125;#endif#endif /* *//** * @&#125; */ /** * @&#125; *//** * @&#125; */ /************************ (C) COPYRIGHT greedyhao *****END OF FILE****/ 源文件的代码模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* Includes ------------------------------------------------------------------*//** @addtogroup BSP * @&#123; */ /** @addtogroup Components * @&#123; */ /** @addtogroup ST7735 * @brief This file provides a set of functions needed to drive the * ST7735 LCD. * @&#123; *//** @defgroup ST7735_Private_TypesDefinitions * @&#123; */ /** * @&#125; */ /** @defgroup ST7735_Private_Defines * @&#123; *//** * @&#125; */ /** @defgroup ST7735_Private_Macros * @&#123; *//** * @&#125; */ /** @defgroup ST7735_Private_Variables * @&#123; */ /*** @&#125;*/ /** @defgroup ST7735_Private_FunctionPrototypes * @&#123; *//*** @&#125;*/ /** @defgroup ST7735_Private_Functions * @&#123; *//*** @&#125;*/ /*** @&#125;*/ /*** @&#125;*/ /*** @&#125;*//************************ (C) COPYRIGHT greedyhao *****END OF FILE****/","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"CubeMX小指南之添加其他软件组件","slug":"工作-stm32-2018-07-06-CubeMX小指南之添加其他软件组件","date":"2018-07-06T05:38:47.000Z","updated":"2018-09-09T04:34:27.056Z","comments":true,"path":"2018/07/06/工作-stm32-2018-07-06-CubeMX小指南之添加其他软件组件/","link":"","permalink":"http://greedyhao.cc/2018/07/06/工作-stm32-2018-07-06-CubeMX小指南之添加其他软件组件/","excerpt":"","text":"CubeMX小指南之添加其他软件组件 写这篇文章是因为我看到STM32CubeMX for STM32 configuration and initialization C code generation这篇官方的CubeMX的使用文档中的Adding Additional Software Components这部分时发现，资料中的是这样的 而我的是这样的 这一看就知道有问题嘛，凭什么我的pacK少这么多是吧。 解决Additional Software Components中没有可添加的包的问题 我找到的原解决方案链接在这里 ps:公众号不能点击链接确实很麻烦，我会在文末附加上这个链接和我的博客地址，可以选择在文末复制这个链接或者到我的博客中读这篇文章。 解决方法如下： 首先是打开CubeMX 在Help菜单下点击ManageEmbeddedSoftwarePackages（快捷键Alt+U） 在EmbeddedSoftwarepackagesmanager窗口底部点击FromURL 在新的窗口点击New 输入Keilpacks的indexURL：http://sadevicepacksprodus.blob.core.windows.net/idxfile/keil.pidx 点击Check，然后你可以看见绿色的小勾 点击Ok，然后会开始更新URL，这有点久，我等了几分钟 这时候再打开AdditionalSoftwareComponents你就会发现多了很多包了 还是没有看见自己想要的包怎么办 不急，就拿我自己来说吧，想添加rt-thread的支持，在刚刚添加完keil pack后，发现还是没有rt-thread的支持。说实话，我是觉得有点奇怪的，明明keil pack中是有rt-thread的index的。 既然没有自动加入，那就手动加入吧。 和前面添加keil pack的方法一样，在Keil pack index URL中找到了rt-thread的index URL:http://www.rt-thread.org/download/mdk/rt-thread.rtthread.pdsc，然后添加进去，install一下，Additional Software Components中就有rt-thread了 怎么添加Additional Software Components进自己的工程呢 以rt-thread为例，先进入Additional Software Components 在左侧的Pack Vender中选择rt-thread，展开rt-thread Vender后，你会看见两个警告，大概意思是组件缺失，需要勾选上这三个组件的Selection，再返回到主界面时，就可以看到rt-thread了 文中链接的提供 博客地址：http://greedyhao.cc/ AdditionalSoftware解决方案原文链接：https://community.st.com/docs/DOC-1987-cubemx-adding-additional-software-components","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"使用Cubemx移植FatFs到stm32","slug":"工作-stm32-2018-07-05-使用Cubemx移植FatFs到stm32","date":"2018-07-05T07:29:27.000Z","updated":"2018-09-09T04:02:39.558Z","comments":true,"path":"2018/07/05/工作-stm32-2018-07-05-使用Cubemx移植FatFs到stm32/","link":"","permalink":"http://greedyhao.cc/2018/07/05/工作-stm32-2018-07-05-使用Cubemx移植FatFs到stm32/","excerpt":"","text":"使用Cubemx移植FatFs到stm32 在大型的存储器中，没有文件系统是万万不可行的，你不可能每次要打开一个文件都要从头到尾扫描一遍存储器，几兆的小存储器还好，几G甚至几T的存储器就根本没办法这么做了。而且有了文件系统也可以方便的管理使用各类文件。 这一次使用Cubemx生成FatFs的初始化代码，然后做最后的移植工作。本人使用的是stm32f767的野火的板子。 介绍一下FafFs 系统架构 FatFs是一种中间层，可以屏蔽硬件的差异，移植起来非常方便 移植需要注意的地方 你需要提供FatFs需要的底层I/O函数，需要的函数如下表，但是并不是全部函数都需要，你只需要提供必需的disk_status disk_initialize disk_read 和你需要的就可以。 开始移植 配置Cubemx 因为我准备的是W25Q128上的FatFs，CubeMX上面没有，所以要选择user-defined 接下来是在Configuration里面配置FatFs，因为需要读取的文件是中文的，所以要配置为中文，然后为以后可能还有别的存储器预留空位，所以配置VOLUMES为3 还有就是在project setting里面把stack设置的大点 此外就是W25Q128的基本配置，这些就不提供了，网上有，可以参考微雪课堂里的配置。 接下来就是生成代码了 补完底层I/O函数 打开user_disko.c这个文件，可以看到CubeMX自动生成的函数原型。由于我需要读写磁盘，所以我需要补全这些所有的函数USER_initialize USER_status USER_read USER_write USER_ioctl 遇到问题和解决问题 f_mount返回FR_DISK_ERR 这个问题困扰了我好几个小时，我从f_mount-&gt;get_ldnumber用printf找了差不多1个小时的BUG，发现找不到问题，突然间发现我f_mount还调用了一个函数find_volume，而且就算这里出现了问题，就换方向一路追踪find_volume-&gt;check_fs-&gt;move_window-&gt;disk_read，发现是disk_read返回的错误，看到这我就傻眼了，觉得不可能啊，因为我之前读取写入flash都是没有问题的。 第二天脑袋比较清醒了，首先先测试初始化是否成功，在读取成功flash id后确定了初始化成功。 然后再来看看disk_read，它使用的是我提供的一个全局的disk io驱动来读取disk，结构体类型如下 1234567typedef struct&#123; uint8_t is_initialized[_VOLUMES]; const Diskio_drvTypeDef *drv[_VOLUMES]; uint8_t lun[_VOLUMES]; volatile uint8_t nbr;&#125;Disk_drvTypeDef; 所以我回到了user_diskio.c查看我的USER_read函数 123456789101112131415161718192021222324DRESULT USER_read ( BYTE pdrv, /* Physical drive nmuber to identify the drive */ BYTE *buff, /* Data buffer to store read data */ DWORD sector, /* Sector address in LBA */ UINT count /* Number of sectors to read */)&#123; /* USER CODE BEGIN READ */ FLASH_DEBUG_FUNC(); DRESULT res = RES_ERROR; if ((Stat &amp; STA_NOINIT)) &#123; res = RES_NOTRDY; &#125; else &#123; sector+=1536;//扇区偏移，外部Flash文件系统空间放在外部Flash后面6M空间 res = BSP_QSPI_Read(buff, sector &lt;&lt;12, count&lt;&lt;12); &#125; return res; /* USER CODE END READ */&#125; 我在USER_read的else括号中加了一个printf，结果发现调用f_mount时，居然没有进入这个else语句，然后我开始怀疑这个Stat有问题，所以我把if的条件去掉了，直接执行_sector+=1536;res = BSP_QSPI_Read(buff, sector &lt;&lt;12, count&lt;&lt;12);_这条语句，发现FatFs挂载成功。 很激动，原来问题在于Stat的状态没有更新，因为Stat一开始定义的时候是定义为STA_NOINIT。 123/* Disk status */static volatile DSTATUS Stat = STA_NOINIT; 接下来就是查找disk的状态没有更新的原因。回到一开始找到返回错误信息的函数find_volume，它的执行过程相当于get_ldnumber-&gt;disk_initialize-&gt;check_fs…一开始就是到了check_fs这一步的时候报错，停止程序的，我们可以发现，这个过程并没有调用到用户定义的USER_status或FatFs定义的disk_status来检查disk的状态更新。 1234567891011所以我在初始化中加入了检查disk的状态的代码DSTATUS USER_initialize ( BYTE pdrv /* Physical drive nmuber to identify the drive */)&#123; /* USER CODE BEGIN INIT */ Stat = USER_status(pdrv); return BSP_QSPI_Init(); /* Flash的初始化 */ /* USER CODE END INIT */&#125; 效果很好，disk的状态更新成功，f_mount挂载正常。 f_open返回FR_INVALID_NAME 好不容易挂载成功了，但是读写还是失败，第一反应是可能在编码上出错了，因为我的工程没有包括cc936.c这个文件，而野火官方的工程却包括了，我怀疑是不是这一点导致无法读取中文，从而FR_INVALID_NAME。 但是我现在还不知道FatFs是怎么调用cc936.c这个文件的，只能先从f_open跟踪进去看看。 f_open-&gt;follow_path，打LOG发现是follow_path中的create_name返回的FR_INVALID_NAME 进入create_name找到返回FR_INVALID_NAME的语句 123456789101112...mem_set(sfn, &apos; &apos;, 11);...for (;;;) &#123; ... if (c == &apos;.&apos; || i &gt;= ni) &#123; /* End of body or over size? */ if (ni == 11 || c != &apos;.&apos;) return FR_INVALID_NAME; /* Over size or invalid dot */ i = 8; ni = 11; /* Goto extension */ continue; &#125; ...&#125; 由于对于文件名一开始只分配了11个空间，但是我的文件名却超过了11个空间，所以导致了这个问题，在我将我的文件名减少后，问题解决。 文件名长度才11有点短，但是可以通过修改支持长文件名来支持。 在支持长文件名后，读写长文件名没有问题了 可以改进的地方 本工程没有加入RTC的支持，所以没有去实现get_fattime，因此不支持多磁盘，想支持多磁盘需要实现get_fattime 本工程已上传github 1https://github.com/greedyhao/stm32","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"自适应滤波教我做人","slug":"生活-感悟-2018-05-25-自适应滤波教我做人","date":"2018-05-25T15:21:28.000Z","updated":"2018-09-09T03:14:28.039Z","comments":true,"path":"2018/05/25/生活-感悟-2018-05-25-自适应滤波教我做人/","link":"","permalink":"http://greedyhao.cc/2018/05/25/生活-感悟-2018-05-25-自适应滤波教我做人/","excerpt":"","text":"自适应滤波教我做人 最近准备参加电赛，校赛的要求是在2017年电赛国赛的题目中选择一个做。我看了题目，表示对自适应滤波比较感兴趣，正好之前也学习了解过一点信号处理的相关知识，就决定是自适应滤波了。 先说我结果吧，后天就是比赛开始了，但是我还是没有搞定问题，又面临着考试可能会挂科的压力，只能弃权了。 我觉得之所以会导致这个结果，跟我前期的规划失策是有一定原因的。 我将主要的精力全部放在LMS算法的实现上了；再着，FPGA对我来说是一个很大的挑战，因为之前从来没有用过，要在一个月内学会使用并做比赛，对我来说还是有着挺大的压力的；还有很重要的一点就是，我的心太大了，同时报了两个比赛，除了电赛还有另外一个科技创新的校内比赛，本以为很容易解决的，但是还是耽误了我很多时间，而且也是由于时间问题只能放弃。 这次的比赛除了让我意识到我的规划有问题外，也让我知道了，一个人的力量还是有限的。在没有参加比赛前，我还是自信心爆棚的，在网上看了些论文，自以为就没有问题了，就直接随便拉了两个人报名，然后全部工作由我一个人来做。事实证明，还是很难的，特别是做自己不熟悉的东西，更是难上加难；找文档、找论文都花了我超多时间，如果有队友的话，这些时间可以剩出很多来，甚至我的项目进度还可以以并行的方式前进。就拿这次的比赛来说，我需要一个信号叠加、一个信号移相、一个自适应滤波三大模块，正好电赛有三个名额，如果有队友的话，完全可以分成多个任务，大家一起完成， 断断续续做了差不多一个月的这个比赛，我就说说我除了教训，还获得了什么吧。 首先自然是学会了使用FPGA的一点皮毛，Quartus这个庞大的软件基本被我啃了下来，基本会操作了，很感动。因为软件资料真的不算多，特别是我使用的最新quartus 18版，我在官网看的有的资料甚至是几天前才出的，有的资料也还没有更新，真的挺难受的。我把我自己排的许多坑全部都写出来了，直面使用quartus遇到的问题、使用ModelSim遇到的问题、使用DSP Builder遇到的问题，这些很多都是我在网上没有搜到，然后在官方手册里找了很久才找到的，也算是我为广大群体做的一点小贡献吧。可能我之后还会写一些具体的操作教程，因为我也注意到了我使用的开发板Cyclone IV相关的教程比较缺乏，不好上手，就好像这次困住我的地方就是A/D转换方面的问题，等我解决了后就会发出来。 再者的话自然就是对信号处理有了更多的了解，了解到自适应滤波其实本质上也是一种基于统计学的方法，通过统计输入信号与期望信号之间的误差来调节滤波器的相关参数，自适应滤波分为自适应过程与滤波过程。我花了很多时间，但是也没有完全理解，最后终于在网上找到了一个解决方法，但是效果并不怎么好，是由两个七阶lms滤波器组成，但是却需要差不多8个周期才能收敛，而我在论文中看到的只需要两个周期，而且没有使用这么多资源。下面给张自适应滤波器的效果图吧。 再者的话，就是对数字信号有了更多的了解，一开始想着信号叠加和信号移相全部使用模拟电路做，但是后来了解到可以使用FPGA完成，就想使用数字电路来完成。可以说，这是导致我失败的一个很重要的原因，因为信号的移相需要使用到Direct digital synthesizer(DDS)，这是什么？它可以从一个单一的频率源生成任意波形和频率。原本我的想法是通过ADC得到输入信号的波形和频率，然后将移相后的波形通过DDS生成，再通过DAC输出，但是FPGA还不太熟，怎么检测波形我还不会，就一直给卡在这里了… 总的来说，失败了也不错，只有挫折能让人保持清醒，而痛苦才能让我品尝到快乐。","categories":[{"name":"生活","slug":"生活","permalink":"http://greedyhao.cc/categories/生活/"}],"tags":[]},{"title":"解决Alios烧录导致esp32不断重启问题","slug":"工作-alios-2018-05-15-解决Alios烧录导致esp32不断重启问题","date":"2018-05-13T11:59:55.000Z","updated":"2018-09-09T05:52:27.812Z","comments":true,"path":"2018/05/13/工作-alios-2018-05-15-解决Alios烧录导致esp32不断重启问题/","link":"","permalink":"http://greedyhao.cc/2018/05/13/工作-alios-2018-05-15-解决Alios烧录导致esp32不断重启问题/","excerpt":"解决Alios烧录导致esp32不断重启问题 最近为了参加一个学校的科技创新的比赛，准备做个物联网的小项目，准备使用esp32的开发板。正好看上了Alios Things这个平台，花了很多时日解决编译问题，有兴趣入坑的朋友可以参考一下。 在解决了编译问题后，又遇到了烧录导致设备不断重启的问题，让我更加无从下手，但是使用Arduino烧录的程序是可以正常运行的。在我搜索了很多页面后，终于找到了解决方法。","text":"解决Alios烧录导致esp32不断重启问题 最近为了参加一个学校的科技创新的比赛，准备做个物联网的小项目，准备使用esp32的开发板。正好看上了Alios Things这个平台，花了很多时日解决编译问题，有兴趣入坑的朋友可以参考一下。 在解决了编译问题后，又遇到了烧录导致设备不断重启的问题，让我更加无从下手，但是使用Arduino烧录的程序是可以正常运行的。在我搜索了很多页面后，终于找到了解决方法。 错误信息如下图 说出来你可能不信，解决方法很简单，erase flash一下就好了。 具体操作可以复制以下代码到Alios Studio终端中运行，召唤终端的方法是 ctrl + ` 12## comX 为你的设备的端口号esptool.py --port comX erase_flash 编译烧录完后，运行效果如下","categories":[{"name":"问题总结","slug":"问题总结","permalink":"http://greedyhao.cc/categories/问题总结/"}],"tags":[{"name":"Alios","slug":"Alios","permalink":"http://greedyhao.cc/tags/Alios/"}]},{"title":"使用Dsp_Builder遇到的问题","slug":"工作-fpga-2018-05-13-使用Dsp-Builder遇到的问题","date":"2018-05-13T09:27:43.000Z","updated":"2018-09-09T03:04:37.100Z","comments":true,"path":"2018/05/13/工作-fpga-2018-05-13-使用Dsp-Builder遇到的问题/","link":"","permalink":"http://greedyhao.cc/2018/05/13/工作-fpga-2018-05-13-使用Dsp-Builder遇到的问题/","excerpt":"","text":"使用Dsp_Builder遇到的问题 找不到DSP Builder的库 到你的quartus安装路径下找到DSP Builder，比如我的就在D:8.0_builder，点击dsp_builder.bat，可以选择把dsp_builder.bat发送快捷方式到桌面方便点击。 在弹出的matlab中的命令框中输入，就可以看见如图所示的库了 1slLibraryBrowser DSP Builder license 问题 之前破解没有破解完全，没有get到作者说的设置环境变量是什么意思，知道今天要用DSP Builder编译项目时才知道。 需要在系统变量中添加LM_LICENSE_FILE和之前license.dat的地址 修改后重启DSP Builder，编译成功 使用Subsystem分层设计 右键一个symbol，可以看见Create Subsystem选项，不用在意是什么symbol，只要input output的port是自己需要的就好了。 这里可以看见元器件的子系统，然后可以进行修改 最终效果图如下","categories":[{"name":"问题总结","slug":"问题总结","permalink":"http://greedyhao.cc/categories/问题总结/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://greedyhao.cc/tags/FPGA/"}]},{"title":"使用ModelSim遇到的问题","slug":"工作-fpga-2018-05-13-使用ModelSim遇到的问题","date":"2018-05-13T09:23:35.000Z","updated":"2018-09-09T03:08:01.704Z","comments":true,"path":"2018/05/13/工作-fpga-2018-05-13-使用ModelSim遇到的问题/","link":"","permalink":"http://greedyhao.cc/2018/05/13/工作-fpga-2018-05-13-使用ModelSim遇到的问题/","excerpt":"","text":"使用ModelSim遇到的问题 Error: Could not find altera.alt_dspbuilder_package. 解决方法自然是添加包了。 把_dspbuilder_package.vhd文件复制到_ase。 然后再对Modlesim里库文件altera进行compile，选中alt_dspbuilder_package.vhd文件进行compile，从而把alt_dspbuilder_package添加进来，重新启动即可。 具体操作如图，记得要选择altera库再编译 编译完成后会把alt_dspbuilder_package添加到altera库中，然后就可以仿真DSP Builder的项目了","categories":[{"name":"问题总结","slug":"问题总结","permalink":"http://greedyhao.cc/categories/问题总结/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://greedyhao.cc/tags/FPGA/"}]},{"title":"使用_Alios_Things_遇到的问题总结","slug":"工作-alios-2018-05-13-使用-Alios-Things-遇到的问题总结","date":"2018-05-13T03:29:10.000Z","updated":"2018-09-09T02:59:43.046Z","comments":true,"path":"2018/05/13/工作-alios-2018-05-13-使用-Alios-Things-遇到的问题总结/","link":"","permalink":"http://greedyhao.cc/2018/05/13/工作-alios-2018-05-13-使用-Alios-Things-遇到的问题总结/","excerpt":"","text":"使用_Alios_Things_遇到的问题总结 更新中… 编译问题 系统找不到指定文件 如下图，虽然选择了编译的项目和板子，但是make时系统找不到指定文件 这种情况多半是没有选择对工作目录，VS Code中的操作如下：文件-&gt;打开文件夹，然后选择ALIOS-THINGS 编译没有bin输出 有时候会出现编译后没有bin输出 这时候把项目clean一下再编译就可以了。 烧录问题 esp32烧录需要stlink问题 目前的aos-cube已经可以支持esp32的烧录了，你首先需要输入 1pip list 确认aos-cube的版本是否为最新版 2.30不是最新版，所以无法upload，需要复制下面的升级 1pip install -U aos-cube","categories":[{"name":"问题总结","slug":"问题总结","permalink":"http://greedyhao.cc/categories/问题总结/"}],"tags":[{"name":"Alios","slug":"Alios","permalink":"http://greedyhao.cc/tags/Alios/"}]},{"title":"FPGA学习进度","slug":"工作-fpga-2018-05-11-FPGA学习进度","date":"2018-05-11T01:44:58.000Z","updated":"2018-09-08T15:32:17.946Z","comments":true,"path":"2018/05/11/工作-fpga-2018-05-11-FPGA学习进度/","link":"","permalink":"http://greedyhao.cc/2018/05/11/工作-fpga-2018-05-11-FPGA学习进度/","excerpt":"","text":"FPGA学习进度 2018/5/18 今天才知道原来fpga重新上电后之前的程序就没有了，要保持需要固化 2018/5/16 本来之前就说要学的platfrom designer被Alios的学习拖了几天，今天了解了一下，基本会用了 板子能够输出Hello world了 2018/5/13 今天开始学习其他的组件dsp builder(重点)、platfrom designer dsp builder之前没有破解好，没有添加环境变量，编译时出错，在添加环境变量后重启matlab后可以使用了。 成功在dsp builder编译项目成功，并在modelsim仿真成功，就是和官方给的图有点不一样，有点疑惑 成功将dsp builder项目添加到quartus中，编译成功但是仿真出错。 仿真报错问题解决，但是不出波形。 2018/5/12 今天是一个重大的时刻，成功完成了自己的第一个FPGA项目而且烧录成功，为自己打call 2018/5/11 感谢上苍，找到了新建工程打不开的原因了，这是解决方案的原链接 2018/5/10 早上花了差不多2个小时，终于在matlab中找到了dsp builder，但是使用起来好像会默认使用quartus pro的tools，于是卸载pro版 不知道怎么就能在simulink library browser中看到dsp builder的库了，电脑给了我这个惊喜，很开心（再不给我可能要砸电脑了…） 我做的事情就是把..8.0_builder64.m复制到..8.0_builder64打开simulink library browser 但是还是没有看见dsp builder，但是后来我删除了这个文件后，不知道怎么回事就看到了dsp builder… 使用slLibraryBrowser命令打开simulink library browser 为了确保能够打开dsp builer不是偶然事件，我关闭了matlab，然后重新打开了simulink library browser，发现还是可以使用dsp builder，至此软件准备完毕 很好，新建的quartus的工程居然打不开（手动微笑） 2018/5/9 开始学习FPGA。 了解到DSP Builder对我的FPGA设计有帮助 发现Intel FPGA上的support有training的视频，开始看视频学习 才知道原来quartus pro版不支持cyclone IV，又得重下standand版…","categories":[{"name":"每日学习记录","slug":"每日学习记录","permalink":"http://greedyhao.cc/categories/每日学习记录/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://greedyhao.cc/tags/FPGA/"},{"name":"quartus","slug":"quartus","permalink":"http://greedyhao.cc/tags/quartus/"}]},{"title":"直面使用quartus遇到各种的问题","slug":"工作-fpga-2018-05-11-直面使用quartus遇到各种的问题","date":"2018-05-11T01:42:02.000Z","updated":"2018-09-08T15:33:58.205Z","comments":true,"path":"2018/05/11/工作-fpga-2018-05-11-直面使用quartus遇到各种的问题/","link":"","permalink":"http://greedyhao.cc/2018/05/11/工作-fpga-2018-05-11-直面使用quartus遇到各种的问题/","excerpt":"","text":"直面使用quartus遇到各种的问题 安装破解 quartus prime 18 破解 这个人还有一系列其他的破解软件，可以打开他的空间看看 can’t find design entity 在新建工程后，点击工程文件发现居然说无法打开？？？ 网上查说没破解成功，在我重新破解一次后发现不是这个问题。 还好我有谷歌，还是让我找到了解决方案 说是需要自己手动创建design entity，下面是具体解决方案 解决方案 在使用Project Wizard创建好工程后，你以为就创建好工程了？ 双击“myFPGAgizmo”编辑代码，会弹出一个不太直观的错误： 1Can&apos;t find design entity &quot;myFPGAgizmo&quot;. 大概会像下图这样 你需要自己手动的添加一个新的DESIGN ENTITY File - New - Verilog HDL File: 新建文件一开始不能自己命名，要保存时才能命名，这点和Visual Studio很像 要注意一下： module的名字要和”top level”文件名相同，而且要注意大小写，否则的话，就会报错 1Top level design entity &quot;myFPGAgizmo&quot; is undefined 测试代码如下： 12345module myFPGAgizmo (x1, x2, f); input x1, x2; output f; assign f = (x1 &amp; ~x2)|(~x1 &amp; x2);endmodule Critical Warning: Synopsys Design Constraints File file not found: ‘xxx.sdc’. A Synopsys Design Constraints File is required by the Timing Analyzer to get proper timing constraints. Without it, the Compiler will not properly optimize the design. 这是缺少了SDC文件，SDC文件在我看来是用来约束时序，配置时钟的。 学过数电我们都知道，时序电路的时钟是非常关键的，如果没有配置时钟的话，Quartus默认会配置1GHz时钟，这很显然是没法工作的。 解决方法就是File-&gt;New，然后的弹出窗口中选择Other Files-&gt;Synopsys Design Constraints File。配置好SDC文件保存时要注意，文件名字要和顶层文件名相同。 相关的SDC文件的设置参考Timing Analyzer User Guide 一个简单的SDC例子如下： 123create_clock -period 20.00 -name adc_clk [get_ports adc_clk]derive_pll_clocksderive_clock_uncertainty Error (xxx): Logic function of type xxx and instance “inst” is already defined as a signal name or another logic function 这是因为名字重复了。如下图，我一开始没有注意到，有的symbol是由名字的，刚创建出来的时候都是一样的，一编译就会出错，修改后就好了。 Can’t launch the ModelSim-Altera software… 运行ModelSim仿真时发现无法打开仿真 这是因为没有设置ModelSim的位置导致的，Tools-&gt;Options.. 然后设置好你的ModelSim路径 保存好后运行测试成功","categories":[{"name":"问题总结","slug":"问题总结","permalink":"http://greedyhao.cc/categories/问题总结/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://greedyhao.cc/tags/FPGA/"},{"name":"quartus","slug":"quartus","permalink":"http://greedyhao.cc/tags/quartus/"}]},{"title":"解决WSL无法运行32位程序问题","slug":"工作-Linux-2018-04-15-解决WSL无法运行32位程序问题","date":"2018-04-15T08:47:06.000Z","updated":"2018-09-09T05:52:27.812Z","comments":true,"path":"2018/04/15/工作-Linux-2018-04-15-解决WSL无法运行32位程序问题/","link":"","permalink":"http://greedyhao.cc/2018/04/15/工作-Linux-2018-04-15-解决WSL无法运行32位程序问题/","excerpt":"解决WSL无法运行32位程序问题 ./arm-none-linux-gnueabi-gcc: cannot execute binary file: Exec format error 因为我是学生，比较穷，只有一台电脑，而且有使用Windows的需要，但是又需要使用到Linux，所以选择了Windows子系统(WSL)，但是发现WSL不支持32位程序的运行，在苦苦搜索后，终于在github找到了解决方法。","text":"解决WSL无法运行32位程序问题 ./arm-none-linux-gnueabi-gcc: cannot execute binary file: Exec format error 因为我是学生，比较穷，只有一台电脑，而且有使用Windows的需要，但是又需要使用到Linux，所以选择了Windows子系统(WSL)，但是发现WSL不支持32位程序的运行，在苦苦搜索后，终于在github找到了解决方法。 解决方案的原链接 微软官方说了，WSL暂时不准备支持ELF-32的运行。 要求系统版本1709, build 16299 或以上。 安装qemu 和 binfmt 123sudo apt updatesudo apt install qemu-user-staticsudo update-binfmts --install i386 /usr/bin/qemu-i386-static --magic &apos;\\x7fELF\\x01\\x01\\x01\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x03\\x00\\x01\\x00\\x00\\x00&apos; --mask &apos;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\xff\\xff\\xff\\xff\\xff\\xff\\xff&apos; 注意： 每次重启WSL后如果需要i386的支持需要以下命令 1sudo service binfmt-support start Enable i386 architecture and packages 123sudo dpkg --add-architecture i386sudo apt updatesudo apt install gcc:i386 测试 12345678$ file arm-none-linux-gnueabi-gccarm-none-linux-gnueabi-gcc: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.2.5, stripped$ ./arm-none-linux-gnueabi-gcc -vUsing built-in specs.Target: arm-none-linux-gnueabiConfigured with: /scratch/julian/2009q3-respin-linux-lite/src/gcc-4.4/configure --build=i686-pc-linux-gnu --host=i686-pc-linux-gnu --target=arm-none-linux-gnueabi --enable-threads --disable-libmudflap --disable-libssp --disable-libstdcxx-pch --enable-extra-sgxxlite-multilibs --with-arch=armv5te --with-gnu-as --with-gnu-ld --with-specs=&apos;%&#123;funwind-tables|fno-unwind-tables|mabi=*|ffreestanding|nostdlib:;:-funwind-tables&#125; %&#123;O2:%&#123;!fno-remove-local-statics: -fremove-local-statics&#125;&#125; %&#123;O*:%&#123;O|O0|O1|O2|Os:;:%&#123;!fno-remove-local-statics: -fremove-local-statics&#125;&#125;&#125;&apos; --enable-languages=c,c++ --enable-shared --disable-lto --enable-symvers=gnu --enable-__cxa_atexit --with-pkgversion=&apos;Sourcery G++ Lite 2009q3-67&apos; --with-bugurl=https://support.codesourcery.com/GNUToolchain/ --disable-nls --prefix=/opt/codesourcery --with-sysroot=/opt/codesourcery/arm-none-linux-gnueabi/libc --with-build-sysroot=/scratch/julian/2009q3-respin-linux-lite/install/arm-none-linux-gnueabi/libc --with-gmp=/scratch/julian/2009q3-respin-linux-lite/obj/host-libs-2009q3-67-arm-none-linux-gnueabi-i686-pc-linux-gnu/usr --with-mpfr=/scratch/julian/2009q3-respin-linux-lite/obj/host-libs-2009q3-67-arm-none-linux-gnueabi-i686-pc-linux-gnu/usr --with-ppl=/scratch/julian/2009q3-respin-linux-lite/obj/host-libs-2009q3-67-arm-none-linux-gnueabi-i686-pc-linux-gnu/usr --with-host-libstdcxx=&apos;-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm&apos; --with-cloog=/scratch/julian/2009q3-respin-linux-lite/obj/host-libs-2009q3-67-arm-none-linux-gnueabi-i686-pc-linux-gnu/usr --disable-libgomp --enable-poison-system-directories --with-build-time-tools=/scratch/julian/2009q3-respin-linux-lite/install/arm-none-linux-gnueabi/bin --with-build-time-tools=/scratch/julian/2009q3-respin-linux-lite/install/arm-none-linux-gnueabi/binThread model: posixgcc version 4.4.1 (Sourcery G++ Lite 2009q3-67)","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"},{"name":"WSL","slug":"WSL","permalink":"http://greedyhao.cc/tags/WSL/"}]},{"title":"如何阅读datasheet，以BQ24610为例","slug":"工作-altium-2018-04-06-如何阅读datasheet","date":"2018-04-06T11:53:46.000Z","updated":"2018-09-09T05:52:27.812Z","comments":true,"path":"2018/04/06/工作-altium-2018-04-06-如何阅读datasheet/","link":"","permalink":"http://greedyhao.cc/2018/04/06/工作-altium-2018-04-06-如何阅读datasheet/","excerpt":"如何阅读datasheet，以BQ24610为例 本文的主要目的在于传播基本的阅读datasheet的能力，以及PCB设计需要注意的基本问题。","text":"如何阅读datasheet，以BQ24610为例 本文的主要目的在于传播基本的阅读datasheet的能力，以及PCB设计需要注意的基本问题。 本次需要设计的是24V动力锂电池充电电路。 原理图设计 参考官方参考电路 为了快速设计电路，自然是参考官方参考电路，选择Typical Application。 做细微的参数调整 由于我们的需求是给24V的电池充电，所以需要稍微修改一下原理图，接下来需要查看的就是Feature Description 设置充电电压 从图中可以看出，R1和R2是设置电池充电电压的地方。我需要的是24V充电，所以我分贝设置为100K和1.1M - 设置电池充电电流 Vset1和Rsr是用来调整充电电流的，虽然我也想把充电电流设置的高一点，但是我在淘宝上找不到能提供那么大电流的的24V的适配器，很失望。Rsr就用了10mR，Vset1是使用电阻分压得到的，我本来想设置为5A的，可是43.5K的电阻很贵，就采用了和官方一样的电阻值，设置为3A。 - 设置适配器充电电流 通过Vacset和Rac设置，前文也说了，由于适配器限制，本来这片芯片最大能承受10A充电电流的，也只能设置成3A，也使用官方提供的值了。 - 设置预充电电流 预充电就是当电池电压低于一个设置的阈值时，先用小电流对电池充电，使电池达到设置的阈值，这样可以激活电池，保证电池的寿命不会太快衰减。但需要注意的是，预充电30分钟后还没有达到阈值的话，充电芯片就会停止充电，通过状态引脚给出错误信息。 - 设置充电安全时间 通过Cttc这个电容可以设置充电的安全时间，也是一种保护电池的措施。我使用的也是官方的值。 - 系统供电方式 这里说的大概意思就是，VCC可以从电池或适配器供电，当VCC电压大于电池电压时，会关闭电池与系统之间的BATFET，使用VCC供电（一般也就是插着适配器的时候才会发生吧，使用适配器供电也很正常）。 - 充电和取消充电的情况 这里列举了什么情况下充电，什么情况下停止充电，有兴趣自己看看就好，对原理图绘制影响不大。 - 过热保护 这里提到用103AT的热敏电阻测量温度。 - 充电状态输出方式 这张表体现了充电的状态对应的LED灯情况 完成设计 说实话，感觉这种设计感觉技术水平不高，还是那些使用分立元件那个年代的前辈厉害，现在都集成在IC中了，外围设计简单了太多。 PCB设计 官方建议 这是官方提供的Layout的指导 输入电容要尽可能的靠近开关MOSFET并使得和地之间的回路最小。这些元件需要放在同一层而不是不同层然后使用过孔连接（惨..没写这篇文章前还没注意到，我有的元件是放在bottom的，不过我用了多个过孔应该没关系的吧..）。 IC应该被放在开关MOSFET的附近来保证控制信号是干净的（我放的好像有点远..) 电感的输入端要尽可能的靠近开关MOSFET的输出端。覆铜面积要尽可能小以避免电磁干扰，但是要保证足够的宽度承载电流。这里不要用不同层的平行线的连接。保证和其他网络尽可能小的寄生电容（这是为了避免这里的高频信号影响其他位置的模拟电路）。 采样电阻要靠近电感的输出端，布线时最好参考官方的这种设计 - 输出电容要放置在靠近采样电阻的输出端和地之间。 - 输出电容的地要先和输入电容的地连接再和IC的地连接 - 模拟地要和电源地分离，并且用信号地连接充电器的电源地和模拟地。就在IC的下放使用覆铜连接模拟地，但是要避免电源管脚以减少容性和感性噪声耦合。在热焊盘上连接模拟地和电源地并作为信号地的连接点。或者使用0R的电阻连接模拟地和电源地（这种情况下热焊盘需要连接模拟地）。非常推荐在热焊盘下使用星形连接。 - 热焊盘的接地是非常重要的，要确保过孔是直接在IC下方的。 - 去耦电容要尽可能靠近IC - 过孔的数量和大小要满足电流的需要 PCB一般要求 除此之外还要注意电流与线宽、铜厚之间的关系 成品图 Top Layer Bottom Layer 总结 画PCB还是需要有经验加持的，就拿我这次画板来说吧，之前没有经验，不懂如何看IC的datasheet，在老师的带领下才学会了查看datasheet。但是看datasheet还是不够认真，没有去看官方的一些建议，Layout时有许多细节没有处理好，只到我打板后这么久，写文章的时候才发现，官方建议中的第2、3、4、5、6、7、9都是不太符合要求的，但是板都打了.. 虽然板子存在很多问题，但是自己画的板还是想看看效果是怎么样的，可惜退了那个团队，测试板子就交给其他人了。","categories":[],"tags":[{"name":"Altium","slug":"Altium","permalink":"http://greedyhao.cc/tags/Altium/"},{"name":"PCB","slug":"PCB","permalink":"http://greedyhao.cc/tags/PCB/"}]},{"title":"《数学之美》阅读记录四","slug":"读书笔记-2018-04-05-《数学之美》阅读记录四","date":"2018-04-05T07:36:09.000Z","updated":"2018-09-09T05:52:27.812Z","comments":true,"path":"2018/04/05/读书笔记-2018-04-05-《数学之美》阅读记录四/","link":"","permalink":"http://greedyhao.cc/2018/04/05/读书笔记-2018-04-05-《数学之美》阅读记录四/","excerpt":"《数学之美》阅读记录四 今天阅读的这部分也是对于搜索引擎的介绍","text":"《数学之美》阅读记录四 今天阅读的这部分也是对于搜索引擎的介绍 在搜索引擎的早期阶段，搜索引擎面临一个普遍的问题：搜索出来的答案很难找到自己想要的。 当时虽然已经对网页做了索引，能够很快给出搜索结果了，但是搜索结果不精准，可能自己的想要的答案不知道在多少页的搜索结果之后。为了解决这个问题，谷歌的PageRank排名技术诞生了。 简单来说，PageRank排名就是通过“投票”选出网页的排名。“投票”就是看看同一个搜索词下，哪一个网页被链接的次数多，就排名靠前。 再后来，人们发现娱乐八卦的PageRank值挺高的，但是却不是自己想要的。这时对PageRank不再是简简单单的统计被链接的量，开始加入了权重；质量好的网站权重大，质量差的网站权重低。 此外，还对网页中关键词的词频做统计。统计网页中总词数，用网页中的关键词处于总词数得到词频，将所有关键词的词频加起来作为网页相关性的参考。但是这样还是存在着问题，停止词对于我们的搜索来说是毫无意义的，有的关键词却是我们更加关注的，这样一来，我们需要给关键词的词频加上权重，更重要的词的权重高，无意义的词权重为零。 对于地址的匹配使用到了有限状态机，不过我对于有限状态机没什么了解，对于书中的内容也是理解不充分，还是上一张书中的图吧 我感觉有限状态机就好像是对特定词匹配，就像图中的， 搜索字串可以是先市或省，然后一级一级往下排，有限状态机就按照这种排序匹配地区级对应的字串进行搜索，就好比广东省匹配到的就是广东这样；输入到图中的有限状态机的字串还不能先是街道级后是省级，这会报错。 导航使用到了动态规划算法我也是只是略有耳闻，看完书中的介绍后也只是知道，动态规划算法可以降低计算机的工作量，它把一个大的问题分解为一个个小的问题来解决。 书中介绍了一个人：辛格博士。他用事实告诉了我们，解决工程中的问题要用最简单的方法，有时候最简单的方法反而是最有效的方法；而且简单的方法更容易让人理解，后期维护升级成本会更低。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://greedyhao.cc/categories/读书笔记/"}],"tags":[]},{"title":"《数学之美》阅读记录三","slug":"读书笔记-2018-04-04-《数学之美》阅读记录三","date":"2018-04-04T15:29:18.000Z","updated":"2018-09-09T05:52:27.808Z","comments":true,"path":"2018/04/04/读书笔记-2018-04-04-《数学之美》阅读记录三/","link":"","permalink":"http://greedyhao.cc/2018/04/04/读书笔记-2018-04-04-《数学之美》阅读记录三/","excerpt":"《数学之美》阅读记录三 今天看到了介绍搜索引擎和网络爬虫的原理。","text":"《数学之美》阅读记录三 今天看到了介绍搜索引擎和网络爬虫的原理。 搜索引擎如何能在0.几秒内给出搜索结果呢？如果是单纯的进行每个网页的文字扫描，想必大家都知道不可能这么快的。搜索引擎做了一件事，就是给网页添加索引，就好比图书馆给每本书添加了个编号，这样就加速了我们找书的速度；同样的，有了索引，在索引中找一个关键字和在茫茫的网页中找这个关键字比起来根本就不是一个数量级的。 谈到这个索引，就不得不谈到布尔代数。布尔代数只有0和1两个状态，一开始出现的时候不被人注意，人们认为这么简单的数学没有什么用处，后来香农把它带入了电路后才慢慢进入了人们的视野，人们也慢慢离不开它。 网络爬虫的原理就是模拟浏览器浏览页面，然后把页面上的超链接copy下来。虽然看起来简单，但是互联网上是时刻变化的，可能上一秒爬虫爬过的地方，下一秒就改变了。因此，爬虫在选择爬取链接时要有所取舍，是先爬取页面的首页，还是一条路黑到底，直接爬完。一般页面首页是比较重要的，先把就近的所有第一层超链接爬完再爬下一层就是所谓的“广度优先搜索”；而一个页面一直爬到底再爬下一个页面的是“深度优先搜索”。不过一般实际应用中还要考虑建立新连接需要TCP三次握手的时间，会结合“广度优先搜索”和“深度优先搜索”优点，协调好“广度”与“深度”之间的度。 除了广度与深度之间的度外，网络爬虫要做的工作还有就是页面的分析和URL的提取，并且还有记录好已经爬取过的页面，要做标记，避免重复爬取。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://greedyhao.cc/categories/读书笔记/"}],"tags":[]},{"title":"《数学之美》阅读记录二","slug":"读书笔记-2018-04-03-《数学之美》阅读记录二","date":"2018-04-03T15:42:48.000Z","updated":"2018-09-09T05:52:27.808Z","comments":true,"path":"2018/04/03/读书笔记-2018-04-03-《数学之美》阅读记录二/","link":"","permalink":"http://greedyhao.cc/2018/04/03/读书笔记-2018-04-03-《数学之美》阅读记录二/","excerpt":"《数学之美》阅读记录二 今天比较忙，看的比较少，这部分就介绍了一个令人敬佩的人。","text":"《数学之美》阅读记录二 今天比较忙，看的比较少，这部分就介绍了一个令人敬佩的人。 弗里德里克·贾里尼克（Frederek Jelinek）。 这个人与作者对于中小学生的成长路线的规划比较让我赞同，他们都认为，中小学生的自身成长比课业的学习更加重要。人在成年后学习知识的能力比小时候要强很多，大学学的知识比中小学学的知识加起来还要多很多。小时候没有学习到的课业上的知识可以长大以后再补，但是小时候没有获得应该有的社会经历、社交经验、个人习惯，在长大后就很难再改变了。 不仅仅是这个人的知识的渊博让人佩服，更是他真的能够活到老学到老。在本该退休时，却仍然整天呆在他的实验室中，与他的学生研究问题，而且对学生也是极为负责，从他们的学费生活费，到他们的实习，他都会尽量帮助。对待知识的这种态度让我极为感叹。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://greedyhao.cc/categories/读书笔记/"}],"tags":[]},{"title":"第一天阅读《数学之美》","slug":"读书笔记-2018-04-02-第一天阅读《数学之美》","date":"2018-04-02T15:45:03.000Z","updated":"2018-09-09T05:52:27.808Z","comments":true,"path":"2018/04/02/读书笔记-2018-04-02-第一天阅读《数学之美》/","link":"","permalink":"http://greedyhao.cc/2018/04/02/读书笔记-2018-04-02-第一天阅读《数学之美》/","excerpt":"第一天阅读《数学之美》 之前读书没有做记录，总感觉漏了些什么，决定以后每天读书后做笔记。","text":"第一天阅读《数学之美》 之前读书没有做记录，总感觉漏了些什么，决定以后每天读书后做笔记。 买书纯粹是为了凑单满减，书买来了几个月了，今天闲来没事，就拿来看看。 先上书的图 根据我看的前几章来看，这本书讲的是自然语言处理，从一开始的人与人之间的交流，到我目前看到的，对语言进行词法分析。 自然语言的应用范围就我所知而言，可以应用于语音识别、机器翻译。在20世纪前，自然语言分析发展几乎可以说是无。当时的研究路线是对自然语言使用语法分析，但是理想是丰满的，现实是骨感的。语法分析虽然看起来是非常行的通的，通过二维数据对语句的词进行语法分离，比如：小明打篮球。这个句子按照主谓宾来分，小明是主语，打篮球整体为谓语；再细分的话，打是谓语动词，而篮球是名词。对短句似乎还是没有问题的，但是对于长句的分析是非常困难的，因为对语句进行语法分析需要设定一系列的规则，需要占用大量的算力，这样的程序时间复杂的是指数级别的，一般的计算机根本无法完成这样的计算工作。 随后有人提出了利用数学统计语言模型，而不是语法分析模型。Goole翻译的成功是应用数学统计模型进行自然语言的一大助力。利用统计学建立模型是理论支持是大数定理，大数定理简单来说就是，当一个事件的样本数目足够多的时候，样本中这一事件出现的概率近似于这一事件的概率。通过大数据统计词频，来确认机器翻译时，该翻译成什么词，词的顺序该是怎么样。 统计模型的建立有分一元 二元到多元，代表的意思是模型的建立联系了多少上下文的词，两个词就二元，三个词就三元，一般使用的多是三元模型，到了四元以上的模型建立的性价比就开始下降了，Google搜索使用的是四元模型，但是使用了500多台服务器支撑。 这种基于上下文的分词器，使用了条件概率，当需要基于多个词的分析时，条件概率就会变得非常复杂，因为连条件的条件都是不清晰的。这时就用到了隐含马尔可夫模型，通俗的来说，这是一种偷懒的方法，它不去管条件的条件，它永远只会基于第i-1项求第i项的概率，然后对他们求和。 通信模型同样适用于自然语言模型，解决好编码和解码的问题，自然语言的处理问题就解决大半了。 信息对于自然语言分析是非常重要的，一个系统如果没有信息就只是相当于一个黑盒子，输入的数据量不够，输出自然就不准确；使用过搜索引擎的人都知道，搜索的关键字越多越准确，得到的结果就越是自己想要的。 自然语言处理还有一些复杂的情况，比如有些词有二义性，书中介绍的总统布什Bush就有第二个意思“灌木丛”，当时的机器翻译还不成熟，就把布什翻译成了“灌木丛”。为了解决这个问题，使用了香农提出的互信息，通俗来讲就是，在翻译Bush时，如果同时信息中还出现了总统、白宫等信息，那么就翻译成布什；而附带信息是泥土、潮湿度等信息时，就翻译成灌木丛。而随机变量之间的差别就是条件熵，条件熵越小，差别度越小，这在判断论文是否抄袭很有效，如果是抄袭的论文，会有大量词的词频相近，它们的条件熵比较小。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://greedyhao.cc/categories/读书笔记/"}],"tags":[]},{"title":"hexo d 出错","slug":"工作-hexo-2018-04-01-hexo-d-出错","date":"2018-04-01T08:59:11.000Z","updated":"2018-09-09T05:52:27.812Z","comments":true,"path":"2018/04/01/工作-hexo-2018-04-01-hexo-d-出错/","link":"","permalink":"http://greedyhao.cc/2018/04/01/工作-hexo-2018-04-01-hexo-d-出错/","excerpt":"hexo d 出错 不少新人在使用hexo的时候可能会遇到hexo d无法deploy的问题，这里给出解决方法。","text":"hexo d 出错 不少新人在使用hexo的时候可能会遇到hexo d无法deploy的问题，这里给出解决方法。 出错信息如下： 123456789101112bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &apos;https://github.com&apos;: No errorFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/trouble...Error: bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &apos;https://github.com&apos;: No errorat ChildProcess.&lt;anonymous&gt; (E:\\zan\\www\\gitpages\\hexo\\zanjs.github.io\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:42:17)at emitTwo (events.js:87:13)at ChildProcess.emit (events.js:172:7)at maybeClose (internal/child_process.js:818:16)at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5) 解决问题 添加ssh秘钥 以github为例。进入github的setting，选择SSH and GPG keys 选择NEW SSH key Title随便写，Key写自己生成的ssh key。 git官方给出的ssh秘钥是像下面的这种格式。 1234567$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@agadorlaptop.local 如果_cat ~/.ssh/id_rsa.pub_没有结果的话，就需要生成ssh key。 生成ssh key的命令需要按三次空格键 123456789$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /Users/schacon/.ssh/id_rsa.Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.The key fingerprint is:43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local 更新git版本 如果在添加了ssh key后还是没有解决问题，报HttpRequestException encountered 的错误，那么可能你的git版本太低了，你需要更新你的git版本。 到github的Git-Credential-Manager-for-Windows，下载.exe文件直接安装更新，然后重新测试应该就没有问题了。","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://greedyhao.cc/tags/hexo/"}]},{"title":"虚拟机与主机之间ping不通的解决方法","slug":"工作-Linux-2018-02-05-虚拟机与主机之间ping不通的解决方法","date":"2018-02-05T11:40:54.000Z","updated":"2018-09-09T05:52:27.808Z","comments":true,"path":"2018/02/05/工作-Linux-2018-02-05-虚拟机与主机之间ping不通的解决方法/","link":"","permalink":"http://greedyhao.cc/2018/02/05/工作-Linux-2018-02-05-虚拟机与主机之间ping不通的解决方法/","excerpt":"虚拟机与主机之间ping不通的解决方法 最近需要使用Linux系统，然而我的电脑是Windows系统，所以不可避免使用到了虚拟机；而虚拟机与Windows主机之间需要共享文件，一是使用虚拟机软件的共享文件设置，二就是设置服务器如samba。但是会出现配置好服务器却发现Windows主机无法访问服务器的情况，而且在ping虚拟机的时候会出现ping不同的情况。以下就是这种情况的解决方法。","text":"虚拟机与主机之间ping不通的解决方法 最近需要使用Linux系统，然而我的电脑是Windows系统，所以不可避免使用到了虚拟机；而虚拟机与Windows主机之间需要共享文件，一是使用虚拟机软件的共享文件设置，二就是设置服务器如samba。但是会出现配置好服务器却发现Windows主机无法访问服务器的情况，而且在ping虚拟机的时候会出现ping不同的情况。以下就是这种情况的解决方法。 VirtualBox 由于本人使用的是VirtualBox，所以用作展示的也是VirtualBox。 开启仅主机网络 如图，先要确保虚拟机处于关闭状态，打开 局部设置-&gt;网络-&gt;网卡2，勾选启用网络连接，连接方式选择仅主机网络。 开启后的效果 首先是展示虚拟机的ip地址 展示Windows主机ping虚拟机的结果","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"http://greedyhao.cc/tags/VirtualBox/"}]},{"title":"滤波器设计中的频率归一化问题","slug":"工作-matlab-2018-01-12-滤波器设计中的频率归一化问题","date":"2018-01-12T07:16:17.000Z","updated":"2018-09-08T14:23:27.594Z","comments":true,"path":"2018/01/12/工作-matlab-2018-01-12-滤波器设计中的频率归一化问题/","link":"","permalink":"http://greedyhao.cc/2018/01/12/工作-matlab-2018-01-12-滤波器设计中的频率归一化问题/","excerpt":"","text":"滤波器设计中的频率归一化问题 滤波器介绍 滤波器的设计就是设计滤波器的系数[b,a] 归一化的介绍 信号处理工具箱中经常使用的是nyquist频率，它被定义为采样频率的一半，在滤波器的阶数选择和设计中的截止频率均使用nyquist频率进行归一化处理。 滤波器设计的介绍 本文示例中的滤波器的通频带设计为butter(5,[20/(fs/2) 20/(fs/2)])，5为滤波器阶数，20为你需要设置通过频率的上限或下限，fs为你的采样频率，本文使用nyquist频率进行归一化处理，所以对fs除以2。 如果采样频率Fs=1000Hz，设计一个5阶、通带为100-200Hz的带通滤波器，那么： 1[b,a]=butter(5,[0.2 0.4])=butter(5,[100/(1000/2) 200/(1000/2) ]) 实例分析滤波器 源码 下面是一个简单的滤波器的设计源码： 1234567891011121314fs = 50;% 采样频率Wn=[20/(fs/2) 20/(fs/2)];% 设置通频带N=5;% n阶滤波器[b,a]=butter(N,Wn);t = 0:1/fs:10-1/fs; x = sin(2*pi*15*t) + sin(2*pi*20*t);% 产生一个频率分量为15Hz和20Hz的正弦信号X = fft(x,4096);% 频域分析f = (0:length(X)-1)*fs/length(X);subplot(221);plot(t,x);title(&apos;滤波前信号的波形(a)&apos;);subplot(222);plot(f,abs(X));title(&apos;滤波前信号的频谱(b)&apos;);y=filter(b,a,x);Y=fft(y,4096);subplot(223);plot(t,y);title(&apos;滤波后信号的波形(c)&apos;);subplot(224);plot(f,abs(Y));title(&apos;滤波后信号的频谱(d)&apos;); 滤波器效果图及分析 图a和图b是未处理的信号波形，从b图可以看出这个正弦信号有两个频率分量 图c和图d是处理后的信号波形，从d图可以看出此时只有20Hz这一个频率分量了","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://greedyhao.cc/tags/Matlab/"},{"name":"数字滤波","slug":"数字滤波","permalink":"http://greedyhao.cc/tags/数字滤波/"}]},{"title":"Matlab内建函数中文文档","slug":"工作-matlab-2018-01-11-Matlab内建函数中文文档","date":"2018-01-11T13:45:10.000Z","updated":"2018-09-09T05:52:27.812Z","comments":true,"path":"2018/01/11/工作-matlab-2018-01-11-Matlab内建函数中文文档/","link":"","permalink":"http://greedyhao.cc/2018/01/11/工作-matlab-2018-01-11-Matlab内建函数中文文档/","excerpt":"Matlab内建函数中文文档 此部分内容会随着我的使用而更新，大部分来自有道翻译。","text":"Matlab内建函数中文文档 此部分内容会随着我的使用而更新，大部分来自有道翻译。 基本信号 阶跃信号 矩形信号 rectpuls 矩形脉冲 画图函数 plot fplot 示例 123456789fplot(f)fplot(f,xinterval)fplot(xt,yt)fplot(xt,yt,tinterval)fplot(___,LineSpec)fplot(___,Name,Value)fplot(ax,___)fp = fplot(___)[x,y] = fplot(___) 描述 fplot(f) 在x轴以默认间隔[-5,5]画出输入的f函数 fplot(f,xinterval) 对f增加了plot的间隔限制。xinterval=[xmin xmax] stairs 示例 1234567stairs(Y)stairs(X,Y)stairs(___,LineSpec)stairs(___,Name,Value)stairs(ax,___)h = stairs(___)[xb,yb] = stairs(___) 描述 stairs(Y) 通过Y中的元素以阶梯状的方式plot 如果Y是向量，那么stairs画一条线 如果Y是矩阵，那么stairs对矩阵的每一行的元素画一条线 stairs(X,Y) 把Y中的元素用X的位置plot出来。X和Y需要是同样大小的向量或者矩阵。此外，X可以是行向量或者列向量但Y这个矩阵的行需要是X的长度。 subplot 在平铺的位置创建轴线（画子图） 示例 12345678subplot(m,n,p)subplot(m,n,p,&apos;replace&apos;)subplot(m,n,p,&apos;align&apos;)subplot(&apos;Position&apos;,positionVector)subplot(m,n,p,ax)subplot(___,Name,Value)h = subplot(___)subplot(h) 描述 下面给出subplot的简单示例，方便了解用法 subplot(m,n,p) m表示行，n表示列，p表示第几张图。图的标号从第一行第一列开始，(1,1)(1,2)(2,1)…对应1,2,3… axis 限制坐标大小 示例 1axis(limits) 描述 axis(limits) 设置当前坐标系限制。如果是笛卡尔坐标系，需要四个向量[xmin xmax ymin ymax]对x，y限制。如果是Z坐标系，需要六个向量。如果还要设置颜色限制，需要八个向量限制。如果是极坐标系，需要四个向量限制theta-axis和r-axis。 傅里叶家族 FFT 快速傅里叶变换 示例 123Y = fft(X)Y = fft(X,n)Y = fft(X,n,dim) 描述 Y = fft(X) 利用快速傅里叶变换(FFT)算法计算X离散傅里叶变换(DFT)。 如果X是一个向量，那么fft(X)返回向量的傅里叶变换。 如果X是一个矩阵，那么fft(X)将X的列视为向量，并返回每个列的傅里叶变换。 如果X是一个多维数组，那么fft(X)将处理第一个数组维度上的值，其大小不等于1作为向量，并返回每个向量的傅里叶变换。 Y = fft(X,n) 返回n-point DFT。如果没有指定值，则Y的大小与X相同。 如果X是一个向量且X的长度小于n，那么X就会被加上后面的0到n。 如果X是一个向量且X的长度大于n，那么X就被截断为n的长度。 如果X是一个矩阵，那么每一列都被当成向量的情况处理。 如果X是一个多维数组，那么第一个大小不等于1的数组维度将被当成向量的情况处理。 Y = fft(X,n,dim) 返回沿着维度的傅里叶变换。例如,如果X是一个矩阵,那么fft(X,n,2)返回每一行的n-point傅里叶变换。 过滤器家族 filter 1-D数字滤波器 示例 1234y = filter(b,a,x)y = filter(b,a,x,zi)y = filter(b,a,x,zi,dim)[y,zf] = filter(___) 描述 y = filter(b,a,x) 过滤输入数据x使用有理传递函数定义的分子和分母系数b和a。 如果a(1)不等于1，滤波器的系数由a(1)归一化。因此，a(1)必须是非零的。 如果x是一个向量，那么过滤器将过滤后的数据作为与x相同大小的向量返回。 如果x是一个矩阵，那么过滤器沿着第一个维度进行操作，并返回每个列的过滤数据。 如果x是一个多维数组，那么过滤器沿着第一个大小不等于1的数组维度作用。 y = filter(b,a,x,zi) 初始条件zi作为过滤延迟的初始条件。zi的长度必须等于max(length(a)，length(b))-1。 y = filter(b,a,x,zi,dim) 沿着维度进行强度调制，例如，如果x是一个矩阵，那么 filter(b,a,x,zi,2) 返回每一行的过滤数据。 [y,zf] = filter(___) 还使用前面的任何语法，返回过滤器延迟的最终条件zf。 butter 巴特沃斯滤波器的设计 示例 12345[b,a] = butter(n,Wn)[b,a] = butter(n,Wn,ftype)[z,p,k] = butter(___)[A,B,C,D] = butter(___)[___] = butter(___,&apos;s&apos;) 描述 [b,a] = butter(n,Wn) 返回一个n阶低通数字巴特沃斯滤波器的传递函数系数，并将其截止频率归一化为 Wn。 [b,a] = butter(n,Wn,ftype) 设计了一个低通、高通、带通或带带阻巴特沃斯滤波器，取决于ftype的值和Wn的元素个数。带通和带阻设计的结果是2n阶的。 Note: 关于影响形成传递函数的数值问题的信息，请参见限制。 [z,p,k] = butter(___) 设计一个低通、高通、带通或带阻的数字巴特沃斯滤波器，并返回其零点、极点和增益。此语法可以包含之前语句中的输入的任何参数。 [A,B,C,D] = butter(___) 设计一个低通，高通，带通，或带阻数字巴特沃斯滤波器，并返回指定其状态空间表示的矩阵。 [_**] = butter(_**,’s’) 设计了一个低通、高通、带通、或阻的模拟巴特沃斯滤波器，截止角频率为Wn。","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://greedyhao.cc/tags/Matlab/"}]},{"title":"Windows配置Java环境","slug":"工作-java-2018-01-10-Windows配置Java环境","date":"2018-01-10T13:45:29.000Z","updated":"2018-09-09T05:52:27.812Z","comments":true,"path":"2018/01/10/工作-java-2018-01-10-Windows配置Java环境/","link":"","permalink":"http://greedyhao.cc/2018/01/10/工作-java-2018-01-10-Windows配置Java环境/","excerpt":"Windows配置Java环境 很多软件的安装都需要Java环境，很多新人安装完Java后发现电脑还是没有Java环境，这是因为Java的安装程序没有自动添加到PATH，这部分得自己手动操作。","text":"Windows配置Java环境 很多软件的安装都需要Java环境，很多新人安装完Java后发现电脑还是没有Java环境，这是因为Java的安装程序没有自动添加到PATH，这部分得自己手动操作。 安装Java 第一步是先去下载安装软件，可以安装JDK也可以只安装JRE，这个看个人喜好，JDK包含JRE。 安装步骤省略，可以直接就默认位置安装，反正也不大。自定义位置时注意，安装JDK时选择的JDK和JRE安装文件夹最好处于同级，不能把JRE装到JDK的目录下。 配置Java环境 进入到系统环境变量 右键电脑，选择属性 点击系统设置 点击环境变量 将Java添加到环境变量 点击新建 变量名填写Java_Home，变量值为JDK安装路径，默认安装路径为C:1.8.0_144 选择PATH（找不到就新建一个PATH） 如果系统PATH中有个javapath就把它删除，或者下移到你自己添加的java路径的后面 点击新建，添加**%Java_Home%*和**%Java_Home%* 新建一个CLASSPATH，如图添加.;%Java_Home%;%Java_Home%.jar;%Java_Home%.jar 测试是否添加成功 win+R，调出运行窗口，输入cmd。如图显示则添加成功","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://greedyhao.cc/tags/Java/"}]},{"title":"数组指针和指针数组的区别","slug":"工作-c-language-2017-11-15-数组指针和指针数组的区别","date":"2017-11-15T06:29:09.000Z","updated":"2018-09-09T05:52:27.812Z","comments":true,"path":"2017/11/15/工作-c-language-2017-11-15-数组指针和指针数组的区别/","link":"","permalink":"http://greedyhao.cc/2017/11/15/工作-c-language-2017-11-15-数组指针和指针数组的区别/","excerpt":"数组指针和指针数组的区别 简单来说： 数组指针–&gt;;指向数组的指针 指针数组–&gt;;存放指针的数组","text":"数组指针和指针数组的区别 简单来说： 数组指针–&gt;;指向数组的指针 指针数组–&gt;;存放指针的数组 数组指针 123int matrix[3][10];int *mp = matrix; //错误的声明int (*p)[10] = matrix; //正确的声明 声明一个指向多维数组的指针时，需要注意，二维及以上的数组长度需要声明出来，因为在执行下标引用时需要知道数组的长度，然后对下标乘以某个数（比如int型的×4）。如果声明的时候没有数组长度比如 **int (*p)[] = matrix;** ，编译器会把这个数组指针根据空数组调整（也就是同零相乘）。 指针数组 1234int main(int argc, char const *argv[]) &#123; /* code */ return 0;&#125; main函数的参数就是一个常见的指针数组的例子了，在数组中存放指针，也可以是字符串数组。 区别 指针数组和数组指针能做的事都差不多。数组指针占用空间的方式事矩阵，虽然效率低，但是不需要任何指针；指针数组占用的空间则只是每个指针本身的长度。 需要存放长短不一的字符串的时候，指针数组的效率就会比数组指针的效率高很多了。","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://greedyhao.cc/tags/c语言/"}]},{"title":"C语言函数参数的传值和传址调用","slug":"工作-c-language-2017-11-14-C语言函数参数的传值和传址调用","date":"2017-11-14T00:36:58.000Z","updated":"2018-09-08T14:04:13.196Z","comments":true,"path":"2017/11/14/工作-c-language-2017-11-14-C语言函数参数的传值和传址调用/","link":"","permalink":"http://greedyhao.cc/2017/11/14/工作-c-language-2017-11-14-C语言函数参数的传值和传址调用/","excerpt":"","text":"C语言函数参数的传值和传址调用 大家都知道，c语言一般的参数都是传值调用的，但有时候也有例外，下面就分析一下什么时候传值调用，什么时候传址调用。 传值调用 标量参数都是传值调用，不会对标量产生任何影响 1234567891011#include &lt;stdio.h&gt;void add_one(int value) &#123; value += 1;&#125;int main(int argc, char const *argv[]) &#123; int value = 10; printf(\"传值前value=%d\\n\", value); add_one(value); printf(\"传值后value=%d\\n\", value); return 0;&#125; 运行结果： 1234传值前value=10传值后value=10Process returned 0 (0x0) execution time : 0.110 sPress any key to continue. 传址调用 数组和指针参数是传址调用，相当于传递了一个包含参数地址的指针，在函数中对数组或指针的任何操作会间接的改变数组和指针的本身 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#define SIZE 4void clr_nums(int nums[], int size) &#123; int i; for (i = 0; i &lt; size; i++) &#123; nums[i] = 0; &#125;&#125;void clr_string(int *string) &#123; *string = \" \";&#125;int main(int argc, char const *argv[]) &#123; int nums[] = &#123;1,2,3,4&#125;; int *string = \"Hello\"; int i; printf(\"传址前\\n\"); printf(\"nums= \"); for (i = 0; i &lt; SIZE; i++) &#123; printf(\"%d \", nums[i]); &#125; printf(\"string=%s\\n\", string); clr_nums(nums, SIZE); clr_string(&amp;string); printf(\"传址后\\n\"); printf(\"nums= \"); for (i = 0; i &lt; SIZE; i++) &#123; printf(\"%d \", nums[i]); &#125; printf(\"string=%s\\n\", string); return 0;&#125; 运行结果： 123456传址前nums= 1 2 3 4 string=Hello传址后nums= 0 0 0 0 string=Process returned 0 (0x0) execution time : 0.111 sPress any key to continue.","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://greedyhao.cc/tags/c语言/"}]},{"title":"esp8266_GPIO控制","slug":"工作-wifi-2017-10-20-esp8266-GPIO控制","date":"2017-10-20T07:21:37.000Z","updated":"2018-09-08T13:58:55.818Z","comments":true,"path":"2017/10/20/工作-wifi-2017-10-20-esp8266-GPIO控制/","link":"","permalink":"http://greedyhao.cc/2017/10/20/工作-wifi-2017-10-20-esp8266-GPIO控制/","excerpt":"","text":"esp8266_GPIO控制 让esp8266连接上机智云后，要控制GPIO，说实话，在官方文档找不到相应的描述，浪费了我很多时间，最后还是在论坛上找到了类似的例子才解决这个问题，现在记录下来方便参考。 GPIO初始化 用过ARM微处理器的都知道，控制GPIO前，先要进行GPIO的初始化。下面上个GPIO13初始化的例子。 123#include &lt;gpio.h&gt;//user_main.cPIN_FUNC_SELECT(PERIPHS_IO_MUX_MTCK_U, FUNC_GPIO13); //GPIO13初始化 将上面这两句命令加入到 user_main.c 文件中的 user_init() 函数中就可以完成对GPIO13的初始化。 对 PERIPHS_IO_MUX_MTCK_U 和 FUNC_GPIO13 的描述在 eagle_soc.h 文件中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//eagle_soc.h...//PIN Mux reg &#123;&#123;#define PERIPHS_IO_MUX_FUNC 0x13#define PERIPHS_IO_MUX_FUNC_S 4#define PERIPHS_IO_MUX_PULLUP BIT7#define PERIPHS_IO_MUX_PULLUP2 BIT6#define PERIPHS_IO_MUX_SLEEP_PULLUP BIT3#define PERIPHS_IO_MUX_SLEEP_PULLUP2 BIT2#define PERIPHS_IO_MUX_SLEEP_OE BIT1#define PERIPHS_IO_MUX_OE BIT0#define PERIPHS_IO_MUX_CONF_U (PERIPHS_IO_MUX + 0x00)#define SPI0_CLK_EQU_SYS_CLK BIT8#define SPI1_CLK_EQU_SYS_CLK BIT9#define PERIPHS_IO_MUX_MTDI_U (PERIPHS_IO_MUX + 0x04)#define FUNC_GPIO12 3#define PERIPHS_IO_MUX_MTCK_U (PERIPHS_IO_MUX + 0x08)#define FUNC_GPIO13 3#define PERIPHS_IO_MUX_MTMS_U (PERIPHS_IO_MUX + 0x0C)#define FUNC_GPIO14 3#define PERIPHS_IO_MUX_MTDO_U (PERIPHS_IO_MUX + 0x10)#define FUNC_GPIO15 3#define FUNC_U0RTS 4#define PERIPHS_IO_MUX_U0RXD_U (PERIPHS_IO_MUX + 0x14)#define FUNC_GPIO3 3#define PERIPHS_IO_MUX_U0TXD_U (PERIPHS_IO_MUX + 0x18)#define FUNC_U0TXD 0#define FUNC_GPIO1 3#define PERIPHS_IO_MUX_SD_CLK_U (PERIPHS_IO_MUX + 0x1c)#define FUNC_SDCLK 0#define FUNC_SPICLK 1#define PERIPHS_IO_MUX_SD_DATA0_U (PERIPHS_IO_MUX + 0x20)#define FUNC_SDDATA0 0#define FUNC_SPIQ 1#define FUNC_U1TXD 4#define PERIPHS_IO_MUX_SD_DATA1_U (PERIPHS_IO_MUX + 0x24)#define FUNC_SDDATA1 0#define FUNC_SPID 1#define FUNC_U1RXD 4#define FUNC_SDDATA1_U1RXD 7#define PERIPHS_IO_MUX_SD_DATA2_U (PERIPHS_IO_MUX + 0x28)#define FUNC_SDDATA2 0#define FUNC_SPIHD 1#define FUNC_GPIO9 3#define PERIPHS_IO_MUX_SD_DATA3_U (PERIPHS_IO_MUX + 0x2c)#define FUNC_SDDATA3 0#define FUNC_SPIWP 1#define FUNC_GPIO10 3#define PERIPHS_IO_MUX_SD_CMD_U (PERIPHS_IO_MUX + 0x30)#define FUNC_SDCMD 0#define FUNC_SPICS0 1#define PERIPHS_IO_MUX_GPIO0_U (PERIPHS_IO_MUX + 0x34)#define FUNC_GPIO0 0#define PERIPHS_IO_MUX_GPIO2_U (PERIPHS_IO_MUX + 0x38)#define FUNC_GPIO2 0#define FUNC_U1TXD_BK 2#define FUNC_U0TXD_BK 4#define PERIPHS_IO_MUX_GPIO4_U (PERIPHS_IO_MUX + 0x3C)#define FUNC_GPIO4 0#define PERIPHS_IO_MUX_GPIO5_U (PERIPHS_IO_MUX + 0x40)#define FUNC_GPIO5 0#define PIN_PULLUP_DIS(PIN_NAME) CLEAR_PERI_REG_MASK(PIN_NAME, PERIPHS_IO_MUX_PULLUP)#define PIN_PULLUP_EN(PIN_NAME) SET_PERI_REG_MASK(PIN_NAME, PERIPHS_IO_MUX_PULLUP)... 设置GPIO模式 我们都知道GPIO有几种模式，输出输入等等。 12#include &lt;gpio.h&gt;GPIO_OUTPUT_SET(GPIO_ID_PIN(13), 0);//GPIO13 低电平输出 上面这句就设置GPIO13低电平输出，要想读取输入需要先使用GPIO_DIS_OUTPUT(gpio_no) disable输出，再用GPIO_INPUT_GET(gpio_no)获取输入。 1234#define GPIO_OUTPUT_SET(gpio_no, bit_value) \\ gpio_output_set((bit_value)&lt;&lt;gpio_no, ((~(bit_value))&amp;0x01)&lt;&lt;gpio_no, 1&lt;&lt;gpio_no,0)#define GPIO_DIS_OUTPUT(gpio_no) gpio_output_set(0,0,0, 1&lt;&lt;gpio_no)#define GPIO_INPUT_GET(gpio_no) ((gpio_input_get()&gt;&gt;gpio_no)&amp;BIT0)","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"esp8266","slug":"esp8266","permalink":"http://greedyhao.cc/tags/esp8266/"},{"name":"wifi","slug":"wifi","permalink":"http://greedyhao.cc/tags/wifi/"}]},{"title":"esp8266连接机智云平台","slug":"工作-wifi-2017-10-19-esp8266连接机智云平台","date":"2017-10-19T05:16:33.000Z","updated":"2018-09-08T13:54:24.761Z","comments":true,"path":"2017/10/19/工作-wifi-2017-10-19-esp8266连接机智云平台/","link":"","permalink":"http://greedyhao.cc/2017/10/19/工作-wifi-2017-10-19-esp8266连接机智云平台/","excerpt":"","text":"esp8266连接机智云平台 为了方便的控制esp8266，我需要选择一个合适的iot平台。我选择了机智云，主要是用起来方便，很多细节都不用我来操心。为了连接上机智云平台，首先需要给esp8266烧录gagent，烧录的教程看这里。 下载GAgnet并烧录 点击下载GAgent，下载完成后可以看见8Mbit 16Mbit 32Mbit版本，暂时我没有发现这几个版本有什么不同，我都烧过了，效果差不多，01s版本的flash比较小，可能选择比较少。 使用机智云串口调试助手检查是否烧录成功 点击下载机智云串口调试助手 打开后在底端选择模拟V4MCU，波特率选择9600，在接收栏点击接收的内容可以显示接收的数据具体信息。 如果有接收到数据则证明烧录GAgent成功 esp8266连接机智云平台 机智云串口调试助手 打开指令界面–&gt;;Softap 此时周围有个XPG-GAgent-xxxx的wifi 切换到机智云Demo APP 官方有提供SDK可以制作自己的APP，如果不会的可以直接使用官方的Demo，这是机智云APP下载地址。 选择添加设备 输入路由wifi的名称和密码，点击下一步 选择对应的模组，我的esp8266是乐鑫的 勾选已完成上述描述点击下一步 如果第一次没有搜索到自己的设备会回到上一步骤，重新检查一下wifi名称密码是否正确，确认esp8266的wifi是否处于开启状态，重新点击下一步即可。 这是APP找到了esp8266的结果 成功连接！ 在路由器的管理界面可以看见esp8266的连接状态 esp8266连接路由器教程就此结束。","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"esp8266","slug":"esp8266","permalink":"http://greedyhao.cc/tags/esp8266/"},{"name":"wifi","slug":"wifi","permalink":"http://greedyhao.cc/tags/wifi/"}]},{"title":"esp8266烧写固件","slug":"工作-wifi-2017-10-11-esp8266烧写固件","date":"2017-10-10T23:41:43.000Z","updated":"2018-09-08T13:05:40.409Z","comments":true,"path":"2017/10/11/工作-wifi-2017-10-11-esp8266烧写固件/","link":"","permalink":"http://greedyhao.cc/2017/10/11/工作-wifi-2017-10-11-esp8266烧写固件/","excerpt":"","text":"esp8266烧写固件 这段时间想用esp8266做一个wifi探针，顺便想做智能家居，但是碰上了烧写固件的难题，花了我挺多时间去学习，于是写下来，给大家做一个参考，也可以留作备忘。 tips: 本人使用的是esp-07，但是其他的型号也是差不多的，可以参考。 进入烧录模式 接线示意图 GPIO15 GPIO0 GPIO2 H X X L L H L H H tips: H表示高电平，L表示低电平，X表示电平无影响 转换到烧录模式唯一需要动的就是GPIO0，其他的都不需要动，电阻也不需要加。我刚开始还以为要加电阻还有那复杂的连线，发现不行后，看了好多遍资料才明白原来只用在上电前拉低GPIO。 本着不做重复的事情的原则，就制作了一个esp8266的烧录板，上个图给大家看看，烙铁很少用，所以走锡有点丑。 我就使用了一个六脚自锁开关，按下去就将GPIO0接地。 使用烧录软件进行烧录 使用Flash下载工具烧录 点击这里获取Flash下载工具 解压后进入../flash_download_tools_v3.6.1.0_0/FLASH_DOWNLOAD_TOOLS_V3.6.1.0，点击ESPFlashDownloadTool_v3.6.1.0.exe， 选择对应的型号 这种combine的包直接烧在0x0位置就好；SPI速度选最快40MHz，如果烧录失败再降低速度；SPI MODE选择DIO；FLASH SIZE按照你的型号选择，不知道就选个8Mbit吧；下面的COM选择你esp8266的端口；波特率115200。 烧录中… 烧录完成！ 使用Arduino烧录 首先需要下载Arduino，需要1.6.x版本以上，因为下载Arduino需要科学上网，在Arduino中文社区有提供网盘下载Arduino IDE 下载 接下就是安装esp8266的库，这是官方说明。 第一种操作 安装好Arduino后打开 选择文件&gt;首选项，在_附加开发板管理器网址_中输入_http://arduino.esp8266.com/stable/package_esp8266com_index.json_ 选择项目&gt;加载库&gt;管理库，搜索esp8266并下载安装。 第二种操作 你需要安装git，进入你Arduino的安装位置，进入hardware 克隆这个esp8266库到本地 1234cd hardwaremkdir esp8266comcd esp8266comgit clone https://github.com/esp8266/Arduino.git esp8266 下载binarytools（需要python2.7） 12cd esp8266/toolspython get.py 重启Arduino 让esp8266进入烧录模式，选择对应的esp型号 点击上传按钮进行烧录 烧录成功","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"esp8266","slug":"esp8266","permalink":"http://greedyhao.cc/tags/esp8266/"},{"name":"wifi","slug":"wifi","permalink":"http://greedyhao.cc/tags/wifi/"}]},{"title":"对fork的进一步理解","slug":"工作-Linux-2017-09-25-对fork的进一步理解","date":"2017-09-25T00:57:27.000Z","updated":"2018-09-08T12:57:47.796Z","comments":true,"path":"2017/09/25/工作-Linux-2017-09-25-对fork的进一步理解/","link":"","permalink":"http://greedyhao.cc/2017/09/25/工作-Linux-2017-09-25-对fork的进一步理解/","excerpt":"","text":"对fork的进一步理解 最近在看Unix的源码，没想到让我对Linux的认知有了更深的理解。 上一张我在书上看到的图 123456789101112#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; pid_t pid; pid = fork (); if (pid &gt; 0) //父进程 printf(&quot;I am the parent of pid=%d\\n&quot;, pid); else if (!pid) //子进程 printf(&quot;I am the child!\\n&quot;); return 0;&#125; 输出结果： 123hao@LAPTOP-SSIGRLRD:/Desktop$ ./forkI am the parent of pid=29I am the child! fork会针对父进程和子进程各返回一次，给父进程返回子进程的pid，此时pid&gt;0；给子进程分配一个 新的pid。 相关文章 进程创建和运行","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"}]},{"title":"c语言速学版","slug":"工作-c-language-2017-09-09-c语言速学版","date":"2017-09-09T14:08:36.000Z","updated":"2017-09-13T13:11:56.000Z","comments":true,"path":"2017/09/09/工作-c-language-2017-09-09-c语言速学版/","link":"","permalink":"http://greedyhao.cc/2017/09/09/工作-c-language-2017-09-09-c语言速学版/","excerpt":"本文只是简单介绍c语言，涉及到计算机原理的知识不会在这里讲解，建议再额外的阅读其他的c语言的书，如《C Primer Plus》《K&amp;R C》等；学习c语言是需要计算机原理的知识的，如果没有可以阅读老刘的系列教程，并关注 码农翻身 公众号获取他的最新教程。学校发的谭某教材就算了吧，不怎么好用，据说还有些错误的地方，而且谭某使用的IDE软件不推荐使用。","text":"本文只是简单介绍c语言，涉及到计算机原理的知识不会在这里讲解，建议再额外的阅读其他的c语言的书，如《C Primer Plus》《K&amp;R C》等；学习c语言是需要计算机原理的知识的，如果没有可以阅读老刘的系列教程，并关注 码农翻身 公众号获取他的最新教程。学校发的谭某教材就算了吧，不怎么好用，据说还有些错误的地方，而且谭某使用的IDE软件不推荐使用。 你需要学会什么 使用什么IDE CodeBlocks CodeBlocks的代码补全能力很强，用着感觉很爽，写代码效率很高。另外奉上CodeBlocks创建c项目教程 windows版下载 其他版本在这里查找对应版本 Dev-C++ windows版下载 不推荐使用windows的文本文档编程，别人的程序放进去还有可能会乱码，而且界面看起来low，用过就知道确实不好用；如果真的不想用这些比较重的IDE，可以选择使用sublime atom这类编辑器 代码规范 代码基本规则 在 .c 源文件开头引入源文件使用到的库函数的 .h 头文件 main 函数作为程序的入口函数，代码从这里开始运行 main 函数的返回类型使用 int 每一句代码以 ; 结尾 其他一些默认代码规范 既然要写代码，肯定要遵循写代码的规则，本教程中的代码都会是符合默认的规范的；但是不同的公司对代码的编写规范可能略微的不同，今后在工作中更是要按照公司的规范编写代码。 个人建议可以参考RT-Thread 编程风格 数据类型 数据类型的话，一般整数用 int，上亿的数为了保险就用 long long；字符用 char；有小数的叫做 浮点数，不管什么，直接用 double，就好；无符号的就在前面加上 unsigned。 下面展示的是所有的数据类型表示数据的大小，有很多没见过也没关系，先见一面。 12345678910111213141516171819202122#include &lt;limits.h&gt;#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; printf(\"signed char类型的对象的最小值：%d\\n\", SCHAR_MIN); printf(\"signed char类型的对象的最大值：%d\\n\", SCHAR_MAX); printf(\"unsigned char类型的对象的最大值：%u\\n\", UCHAR_MAX); printf(\"char类型的对象的最小值：%d\\n\", CHAR_MIN); printf(\"char类型的对象的最大值：%d\\n\", CHAR_MAX); printf(\"short int类型的对象的最大值：%d\\n\", SHRT_MIN); printf(\"short int类型的对象的最大值：%d\\n\", SHRT_MAX); printf(\"unsigned short int类型的对象的最大值：%u\\n\", USHRT_MAX); printf(\"int类型的对象的最小值：%d\\n\", INT_MIN); printf(\"int类型的对象的最大值：%d\\n\", INT_MAX); printf(\"unsigned int类型的对象的最大值：%u\\n\", UINT_MAX); printf(\"long int类型的对象的最小值：%ld\\n\", LONG_MIN); printf(\"long int类型的对象的最大值：%ld\\n\", LONG_MAX); printf(\"unsigned long int类型的对象的最大值：%lu\\n\", ULONG_MAX); return 0;&#125; c语言标准I/O 1234567891011121314#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; //不用在意 int argc, char const *argv[] ，只是让你知道有这么一个东西而已 printf(\"这可以输出你想输出的\\n\"); printf(\"Even only a '\\\\n' is OK\"); printf(\"\\n\"); int num; printf(\"输入一个你想输出的数字： \"); scanf(\"%d\", &amp;num); //不能忽略'&amp;'符号 printf(\"The num is %d\\n\", num); return 0;&#125; 从上面这段程序就可以看出 输入 scanf 和 输出 printf 的使用方法了。 格式化输入输出 12scanf(\"%d\", &amp;num); //不能忽略'&amp;'符号printf(\"The num is %d\\n\", num); 注意到这两句代码的 %d 了没，这就是格式化输入输出，也叫做转换说明。就记个 %d %p %s %c 差不多就够用了，其他的以后用到了再学。 转换说明 输出 %a 浮点数、十六进制数和p-记数法(C99) %A 浮点数、十六进制数和p-记数法(C99) %c 一个字符 %d 有符号十进制整数 %e 浮点数、e-记数法 %E 浮点数、E-记数法 %f 浮点数、十进制记数法 %g 根据数值不同自动选择%f或%e。%e格式在指数小于-4或者大于等于精度时使用 %G 根据数值不同自动选择%f或%E。%E格式在指数小于-4或者大于等于精度时使用 %i 有符号十进制整数（与%d相同） %o 无符号八进制整数 %p 指针 %s 字符串 %u 无符号十进制整数 %x 使用十六进制数字0f的无符号十六进制整数 %X 使用十六进制数字0F的无符号十六进制整数 %% 打印一个百分号 字符与字符串 上图就是一个字符串&quot;Hello&quot;，但是占据了6个空间，由6个字符构成，末尾有个''字符。 这是因为c语言需要这个字符''来表示这是一个完整的字符串。 以下是最常见的Ascii字符 运算符与表达式 基本运算符 123456789101112#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; printf(\"1+2=%d\\n\", 1+2); //加 printf(\"2-1=%d\\n\", 2-1); //减 printf(\"1*2=%d\\n\", 1*2); //乘 printf(\"1/3.0=%f\\n\", 1/3.0); //浮点数的除法 printf(\"1/3=%d\\n\", 1/3); //整数除法取整(整数部分) printf(\"1%%3=%d\\n\", 1%3); //整数除法取模(余数部分) return 0;&#125; 循环 for 123456789101112#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int n; for (n = 10; n &gt; 0; n--) &#123; &#125; return 0;&#125; while 123456789101112#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int n = 10; while (n &gt; 0) &#123; n--; &#125; return 0;&#125; do-while 123456789101112#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int n = 10; do &#123; n--; &#125; while(n &gt; 0); return 0;&#125; 判断与分支 if-else 123456789101112131415161718192021#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int n; printf(\"Input a num: \"); scanf(\"%d\", &amp;n); if (n &gt; 0) &#123; n--; &#125; else if (n &lt; 0)&#123; n++; &#125; else &#123; ; &#125; printf(\"n=%d\\n\", n); return 0;&#125; switch-case 12345678910111213141516#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int n; printf(\"Input a num: \"); scanf(\"%d\", &amp;n); switch (n) &#123; case 1: printf(\"a\\n\");break; case 2: printf(\"b\\n\");break; case 3: printf(\"c\\n\");break; &#125; return 0;&#125; 函数 数组 指针 参考源 printf()、scanf()用法总结及其格式转换说明符","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"},{"name":"c语言","slug":"c语言","permalink":"http://greedyhao.cc/tags/c语言/"}]},{"title":"CodeBlocks创建c项目教程","slug":"工作-c-language-2017-09-09-CodeBlocks创建c项目教程","date":"2017-09-09T13:49:57.000Z","updated":"2017-09-09T13:49:57.000Z","comments":true,"path":"2017/09/09/工作-c-language-2017-09-09-CodeBlocks创建c项目教程/","link":"","permalink":"http://greedyhao.cc/2017/09/09/工作-c-language-2017-09-09-CodeBlocks创建c项目教程/","excerpt":"","text":"新建一个空项目 点击Next project title写你自己想要的项目名 点击Finish 新建一个Empty file，保存为.c文件 右击项目，点击Add files，选择你的文件 点击OK 编译运行","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"}]},{"title":"内存空间分配","slug":"工作-Linux-2017-09-08-内存空间分配","date":"2017-09-08T12:51:10.000Z","updated":"2017-09-08T13:02:19.000Z","comments":true,"path":"2017/09/08/工作-Linux-2017-09-08-内存空间分配/","link":"","permalink":"http://greedyhao.cc/2017/09/08/工作-Linux-2017-09-08-内存空间分配/","excerpt":"glibc的malloc实现，会按照分配内存大小的不同而使用不用的方法，小空间的分配会直接使用堆，大空间的分配使用的就是匿名内存映射。(目前是以128KB的空间为大小的界限)","text":"glibc的malloc实现，会按照分配内存大小的不同而使用不用的方法，小空间的分配会直接使用堆，大空间的分配使用的就是匿名内存映射。(目前是以128KB的空间为大小的界限) 堆实现 简单的说，就是把数据段切分为一系列2的整数幂大小的块，然后相邻的分区，哪里有位置，就使用哪里的内存；不用了就标记一个&quot;不使用&quot;。一般堆的顶端都有一个端点，如果当前堆顶是空的，可以调用 brk()，降低断点的位置，将空间返还给系统。 我理解的内部碎片和外部碎片 堆实现的这个&quot;伙伴内存分配算法&quot;，虽然高速简单，但是会产生&quot;内部碎片&quot;和&quot;外部碎片&quot;。内部碎片降低空间的利用率。外部碎片则是有内存空间却由于被分成不同块而无法使用。 内存映射实现 匿名内存映射和基于文件的映射很像，匿名内存映射使用 mmap() 时，start 参数使用NULL，也就是说不管映射在什么地方，所以叫匿名。 使用匿名内存映射后，妈妈再也不用担心我的内存碎片问题了，不用直接取消映射就好，想用再映射回来。但是凡事有优点就有缺点，每个内存映射都是页的大小的整数倍，也就是说，需要分配的空间越小，对空间的浪费就越多；所以只有在对大量空间分配时才使用内存映射。 参考源 Linux System Programming,Second Edition,by Robert Love(O'Reilly).Copyright 2013 Robert Love,978-1-449-33953-1","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"}]},{"title":"堆栈和堆的区别","slug":"工作-Linux-2017-09-07-堆栈和堆的区别","date":"2017-09-07T01:39:00.000Z","updated":"2017-09-07T04:23:32.000Z","comments":true,"path":"2017/09/07/工作-Linux-2017-09-07-堆栈和堆的区别/","link":"","permalink":"http://greedyhao.cc/2017/09/07/工作-Linux-2017-09-07-堆栈和堆的区别/","excerpt":"在我初学c语言的时候就对堆栈和堆感到很迷惑了，感觉这个东西很抽象，以为堆栈就是堆和栈。","text":"在我初学c语言的时候就对堆栈和堆感到很迷惑了，感觉这个东西很抽象，以为堆栈就是堆和栈。 之所以会混淆堆栈和堆，是因为这是从中文进行理解的，如果是看英文就不会了。 堆栈的英文是stack，堆的英文是heap。 stack包括一个进程的执行栈，其中包括了程序的局部变量和函数的返回值，栈的长度会随着程序的进行变化。stack主要是使用PUSH POP操作的，黑客可以利用缓冲区溢出修改函数的返回地址，让这个地址指向自己想执行的函数，就可以控制这个系统了；不过目前的系统对缓冲区溢出的保护都加强了，已经不是那么容易攻击的了。 heap也叫数据段(data segment)，包含一个进程的动态内存空间。heap是可以写的，而且他的大小也是可以变化的。可以通过alloc的一系列函数对heap空间进行分配，像malloc calloc等。 参考源 Linux System Programming,Second Edition,by Robert Love(O'Reilly).Copyright 2013 Robert Love,978-1-449-33953-1","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"}]},{"title":"讲一颗金子的故事","slug":"生活-讲故事-2017-09-05-讲一颗金子的故事","date":"2017-09-05T09:11:39.000Z","updated":"2017-09-05T09:11:39.000Z","comments":true,"path":"2017/09/05/生活-讲故事-2017-09-05-讲一颗金子的故事/","link":"","permalink":"http://greedyhao.cc/2017/09/05/生活-讲故事-2017-09-05-讲一颗金子的故事/","excerpt":"","text":"从前，在一片空地上，有粒金子躺在一堆沙石中，人们来来往往却从没有人注意到他。直到有一天幸运女神降临，人们把粮食放在这片空地晾晒，在将晒好的粮食收回粮仓的时候，顺带着把这粒金子一起带回了粮仓。日子一天天过去，粮食一天天减少，但是没有人发现这粒金子，金子仍然躺在沙石中，只不过之前是在空地，现在是在粮仓中。 前断时间我们实验室几个人参加了 互联网+创新创业大赛 ，但是很可惜，没有人欣赏。这是参赛项目总排名 我们指纹考勤的排名 我们的指纹考勤使用了科技分量十足的人脸识别技术外加指纹识别技术，另外使用onenet平台获取考勤信息，非常符合未来发展需求。但是评委们都是什么态度，60 60 60 65 60，这分数随随便便给的吧，看都没看吧，一盆多肉的排名居然都比我们高？我们这种科技成分十足的产品居然排名最后，还被怜悯了60分？ 酒香也怕巷子深，再好的作品不被人发现也只会是废品。 但是金子是骄傲的，就算是在沙石中，金子也还是金子。","categories":[{"name":"讲故事","slug":"讲故事","permalink":"http://greedyhao.cc/categories/讲故事/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://greedyhao.cc/tags/生活/"}]},{"title":"记第一次失败的画板","slug":"工作-altium-2017-09-05-记第一次失败的画板","date":"2017-09-05T05:30:40.000Z","updated":"2017-09-05T08:33:24.000Z","comments":true,"path":"2017/09/05/工作-altium-2017-09-05-记第一次失败的画板/","link":"","permalink":"http://greedyhao.cc/2017/09/05/工作-altium-2017-09-05-记第一次失败的画板/","excerpt":"最近突然就想自己做一个小机器人来玩，但是不会画板，正好前天要从家回学校，要坐一晚上的大巴，就在车上通宵看完了Altium的简单的教学视频。为了更好的学习画PCB，就把视频教程中的实例自己去画了出来。","text":"最近突然就想自己做一个小机器人来玩，但是不会画板，正好前天要从家回学校，要坐一晚上的大巴，就在车上通宵看完了Altium的简单的教学视频。为了更好的学习画PCB，就把视频教程中的实例自己去画了出来。 画板流程 画元件原理图库 元件封装库 画原理图 PCB layout 我画的PCB预览图 MSP430 有点失败，地线在覆铜后没有通。 开始--准备Lib 要画板，首先需要准备好元件的原理图库和封装库。 像我们这种初学者，绘制原理图库时不需要计较太多，一般元件左边输入，右边输出，管脚太多的情况下，上面放vcc，下面放gnd。一般来说，元件原理图库绘制要方便自己之后的板子的原理图的绘制，管脚太多的元件就拆分成几个组件。 而元件的封装库就必须要按照实际情况来绘制，可以查找元件的datasheet，按照官方给的参数画，如果封装库绘制的不正确会导致元件焊接不上的尴尬，然后板就白打了。 经过这次画板，我养成了一个习惯，就是先给项目添加一个，把这块板上所有元件的原理图库都添加到一个库中，封装库也是一样，然后 画原理图 一般来说，我们都会先创建一个.PrjPcb项目，然后添加新的PcbDoc SchDoc PcbLib SCHLIB（这是我这次画板学到的），这样项目列表就会如下所示。 然后在绘制板的原理图时，首先会从库里选择元件，这时就要注意一下元件的封装了，不然等到把原理图导入pcb时才发现封装不对，又要重新改封装。 如果发现封装不对或者元件原理图库中没有对应的封装，就更改元件封装。 PCB layout 首先是从原理图中导入 然后验证变更 执行变更 删除红色的room 画禁止布线层 重新选择板子形状 选择板子原点，这是为了给pcb中其他元件的位置做参考点 然后将元件拖入黑色区域，开始手工布线 布线完成后，加滴泪，直接点确定就好 最后铺铜，一定要选择铺的网络端口，因为我把GND空了出来没有连接，所以我铺的是GND。鼠标变成十字光标后，顺着板子四周走一圈，就铺完一个面了。如果发现板子有问题就点击铺铜区域，delete一下就删除了 收到的教训 元件布局很重要，好的元件布局可以让自己在走线的时候更加轻松 注意飞线 ，我是画到最后才发现的，如果飞线有交叉，走线是很麻烦的，要避免飞线交叉 铺铜不是一定能保证网络连接的，我最先以为只要一铺铜，我选择的网络端口就全部连接上了，事实证明是我太年轻，走线太乱导致我铺铜后地线不通，顿时才明白了为什么说 尽量在top层走线的原因了","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Altium","slug":"Altium","permalink":"http://greedyhao.cc/tags/Altium/"}]},{"title":"解决多线程引发的问题","slug":"工作-Linux-2017-08-28-解决多线程引发的问题","date":"2017-08-28T14:55:17.000Z","updated":"2017-08-28T14:55:17.000Z","comments":true,"path":"2017/08/28/工作-Linux-2017-08-28-解决多线程引发的问题/","link":"","permalink":"http://greedyhao.cc/2017/08/28/工作-Linux-2017-08-28-解决多线程引发的问题/","excerpt":"本文将介绍并发和并行有什么区别，再说明如何产生数据的竞争问题，再介绍如何解决竞争问题。","text":"本文将介绍并发和并行有什么区别，再说明如何产生数据的竞争问题，再介绍如何解决竞争问题。 什么是并发和并行 并发和并行 从我画的这幅图就可以看出并发和并行的区别。 并发 是指在一个时间片内对多个任务间切换，以达到多任务的目的。并行 是指多个处理器同时运行多个任务。 简单的说就是，并发是在软件层面运行多任务，甚至单处理器都可以；而并行就需要硬件支持，需要是多处理器。 竞争的问题 由于多线程共享同一个虚拟内存空间，且多线程的顺序是不可知的，所以在多线程对数据进行操作时，就存在着很多不确定性。 拿书本中x++的例子吧，我觉得挺经典的。 假设有两个线程并发执行x++，其中x=5。以下是我们的期待输出。 时间 线程1 线程2 1 把x加载到寄存器（5） 2 寄存器值加1（6） 3 把寄存器值赋给x（6） 4 把x加载到寄存器（6） 5 寄存器值加1（7） 6 把寄存器值赋给x（7） 但是我们前面说了，线程的执行顺序是不确定的，实际情况很可能是这样。 时间 线程1 线程2 1 把x加载到寄存器（5） 2 把x加载到寄存器（5） 3 寄存器值加1（6） 4 寄存器值加1（6） 5 把寄存器值赋给x（6） 6 把寄存器值赋给x（6） 也就是说，很有可能在多线程的情况下，x++虽然被执行了多次，但结果可能只是加了1。 解决数据竞争的问题 同步 同步是解决数据竞争的一个不错的方法。 互斥 因为多线程是共享同一个内存空间的，所以无法使用普通的数据类型来判断一份数据是否已经被&quot;操作过了&quot;；但是我们可以使用&quot;锁&quot;，把数据锁住，让程序在处理数据时只允许单个线程更改数据。这就叫 互斥。 再把书中的一个例子搬出来，是对ATM机存取款加锁。 1234567891011int withdraw (struct account *account, int amount)&#123; lock (); const int balance = account-&gt;balance; if (balance &lt; amount) &#123; unlock (); return -1; &#125; account-&gt;balance = balance - amount; unlock ();&#125; 如果使用Pthread库的API，还可以对单个账户加锁，在下次介绍Pthread的时候再说。 参考源 Linux System Programming,Second Edition,by Robert Love(O'Reilly).Copyright 2013 Robert Love,978-1-449-33953-1","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"}]},{"title":"多进程和多线程的区别","slug":"工作-Linux-2017-08-26-多进程和多线程的区别","date":"2017-08-26T14:12:52.000Z","updated":"2017-08-26T15:18:14.000Z","comments":true,"path":"2017/08/26/工作-Linux-2017-08-26-多进程和多线程的区别/","link":"","permalink":"http://greedyhao.cc/2017/08/26/工作-Linux-2017-08-26-多进程和多线程的区别/","excerpt":"对于线程进程，相必大家都很熟悉，但是很多人对线程和进程具体有什么不同还是不清楚，不知道为什么很多时候要用多线程而不是多进程。","text":"对于线程进程，相必大家都很熟悉，但是很多人对线程和进程具体有什么不同还是不清楚，不知道为什么很多时候要用多线程而不是多进程。 对于进程的描述，我在进程创建和运行有过一些简单的描述，一点都不知道的可以参考一下。 多进程与多线程获得资源不同 内核提供给进程的虚拟内存与虚拟处理器，在多进程的情况下，可以让每一个进程都认为自己完全的占有整台电脑的资源。而在多线程的情况下，同易进程的多个线程之间共享同样的内存资源，但是独自占有处理器资源。 为什么使用多线程而不是多进程 其实线程能做的事情进程也可以做，多进程的低延迟和高I/O吞吐也可以通过I/O多路复用，非阻塞I/O和异步I/O来实现。这些技术可以使进程并发，不会阻塞进程。 但是 进程的上下文切换由于涉及把一个虚拟地址切换到另一个虚拟地址，所以代价比较大；而进程内的线程间切换由于共享同一个内存，代价几乎为0。在极端情况下，在某些ARM机器上，必须把整个CPU的缓存都清空。 多线程真正的优点 为什么现在的应用越来越倾向与使用多线程，真正的原因就是多线程能够 真正的并发运行 ，有多少处理器数就可以并行多少线程。在十多年前人们可能不在意多线程，因为当时的处理器数基本都只有一个，不像现在的处理器基本都是多核，手机的处理器甚至还有十核的，因此手机的应用基本都是多线程的，这样可以更好的利用资源。 多线程的缺点 多线程用起来是很爽，但是存在一个很大的问题：多线程的进程有多个事件在同时运行，而这些事件共享同一份内存，可能会同时读写同一个文件，一个不小心就会输出脏数据。 而且对多线程的程序的调试也是一个很让人头疼的问题（听说的，本人不清楚） 参考源 Linux System Programming,Second Edition,by Robert Love(O'Reilly).Copyright 2013 Robert Love,978-1-449-33953-1","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"}]},{"title":"实际用户和有效用户的区别","slug":"工作-Linux-2017-08-26-实际用户和有效用户的区别","date":"2017-08-26T03:48:14.000Z","updated":"2017-08-26T03:49:05.000Z","comments":true,"path":"2017/08/26/工作-Linux-2017-08-26-实际用户和有效用户的区别/","link":"","permalink":"http://greedyhao.cc/2017/08/26/工作-Linux-2017-08-26-实际用户和有效用户的区别/","excerpt":"这段时间在看《Linux系统编程》，看到好几个对用户ID设置的接口，然后就对实际用户和有效用户 感觉到疑惑，在查询弄明白后，将在下面介绍。","text":"这段时间在看《Linux系统编程》，看到好几个对用户ID设置的接口，然后就对实际用户和有效用户 感觉到疑惑，在查询弄明白后，将在下面介绍。 从理论上介绍一下两者区别 实际用户 实际用户ID是指运行这个进程的用户uid。这个用户uid会被设置为父进程的实际用户ID，并且在exec 系统调用中都不会发生改变。一般情况下，登录进程会将用户登录那个shell的实际用户ID设置为 登录用户的uid，并且这个用户所有进程的实际用户ID都会继承这个值。 超级用户可能会把实际用户 ID设置修改为任意值，但是其他用户不可以。 有效用户 有效用户ID是当前进程所使用的用户ID。 权限认证一般是使用这个值。 初始时，这个ID等于 实际用户ID。 改变uid/gid 12345#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int setuid (uid_t uid);int setgid (guid_t guid); 调用setuid()会设置当前进程的有效用户ID。root用户可以为uid提供任何值；非root用户只允许 将实际用户ID和保留用户ID设置为uid。 获得uid/gid 12345#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;uid_t getuid (void);gid_t getgid (void); 使用getuid和getgid可以分别获得当前进程的uid和gid。 通过实例来展现uid/euid区别 12345678910#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; printf(\"uid=%d\\n\", getuid()); printf(\"gid=%d\\n\", getgid()); return 0;&#125; 编译运行的结果： 123456hao@hao1:~/linux/5.6$ ./uiduid=1000gid=1000hao@hao1:~/linux/5.6$ sudo ./uiduid=0gid=0 第一次运行的时候，使用的是普通用户，uid=1000，gid=1000，由于没有使用setgid对gid进行改变， 所以uid = gid。第二次运行的时候，使用的是超级权限(root)，所以uid=0，gid=0。 特别说明 有效用户ID(euid)代表它的属主，限制进程的权限。 在没有seteuid的情况下，uid = euid，guid同理。 当进程以root权限调用setuid()后，root权限会被丢弃，所以root权限下，使用setuid()更加安全。 参考源 Linux System Programming,Second Edition,by Robert Love(O'Reilly).Copyright 2013 Robert Love,978-1-449-33953-1","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"}]},{"title":"python对方法的迭代","slug":"工作-python-pythonic-2017-08-23-python对方法的迭代","date":"2017-08-23T08:05:11.000Z","updated":"2017-08-23T08:05:11.000Z","comments":true,"path":"2017/08/23/工作-python-pythonic-2017-08-23-python对方法的迭代/","link":"","permalink":"http://greedyhao.cc/2017/08/23/工作-python-pythonic-2017-08-23-python对方法的迭代/","excerpt":"","text":"any() Return True if any element of the iterable is true. If the iterable is empty, return False. Equivalent to: (返回True，如果iterable中的任何一个element是True。如果iterable是空的，返回False。等价与：) 12345def any(iterable): for element in iterable: if element: return True return False 对一个可迭代的对象，要想知道其中某一个元素是否符合某一个表达式，用 any()，最好不过了。 for 今天才知道，原来for循环还可以对方法进行循环，尽管之前就知道list中什么都可以放，可是放方法 的还是头会见到，学习的路果然是任重而道远。 实际运用 问题： You are given a string S. Your task is to find out if the string S contains: alphanumeric characters, alphabetical characters, digits, lowercase and uppercase characters. 给你一个string S。 你的任务是判断string S是否包含： 数字字母都有 按字母表顺序(Unicode) 有数字 有小写字母 有大写字母 12for method in [str.isalnum, str.isalpha, str.isdigit, str.islower, str.isupper]: print any(method(c) for c in s) 参考源 hackerrank讨论区 any的官方doc","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"python","slug":"python","permalink":"http://greedyhao.cc/tags/python/"},{"name":"pythonic","slug":"pythonic","permalink":"http://greedyhao.cc/tags/pythonic/"}]},{"title":"强权和冲动无法教育孩子","slug":"生活-讲故事-2017-08-23-强权和冲动无法教育孩子","date":"2017-08-23T04:26:30.000Z","updated":"2017-08-23T04:28:48.000Z","comments":true,"path":"2017/08/23/生活-讲故事-2017-08-23-强权和冲动无法教育孩子/","link":"","permalink":"http://greedyhao.cc/2017/08/23/生活-讲故事-2017-08-23-强权和冲动无法教育孩子/","excerpt":"讲真，当我看见我的表弟经常被我的舅舅舅娘打骂，有时是因为他捣乱，有时候是因为贪玩，还有时 是因为在他父母心情不好的时候他做错了什么；真的心中愤懑，不认可他父母的做法，也不认为他 父母这么做能解决问题。","text":"讲真，当我看见我的表弟经常被我的舅舅舅娘打骂，有时是因为他捣乱，有时候是因为贪玩，还有时 是因为在他父母心情不好的时候他做错了什么；真的心中愤懑，不认可他父母的做法，也不认为他 父母这么做能解决问题。 虽然都说他父母这是为了我表弟好，但是，很多时候应该换个角度看待问题，如果被打的是你，被 骂的是你你还会这么说吗？ 表弟他的顽皮，他的捣乱，其实就是他的个性，个性不是用来抹杀的，你虽然可以强制让他坐在房间 里看书写作业，但是你限制不了他的内心的狂野。 在我小的时候，我爸妈也是限制我的周末时间，只能周日出去玩，周六必须在家写作业，作业没写 完就不给出去玩。其实这并没有什么卵用，知道我在房间里干嘛吗，真的是嫌得无聊，玩玩自己的 小玩具，趴在窗户上看别人吵架，或者直接躺床上，总之就是不想写作业。一直等到最后期限到了， 才不情不愿的开始动笔，因为自己知道，就算是早写完了作业一样是不能提前出门，因为周六要留 在家里面。 我有过这段经历我就知道，强扭的瓜真的不甜，任何人将任何他人不喜事物强加在另一个人身上，招 来的都是反抗。我觉得之所以我们这代人的长辈不理解我们，可能就是他们没有经历过，这真的是 很可惜，如果经历过九年制义务教育再上个高中，估计他们就懂了。 我觉得，要解决这个问题，首先应该要把孩子真正当成一个人来对待，要尊重，要有爱。你可以给 孩子立下君子协议，定下一个目标，只要孩子达到了这个目标，那么孩子不管做什么事，父母都不会 进行约束，也不会干预孩子达到目标的过程，一切靠他自己发挥；没有达到约定的目标那就接受惩罚。 （当然目标不能不太实际） 如果父母始终认为，在家中自己的地位是最高的，自己的孩子就应该无条件听自己的，那你的孩子 一般都是会反抗，如果不反抗那么问题就更严重了，要么是在隐忍，要么就是根本不会反抗，这两种 情况的后果都非常严重。 ps:不想写了，发现文章的连接性太差了，就是垃圾，思绪被打乱了，下次写前要先画个流程图记录下写作思路。","categories":[{"name":"生活","slug":"生活","permalink":"http://greedyhao.cc/categories/生活/"}],"tags":[{"name":"讲故事","slug":"讲故事","permalink":"http://greedyhao.cc/tags/讲故事/"}]},{"title":"进程创建和运行","slug":"工作-Linux-2017-08-21-进程创建和运行","date":"2017-08-21T03:13:56.000Z","updated":"2017-08-21T03:13:56.000Z","comments":true,"path":"2017/08/21/工作-Linux-2017-08-21-进程创建和运行/","link":"","permalink":"http://greedyhao.cc/2017/08/21/工作-Linux-2017-08-21-进程创建和运行/","excerpt":"简单的说，每个应用在运行时就会产生一个进程，这个进程就对这个应用负责，掌握这个应用的运行状态。 可是为什么还要用一个进程来控制一个应用呢，下面将会简单的解释一下。","text":"简单的说，每个应用在运行时就会产生一个进程，这个进程就对这个应用负责，掌握这个应用的运行状态。 可是为什么还要用一个进程来控制一个应用呢，下面将会简单的解释一下。 现在的应用对于资源的要求都是狮子大开口，开口就是几个G，一台电脑的内存一般也就几个G，总不能 一台电脑就跑这一个应用吧。为了解决这个问题，操作系统就使用了虚拟内存，让每个进程代表一个 应用，给每个进程一种自己独霸整台电脑的假象，然后操作系统进行上下文切换，只把这个进程正好 需要使用的资源放进内存；这样每个进程都有自己独有的资源。 创建进程 创建进程需要一个系统调用 fork()，fork可以创建一个和当前进程映像一样的进程；成功时 创建子进程并返回子进程的pid，失败时不会创建子进程，返回-1并设置相应的errno。 顺便介绍一下pid，pid是进程的ID，数据类型是pid_t，在Linux中被定义为int。可以调用 getpid() 来获得调用进程的pid，还可以通过调用 getppid() 来获得调用进程的父进程的pid。 运行进程 运行进程需要调用 exec 系统调用，但是不存在单一的exec函数，他是由一系列的exec函数组成的。 以一个最简单的调用 execl() 为例： + 成功的execl()调用改变 地址空间 和进程映像 + 所有的挂起的信号都会丢失 + 捕捉到的所有信号都会还原为默认处理方式 + 丢弃所有的内存锁 + 大多数进程的属性会还原成默认值（pid 父进程的pid 优先级 所属的用户和组 不会变） + 清空和进程内存地址空间相关的所有数据，包括所有映射的文件 终止进程 终止进程使用的是 exit() 系统调用，参数用于表示进程的推出状态， EXIT_SUCCESS 和 EXIT_FAILURE 这两个可移植的宏分别表示成功和失败（也可以使用0和非0值来表示，不过 可移植性就差了）。 简单的表示成功退出就使用 1exit(EXIT_SUCCESS); 这个系统调用会先完成在用户空间需要做的事，再调用_exit()再处理内核中的事。 在用户空间做的事 + 调用任何由 atexit() 或 on_exit() 注册的函数，按在系统中注册的相反顺序。（ 假如在exit()前运行了atexit(a) atexit(b)，那么在调用exit()后就会先运行b再运行a ） + 清空所有已打开的标准I/O流 + 删除有tmpfile()函数创建的所有临时文件 内核会清理进程所创建的 不再使用的所有资源这包括但不局限于：分配内存 打开文件和System Ⅴ 的信号量。清理完成后，内核会摧毁进程，并告知父进程其子进程已经终止。 参考源 Linux System Programming,Second Edition,by Robert Love(O'Reilly).Copyright 2013 Robert Love,978-1-449-33953-1","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"}]},{"title":"配置HC-05","slug":"工作-bluetooth-2017-08-19-配置HC-05","date":"2017-08-19T15:39:58.000Z","updated":"2017-08-21T03:21:06.000Z","comments":true,"path":"2017/08/19/工作-bluetooth-2017-08-19-配置HC-05/","link":"","permalink":"http://greedyhao.cc/2017/08/19/工作-bluetooth-2017-08-19-配置HC-05/","excerpt":"在网上搜索了很久关于HC-05的配置，但是自己的配置还是有问题，HC-05仍然无法进入AT模式，现总结如下。","text":"在网上搜索了很久关于HC-05的配置，但是自己的配置还是有问题，HC-05仍然无法进入AT模式，现总结如下。 第一个问题--如何进入AT模式 首先是HC-05的key或en管脚要上拉一个高电平，仔细看下，在HC-05上有一个小按键，按着按键再上电（这很重要，我先前也是不知道这点所以不能进入AT模式） 第二个问题--如何发送指令 调整波特率为38400，其他配置如图。 注意图中我光标的位置。 image.png 也就是说，发送指令的格式是：回车+空格 指令的格式很重要，不然是没有回应的","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"bluetooth","slug":"bluetooth","permalink":"http://greedyhao.cc/tags/bluetooth/"}]},{"title":"Linux_I/O_Scheduler","slug":"工作-Linux-2017-08-19-Linux-IO-Scheduler","date":"2017-08-19T02:26:51.000Z","updated":"2017-08-19T02:47:31.000Z","comments":true,"path":"2017/08/19/工作-Linux-2017-08-19-Linux-IO-Scheduler/","link":"","permalink":"http://greedyhao.cc/2017/08/19/工作-Linux-2017-08-19-Linux-IO-Scheduler/","excerpt":"修改Linux的I/O调度器可以通过修改/sys/block/device/queue/scheduler来完成，有效选项 可以是as cfq deadline 和 noop，下面将介绍这几种调度器。","text":"修改Linux的I/O调度器可以通过修改/sys/block/device/queue/scheduler来完成，有效选项 可以是as cfq deadline 和 noop，下面将介绍这几种调度器。 这个I/O调度器有什么用 先告诉大家一个数据，单次硬盘寻址平均需要8毫秒以上，但却是CPU周期的2500万倍。 为了解决硬盘与其他设备之间的巨大差异，便通过I/O调度器的基本功能 合并 和 排序， 来尽量减少磁盘寻址次数和移动距离（因为这是I/O中耗时最久的）。 改进读请求 每次读请求必须返回最新的数据因此，当请求的数据不在页缓存中时，读请求在数据从硬盘读出前会 一直阻塞--这可能是一个相当漫长的操作。我们将这种性能损失称为读延时 读请求之间存在依赖，打开这个文件可能需要先打开另外一个文件，这么样的话，我们可能需要硬盘再转一圈去寻址， 这样的话，读延时就太严重了。 因此最先想到的解决方法就是对这些寻址进行排序，让磁头的移动距离最小。 但是这样又出现了另一个问题，还是依赖的问题。在将寻址排序后，假如新的请求都是50 ~ 60之间的， 但是存在一个依赖需要访问第109块，这样的话，读延时会很严重，会极大影响系统性能。 Deadline 读写请求分离，读请求具有高优先调度权，除非写请求即将被饿死的时候，才会去调度处理写请求。这种处理可以保证读请求的延迟时间最小化。 对请求的顺序批量处理。对那些地址临近的顺序化请求，deadline给予了高优先级处理权。例如一个写请求得到调度后，其临近的request会在紧接着的调度过程中被处理掉。这种顺序批量处理的方法可以最大程度的减少磁盘抖动。 保证每个请求的延迟时间。每个请求都赋予了一个最大延迟时间，如果达到延迟时间的上限，那么这个请求就会被提前处理掉，此时，会破坏磁盘访问的顺序化特征，回影响性能，但是，保证了每个请求的最大延迟时间。 Anticipatory 还是寻址时间的问题。假设应用突然提交一个读请求，而且该请求即将到截止时间，I/O调度器响应该请求， 在硬盘中查找请求的数据，然后返回，再处理队列中其他请求。 这么做，会有很多次的硬盘寻址次数，而硬盘寻址又是非常耗时的，为了减少硬盘寻址次数，可以让 调度器在处理完一个读请求后稍微等待一下，如果还有读请求就一起处理；相比于硬盘寻址的时间， 调度器等待的时间是非常值得的。 这个anticipatory调度器的工作原理也叫做 预测，每处理完一个读请求后会等待6毫秒， 因为大部分读是相互依赖的，预测可以节省大量时间。 CFQ Complete Fair Queuing I/O 调度器和前两种调度器目的是一致的。使用CFQ时，每个进程都有自己 的队列，每个队列分配一个时间片，同时还是存在着预测；在没有请求处理时会空转一段时间（默认10毫秒）；在进程队列中同步请求（如读操作）被赋予比非同步请求更高的优先级。 Noop Noop I/O调度器是最简单的调度器，它不排序，只简单的合并，一般使用在不需要对请求排序的 特殊设备上，也更快。 固态驱动器比机械硬盘快的原因 前文提到的不需要对请求排序的就是这种固态驱动器(SSDs)它使用类似随机访问内存的方式来索引， 没有硬盘的&quot;旋转&quot;代价。 参考源 Linux System Programming,Second Edition,by Robert Love(O'Reilly).Copyright 2013 Robert Love,978-1-449-33953-1 linux内核之块设备四---deadline调度算法","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"}]},{"title":"为什么你不喜欢编程","slug":"生活-安利-2017-08-16-为什么你不喜欢编程","date":"2017-08-16T06:07:51.000Z","updated":"2017-08-17T07:53:25.000Z","comments":true,"path":"2017/08/16/生活-安利-2017-08-16-为什么你不喜欢编程/","link":"","permalink":"http://greedyhao.cc/2017/08/16/生活-安利-2017-08-16-为什么你不喜欢编程/","excerpt":"我曾听说有人是觉得编程难，所以放弃编程；还有很多是根本没有碰过编程，觉得编程太高大上， 觉得自己肯定学不会就根本不学。其实..这些想法都是错误的！编程就像玩具一样，有难有易， 有好玩有无聊，你喜欢编程只不过是你没有找到属于你的那一个。","text":"我曾听说有人是觉得编程难，所以放弃编程；还有很多是根本没有碰过编程，觉得编程太高大上， 觉得自己肯定学不会就根本不学。其实..这些想法都是错误的！编程就像玩具一样，有难有易， 有好玩有无聊，你喜欢编程只不过是你没有找到属于你的那一个。 先讲讲我的内心活动 虽然表面上是打着劝学的高逼格旗号，其实我内心是就差没有跪下来求大家多点人来学编程了。 因为，总有人不理解编程，以为谁学编程就多么多么叼，可以千里之外入侵别人电脑。哇，这真的 是...真的是心塞，不是什么人都可以办到的啊，而且编程这个领域是非常大的，大到我觉得我这 一生都可以耗在里面了。跟何况我根本不是学怎么入侵别人电脑的啊... 先给你们画个饼 既然是求你们，那么我肯定要拿得出求你们的资格了，先让你们看看我的战车。 战车 战车 这是我大一的时候做的，后来要学其他的东西没有时间，就被我搁置一旁了，而且一些部件丢失， 就剩下了这个残破的模样。但是还是不能小瞧他，至少...至少他还可以再拯救一下的，更何况， 他还是能动的。本来之前是通过蓝牙控制的，现在蓝牙模块都没了，只能给微控制器写点程序， 让他可以乱走一下，这就是编程。 再让你们看个东西，这个是最近弄的，指纹人脸识别门禁，听名字就觉得高大上有木有。 指纹人脸门禁 门内景象 指纹部分 摄像头在门外 虽然看起来很丑，但是这只是原型，后期会把那些乱七八糟的线全部藏起来，而且整个设备都会 变小，到那时是不是很酷。 弱弱的说句，其实我只是做了其中很小的一部分，就一个屏幕显示的程序而已， 很尴尬，因为是好几个人一起做的，所以僧多粥少，也只能这样。 上面那些都是嵌入式方面的编程，再说说全软件的编程。 网页设计 这是我的博客首页，我觉得挺好看的 博客首页 这些都是纯软件写出来的东西（好吧，虽然又不是我做的），这种编程叫做网页设计，涉及前端后端， 使用html css javascript（这种安利本来不该出现这些专业的词语，但是我也是真的不太懂，没办法） 机器学习 好吧，这个更不是我所擅长的，不过介绍和擅长有什么关系呢，只要听起来牛逼就行了。 自动驾驶 这个词相信大家都非常耳熟，这就是机器学习的一种应用； 还有什么 手机的智能预测 这也是一种应用；还有什么函数拟合啊等等就不说了。 网络安全 不是有人想去入侵别人电脑的吗，先不讨论这件事的好坏，就当是你的一种兴趣。如果你想，就去 学习网络安全的知识吧。学点网络安全没坏处，最起码以后出门在外，虽然不能做到入侵电脑， 但是破解一个路由器的密码还是小意思的。 所以说 ====== 所以说，编程嘛，万花从中自有属于你的那一朵，首先就是要找到自己喜欢的，采摘了，再去找下一朵喜欢 的，等到你的花篮放满花了的时候，你就成了别人眼里的大师了，是不是很有想法啊，有想法了就去做 啊","categories":[{"name":"生活","slug":"生活","permalink":"http://greedyhao.cc/categories/生活/"}],"tags":[{"name":"安利","slug":"安利","permalink":"http://greedyhao.cc/tags/安利/"}]},{"title":"文件描述符","slug":"工作-Linux-2017-08-16-文件描述符","date":"2017-08-16T01:59:02.000Z","updated":"2017-08-16T01:59:02.000Z","comments":true,"path":"2017/08/16/工作-Linux-2017-08-16-文件描述符/","link":"","permalink":"http://greedyhao.cc/2017/08/16/工作-Linux-2017-08-16-文件描述符/","excerpt":"刚开始学习Linux编程的朋友可能会不知道什么是文件描述符，我现在就简单的介绍一下。","text":"刚开始学习Linux编程的朋友可能会不知道什么是文件描述符，我现在就简单的介绍一下。 1234567/usr/include/unistd.h...#define STDIN_FILENO 0 /* Standard input. */#define STDOUT_FILENO 1 /* Standard output. */#define STDERR_FILENO 2 /* Standard error output. */... 虽然STDIN_FILENO和stdin效果很像，但是是两个不一样的东西，文件描述符的类型的 int ，而stdin 是 FILE* 类型，具体差别可以参考STDIN_FILENO的作用及与stdin 的区别 常见的对文件描述符的操作： read(), write()，open(),lseek(),select(),poll() 参考源 STDIN_FILENO的作用及与stdin 的区别 文件描述符--维基百科，自由的百科全书","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"}]},{"title":"linux内核缓存介绍","slug":"工作-Linux-2017-08-15-linux内核缓存介绍","date":"2017-08-15T12:48:19.000Z","updated":"2017-08-21T03:13:37.000Z","comments":true,"path":"2017/08/15/工作-Linux-2017-08-15-linux内核缓存介绍/","link":"","permalink":"http://greedyhao.cc/2017/08/15/工作-Linux-2017-08-15-linux内核缓存介绍/","excerpt":"正所谓没吃过猪肉也看过猪跑，会看这篇文章的想必都是听说过 内核 这个词的吧，今天就让 我来请大家吃一回&quot;猪肉&quot;，了解一下内核如何实现I/O。","text":"正所谓没吃过猪肉也看过猪跑，会看这篇文章的想必都是听说过 内核 这个词的吧，今天就让 我来请大家吃一回&quot;猪肉&quot;，了解一下内核如何实现I/O。 实现内核I/o要靠三个主要的子系统: 虚拟文件系统 页缓存 页回写 虚拟文件系统 先说说虚拟文件系统，也称作VFS，Linux中有句名言叫做， 一切皆文件 ，能达到这样的效果， 这个VFS功不可没。他可以让内核在 不了解也不要了解文件系统类型的情况下 调用调用文件系统 函数并操作文件系统数据。 由此，系统调用可以读任意类型文件，工具可以直接从一个文件系统拷贝到令一个上。 页缓存 缓存的存在是为了在CPU的高速和硬盘的低速之间起一个过渡作用，内核查找文件系统数据会先在缓存中 查找，找不到才会访问硬盘。 在这里要介绍两个重要的原理 时间局部性 和 空间局部性。 时间局部性 时间局部性原理认为，刚刚访问过的区域再被访问的可能性很大，所以在第一次访问时会对数据缓存， 虽然消耗内存，但是可以避免开销巨大的硬盘I/O。 空间局部性 空间局部性原理认为，访问数据往往是连续的，而且访问连续空间比随机访问更快，所以每次读操作 都会额外的读取几个比特，也叫做预读。 页缓存动态变化 内存终究是有限的，不可能无限的缓存，所以也缓存需要动态变化。 在页缓存被消耗完了之后，就会 裁剪 不常用的部分，然后 交换 给硬盘，腾出来的空间 留给常用的部分。Linux内核的启发式算法会处理这些问题。 页回写 数据从硬盘读出来，放在缓存中，自然还需要再写会硬盘，因为RAM中的东西会在断电之后丢失。 像这些缓存中的数据被读写操作过后，和硬盘中的数据不一样了，就被叫做 脏数据 ，脏数据需要 回写硬盘让他变干净，所以就有了页回写。 回写是通过 flusher 的内核线程来执行的，当空闲内存低于设定的阈值或者脏缓冲区存在时间 超出设定时，就会触发回写。 这里还是有个问题，就是万一还没有回写系统就断电了。那很可悲，这些数据就丢失了，所以关键应用 可以使用同步I/O来保证数据不会丢失。 参考源 Linux System Programming,Second Edition,by Robert Love(O'Reilly).Copyright 2013 Robert Love,978-1-449-33953-1","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"}]},{"title":"利用hexo搭建博客","slug":"工作-hexo-2017-08-14-利用hexo搭建博客","date":"2017-08-14T11:21:57.000Z","updated":"2017-08-14T13:33:00.000Z","comments":true,"path":"2017/08/14/工作-hexo-2017-08-14-利用hexo搭建博客/","link":"","permalink":"http://greedyhao.cc/2017/08/14/工作-hexo-2017-08-14-利用hexo搭建博客/","excerpt":"发现jekyll不怎么好用，特别是换主题一点也不方便（可能是我不太会），最主要的是hexo 有插件很多方便的插件，为了今后更好的写博客，就提前跳入hexo的坑了。","text":"发现jekyll不怎么好用，特别是换主题一点也不方便（可能是我不太会），最主要的是hexo 有插件很多方便的插件，为了今后更好的写博客，就提前跳入hexo的坑了。 之前使用jekyll搭建博客的时候，因为有一个插件安装不上，所以我没有用命令行生成博客，现在 转到hexo，正好可以补全我这段经历。 你首先需要做的事情 很简单把官方文档看一遍，官方文档写的很简洁， 很有用。 介绍一点简写的命令 123456npm n #newnpm p #publishnpm g #generatenpm d #deploynpm c #cleannpm s #serve 一般写博客的步骤 首先需要布置好你的博客，很简单的，就几个命令而已，自行参考建站。 然后呢再是两个命令 12npm n Hellonpm g -d 一篇博客就成功发布了。 好了，到了泼凉水的时候了 你以为真的就这么简单？执行发布的那两个命令你肯定会出错的，我就是有点坑，hhh 在使用这两个命令前，需要做一件事，安装git的一个插件 1npm install hexo-deployer-git --save 修改根目录下的_config.yml 123deploy:- type: git repo: https://username.com/username/username.github.io.git #不要用git的形式，除非你懂git 第一次会叫你输入用户名和密码 写博客一些常用的工具 参考我上一篇写jekyll的利用github page搭建博客完整版教程上面介绍了很多写博客的工具。 这里我再介绍一个网站unsplash，有很多优美的图片，可以用来当博文的封图。 参考源 hexo 配图不愁，超优质图片素材网站推荐！","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://greedyhao.cc/tags/hexo/"}]},{"title":"解决博客无法被搜索到","slug":"工作-hexo-2017-08-14-解决博客无法被搜索到","date":"2017-08-14T09:08:49.000Z","updated":"2017-08-14T13:25:56.000Z","comments":true,"path":"2017/08/14/工作-hexo-2017-08-14-解决博客无法被搜索到/","link":"","permalink":"http://greedyhao.cc/2017/08/14/工作-hexo-2017-08-14-解决博客无法被搜索到/","excerpt":"0x00 前几天刚在jekyll上搭建了自己的博客，还顺便写里一个教程，然后就发现了一个问题，不能被 百度或者谷歌搜到！！！","text":"0x00 前几天刚在jekyll上搭建了自己的博客，还顺便写里一个教程，然后就发现了一个问题，不能被 百度或者谷歌搜到！！！ 这我就不高兴了，虽然很快就在网上看到了如何让谷歌和百度搜索到自己在GitHub上的博客， 但是我实际操作的时候才发现自己悲剧了，自己的博客是基于jekyll搭建的，这篇教程是基于hexo 的，我发疯的在网上找jekyll的教程，可悲的发现没有.... 0x01 没办法，只能把迁移到hexo了，[迁移过程看这里][#] 需要做的准备 去百度搜索提交和谷歌搜索提交 创建账号 开始 检查是否有被收录 在百度和谷歌的搜索栏输入一下信息 1site:greedyhao.cc //网址换成你自己博客的网址 如果出现我这种情况，那么就是悲催的没收录。 2. 没有收录就去提交收录咯 百度搜索提交和谷歌搜索提交按官方步骤操作。 也就是 提交网站 选择网站类型 验证网站 三大步骤。 前面两个没什么说的，就是第三个步骤可能有点问题。有人可能无法用 验证文件 的，那就用 HTML 验证吧。 最重要的是 如果你是www的网站，可能就麻烦了，可能前两种方法无法验证，你 只能选择去掉www再来一次，或者用 CNAME 验证。 像我的话，怎么验证了都没办法让百度收录也是醉，只能选择把博客搬到国内了，国内的话好像 Coding还不错，不过不花点钱的话，点开博客有广告.... 增加被搜索到的几率 对于谷歌浏览器还是很方便的，直接用xml-sitemaps把你的 博客爬一遍，然后把生成的sitemap.xml上传到谷歌搜索提交上，具体操作如图。 谷歌还有另外一个方法，看下面和百度一起介绍。 百度的话，我真的是没有救了，除非把博客搬到国内来。大概方法说一下。 提交 sitemap 的方法： 进入你的hexo目录下 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在_config.yml添加 1234sitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 接下就添加到百度和谷歌的sitemap里就好了， 但是你添加了是一回事，别人收不收是另外一回事。 + 百度的自动提交 参考这里[Hexo插件之百度主动提交链接][Hexo插件之百度主动提交链接] 参考源 如何让谷歌和百度搜索到自己在GitHub上的博客 Hexo插件之百度主动提交链接","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://greedyhao.cc/tags/hexo/"},{"name":"jekyll","slug":"jekyll","permalink":"http://greedyhao.cc/tags/jekyll/"}]},{"title":"如何入门python","slug":"工作-python-入门-2017-08-13-如何学习python","date":"2017-08-13T05:10:00.000Z","updated":"2017-08-17T07:45:33.000Z","comments":true,"path":"2017/08/13/工作-python-入门-2017-08-13-如何学习python/","link":"","permalink":"http://greedyhao.cc/2017/08/13/工作-python-入门-2017-08-13-如何学习python/","excerpt":"对于如何入门python，网上太多教程，但是很多教程对于初学者并不友好，很多写教程的人都是直接 看别人推荐什么书自己就推荐什么书，这样的教程初学者看了可能想打人；还有的教程作者与初学者 站的高度不一样，导致初学者看着觉得吃力。 感慨这样的情况，又恰好我也刚开始学习python不久，更其他初学者背景相同，又自认为有些许经 验可以供其它初学者参考，便将其写下来，并且会在今后不断完善，且即时更正出现错误的地方。","text":"对于如何入门python，网上太多教程，但是很多教程对于初学者并不友好，很多写教程的人都是直接 看别人推荐什么书自己就推荐什么书，这样的教程初学者看了可能想打人；还有的教程作者与初学者 站的高度不一样，导致初学者看着觉得吃力。 感慨这样的情况，又恰好我也刚开始学习python不久，更其他初学者背景相同，又自认为有些许经 验可以供其它初学者参考，便将其写下来，并且会在今后不断完善，且即时更正出现错误的地方。 对于学习一个知识，我 不推荐看视频， 主要是浪费时间，特别是遇到语速慢的，视频加速都 不能拯救了。推荐的学习方法 看书、看博客、在线练习。 假设你在学习python之前学习过c java的话，在学习python的时候，要抛弃之前的编程习惯， python这门语言如果当成c java来用那就很尴尬了，那样不能体现python的优美，会让你想死。 把我以前看到过的一句金言送给各位: 123Debugging is twice as hard as writing the code in the first place. Therefore,if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it. 开始 使用python写程序就应当使用pythonic的方式，不过在使自己的程序pythonic之前，先要学会 python的一些基本常识，简明 Python 教程 送给你们，这本书是电子版的，缺点是不能拿着读，但是好处是它的一直有在维护的，如果什么地方 有问题，维护这本书的人会即时更改，刚开始学习，首先肯定要保证走的路线是正确的。 为了让自己学的更扎实，你可以选择去 在线练习 ，推荐去codecademy或者 萌码，因为这两个地方的题目我感觉难度比较低，就是感觉有点消耗时间，不过可以用不看 视频节省出来的时间来抵消。 pythonic 开了一个好头以后就要让自己的程序变得pythonic了，推荐去hackerrank 这个网站去看看，顺便刷一下题，帮助学习python。而且这个网站是英文的，你也可以顺便锻炼你的 英文水平。注意，每做完一道题，一定要去这道题的的评论区看看，一般都会有收获的。 另外，我也会把我在评论区看到的不错的内容写下来，放在我的pythonic目录下， 我会不断更新，可以多关注一下。 要想让程序pythonic，我觉得还是要多看看官方文档，多了解些python的Built-in Functions， 不要老想着自己造轮子，自己一个人的力量能有一群人的力量大吗？ 推荐 看书 + 简明 Python 教程 + Effecitive Python 博客 + 廖学峰的Python教程 在线练习 + codecademy + hackerrank + 萌码","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"},{"name":"python","slug":"python","permalink":"http://greedyhao.cc/tags/python/"}]},{"title":"改变小数点位数的方法","slug":"工作-python-入门-2017-08-13-改变小数点位数","date":"2017-08-13T05:10:00.000Z","updated":"2017-08-14T13:25:01.000Z","comments":true,"path":"2017/08/13/工作-python-入门-2017-08-13-改变小数点位数/","link":"","permalink":"http://greedyhao.cc/2017/08/13/工作-python-入门-2017-08-13-改变小数点位数/","excerpt":"接下来就将介绍，当我们需要对输出的小数点位数限制的时候，需要怎么办。","text":"接下来就将介绍，当我们需要对输出的小数点位数限制的时候，需要怎么办。 使用 round: round官方文档 number就是你想format的数，ndigits就是需要的小数点位数。 1print(round(number, ndigits)) 使用 format: format官方文档 .2f就是你的小数的格式，两个小数点位，number就是你要format的数 1print (\"&#123;0:.2f&#125;\".format(number))","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"},{"name":"python","slug":"python","permalink":"http://greedyhao.cc/tags/python/"}]},{"title":"在循环中获取当前list索引","slug":"工作-python-入门-2017-08-13-在循环中获取list索引","date":"2017-08-13T02:20:00.000Z","updated":"2017-08-14T13:26:47.000Z","comments":true,"path":"2017/08/13/工作-python-入门-2017-08-13-在循环中获取list索引/","link":"","permalink":"http://greedyhao.cc/2017/08/13/工作-python-入门-2017-08-13-在循环中获取list索引/","excerpt":"当我们有的时候想在循环中顺便获取当前元素的索引怎么办呢，难道还像c java一样，还用个中间变量 存储当前循环进度？ 那不可能，那样用python还有什么意思。这种情况就应当使用enumerate，这是官方文档","text":"当我们有的时候想在循环中顺便获取当前元素的索引怎么办呢，难道还像c java一样，还用个中间变量 存储当前循环进度？ 那不可能，那样用python还有什么意思。这种情况就应当使用enumerate，这是官方文档 用例： 1234ints = [8, 23, 45, 12, 78]for idx, val in enumerate(ints): print idx, val 参考源 + 在循环中获取索引","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"},{"name":"python","slug":"python","permalink":"http://greedyhao.cc/tags/python/"}]},{"title":"倒序","slug":"工作-python-入门-2017-08-13-list倒序","date":"2017-08-13T02:00:00.000Z","updated":"2017-08-14T13:26:51.000Z","comments":true,"path":"2017/08/13/工作-python-入门-2017-08-13-list倒序/","link":"","permalink":"http://greedyhao.cc/2017/08/13/工作-python-入门-2017-08-13-list倒序/","excerpt":"这里我将介绍使用list和range来进行倒序的方法。","text":"这里我将介绍使用list和range来进行倒序的方法。 list的倒序方法 1a[::-1] //list倒序 range的倒序方法 1range(len(a)-1,-1,-1) 应用到循环中 12345for i in a[::-1]: print(i)for i in range(len(a)-1,-1,-1): print(a[i]) 参考源 + python倒序循环 + Python中range的使用以及reverse List的方法","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"},{"name":"python","slug":"python","permalink":"http://greedyhao.cc/tags/python/"}]},{"title":"输出list中第二大的数","slug":"工作-python-pythonic-2017-08-13-输出第二大的数","date":"2017-08-13T01:20:00.000Z","updated":"2017-08-14T13:27:01.000Z","comments":true,"path":"2017/08/13/工作-python-pythonic-2017-08-13-输出第二大的数/","link":"","permalink":"http://greedyhao.cc/2017/08/13/工作-python-pythonic-2017-08-13-输出第二大的数/","excerpt":"以下内容来自hackerrank上的一个讨论","text":"以下内容来自hackerrank上的一个讨论 题目： 原题在这， 大概意思就是，有两个输入，第一个输出（2~10）是你要输出的数的个数，第二个就是输入你的list， 用空格做分割。 pythonic的解法在这： 12345if __name__ == '__main__': n = int(input()) arr = map(int, input().split()) print(sorted(list(set(arr)))[-2]) 这里的 [-2] 用的很好，我一开始做题的时候还没有想到。 我使用的方法是从已经排序好的list输出他的第len-1个数。","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"python","slug":"python","permalink":"http://greedyhao.cc/tags/python/"},{"name":"pythonic","slug":"pythonic","permalink":"http://greedyhao.cc/tags/pythonic/"}]},{"title":"pythonic的方式输入一个二维list","slug":"工作-python-pythonic-2017-08-13-pythonic的方式输入一个二维list","date":"2017-08-13T01:20:00.000Z","updated":"2017-08-14T13:27:05.000Z","comments":true,"path":"2017/08/13/工作-python-pythonic-2017-08-13-pythonic的方式输入一个二维list/","link":"","permalink":"http://greedyhao.cc/2017/08/13/工作-python-pythonic-2017-08-13-pythonic的方式输入一个二维list/","excerpt":"以下内容来自hackerrank上的一个讨论","text":"以下内容来自hackerrank上的一个讨论 题目： 先输入一个整数（2~5）表示学生数，再连续输入学生姓名和成绩，输出成绩第二低的学生姓名。 示例输入： 12345678910115Harry37.21Berry37.21Tina37.2Akriti41Harsh39 示例输出： 12BerryHarry 中间过程得到的一个list: 1students = [['Harry', 37.21], ['Berry', 37.21], ['Tina', 37.2], ['Akriti', 41], ['Harsh', 39]] 123456marksheet = []for _ in range(0,int(input())): marksheet.append([input(), float(input())])second_lowest = sorted(list(set([marks for name, marks in marksheet])))[1]print('\\n'.join([a for a,b in sorted(marksheet) if b == second_lowest])) 这是第一个人给出的解法，我刚看到觉得不错了，但是当我看到第二个人的解法才瞬间感觉到什么才 叫做pythonic 12345n = int(input())marksheet = [[input(), float(input())] for _ in range(n)]second_lowest = sorted(list(set([marks for name, marks in marksheet])))[1]print('\\n'.join([a for a,b in sorted(marksheet) if b == second_lowest])) 第二个人对第一个人的marksheet的录入进行了简化，简化到只有一行。 特别是他讲的一句话让我感触很大，python写代码就是要精简，如果长过了50行，你将很难Debug。 原文在这。 1Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"python","slug":"python","permalink":"http://greedyhao.cc/tags/python/"},{"name":"pythonic","slug":"pythonic","permalink":"http://greedyhao.cc/tags/pythonic/"}]},{"title":"list comprehensions","slug":"工作-python-pythonic-2017-08-12-list-comprehensions","date":"2017-08-12T14:20:00.000Z","updated":"2017-08-17T09:51:02.000Z","comments":true,"path":"2017/08/12/工作-python-pythonic-2017-08-12-list-comprehensions/","link":"","permalink":"http://greedyhao.cc/2017/08/12/工作-python-pythonic-2017-08-12-list-comprehensions/","excerpt":"这个例子是生成一个(i,j,k)坐标，if (i + j + k) != n，就输出这个坐标。 这里使用了list comprehensions的方法，使得代码变得简洁，更加pythonic","text":"这个例子是生成一个(i,j,k)坐标，if (i + j + k) != n，就输出这个坐标。 这里使用了list comprehensions的方法，使得代码变得简洁，更加pythonic 代码见下方 1234567891011if __name__ == '__main__': x = int(input()) y = int(input()) z = int(input()) n = int(input()) print([[i,j,k] for i in range(x + 1) for j in range(y + 1) for k in range(z + 1) if((i + j + k) != n)]) 对list comprehensions进一步解读 格式如下 1[操作 循环 条件] 用另一个实现swapcase()的例子来解读 123def swap_case(s): tmp = &apos;&apos;.join([i.lower() if i.isupper() else i.upper() for i in s]) return tmp","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"python","slug":"python","permalink":"http://greedyhao.cc/tags/python/"},{"name":"pythonic","slug":"pythonic","permalink":"http://greedyhao.cc/tags/pythonic/"}]},{"title":"人是不理性的","slug":"生活-感悟-2017-08-12-人总是不理性的","date":"2017-08-12T06:00:00.000Z","updated":"2017-08-14T13:28:09.000Z","comments":true,"path":"2017/08/12/生活-感悟-2017-08-12-人总是不理性的/","link":"","permalink":"http://greedyhao.cc/2017/08/12/生活-感悟-2017-08-12-人总是不理性的/","excerpt":"说在前面的话 今天看到一个很有意思的观点：人是不理性的","text":"说在前面的话 今天看到一个很有意思的观点：人是不理性的 正文 可能很多人会感到奇怪，为什么会有这样的观点，人是理性的动物不是我们一直以来都认可的观点吗？ 古有福尔摩斯，今有夏洛克，那些侦探的小说电影，无不体现着我们人类的理性，这突兀出现的观点 说人类不理性，如何能站得住脚？ 会坚信人类是理性的其实也很正常，因为谁都不喜欢自己的所熟悉的事物居然是错误的。其实在要求 人做一个理性的选择时，就可以体现人的不理性了。 有人做过这样一个实验，让一群人从10个完全一样的物品里挑选一个自己最喜欢的并理性的给出自己 喜欢的理由，神奇的是，这些人的选择不尽相同，而且每个人的理由也是千奇百怪。 影响人决定的主要因素是情感和直觉，很多时候你自以为做出的理性的决定其实都有受到情感的影响， 更何况我们这个世界本身就不是线性的，怎么能用简单的线性思维来解决问题？ 后记 这是我在《故事思维》这本书中看到的观点，总感觉自己写围绕这个观点写出来的内容和那本书的 作者写出来的差距很大，自己看了都觉得说服力不行。 总结一下，这篇文章最大问题应该还是出在大篇幅的强行说道理，像最后一段都是结论性的语句，却 没有任何的事实进行衬托，没有学会作者告诉我们的，要利用故事来说明道理，通过影响别人的情感 来影响别人的抉择。","categories":[{"name":"生活","slug":"生活","permalink":"http://greedyhao.cc/categories/生活/"}],"tags":[{"name":"感悟","slug":"感悟","permalink":"http://greedyhao.cc/tags/感悟/"}]},{"title":"培养自信","slug":"生活-鸡汤-2017-08-12-培养自信","date":"2017-08-12T01:00:00.000Z","updated":"2017-08-14T13:28:13.000Z","comments":true,"path":"2017/08/12/生活-鸡汤-2017-08-12-培养自信/","link":"","permalink":"http://greedyhao.cc/2017/08/12/生活-鸡汤-2017-08-12-培养自信/","excerpt":"先从故事开始 我曾在一个公众号上看到一个文章，讲的是一个小孩子，天生脑袋愚钝，考试始终在班级垫底，但是 却有很棒音乐天赋，钢琴弹的非常好，通过艺考去国外上了一个很好的大学，但是她一直很少朋友。 一次偶然的上台表演机会，她的琴技让在场的人都很吃惊，教授感慨道 你为什么要隐藏着自己？由 于被别人承认，她认清了自己，恢复了自信，朋友多了起来，生活重新走上正轨。","text":"先从故事开始 我曾在一个公众号上看到一个文章，讲的是一个小孩子，天生脑袋愚钝，考试始终在班级垫底，但是 却有很棒音乐天赋，钢琴弹的非常好，通过艺考去国外上了一个很好的大学，但是她一直很少朋友。 一次偶然的上台表演机会，她的琴技让在场的人都很吃惊，教授感慨道 你为什么要隐藏着自己？由 于被别人承认，她认清了自己，恢复了自信，朋友多了起来，生活重新走上正轨。 我想说的 我觉得“每个人都有优点”这句话真的没毛病，但是很多时候，自己的优点都被不自信给掩盖掉了。 导致这种情况的原因有很多，比如故事里的那个女孩可能就是由于一直得不到别人的承认；有的父母 喜欢拿“别人家的孩子”和自己孩子比，这也是一个很大的原因。 不自信的种子可能在童年的时候就种下了，发生了的事情我们没有办法阻止，毕竟穿越时空只是幻 想，但是我们还可以经过训练让我们变得自信。 这是我曾经在ted上看过一个讲座的观点，他认为自信是一种技能，是可以学习的。 增加自信可以从两个方向进行，一个是多练习，一个是多承认自己。 practice make perfect.多练习自然就会有自信，毕竟已经胸有成竹，自然不畏惧。 平时多告诉自己，you are wonderful 要给自己找理由表扬自己，自己认可自己是别人认可自己的 开始。具体可以这么操作，把一个问题切分为一个个小问题，然后每完成一个小问题就自我表扬，这 样多解决几个大问题说不定都崇拜上自己了。 天生我才必有用，要告诉自己“你TM才是最棒的”。 后记 恩，写完了，你很棒。","categories":[{"name":"生活","slug":"生活","permalink":"http://greedyhao.cc/categories/生活/"}],"tags":[{"name":"鸡汤","slug":"鸡汤","permalink":"http://greedyhao.cc/tags/鸡汤/"}]},{"title":"解决LCD初始化与串口初始化的冲突","slug":"工作-stm32-2017-08-12-初始化发生冲突","date":"2017-08-11T07:00:00.000Z","updated":"2017-08-14T13:27:58.000Z","comments":true,"path":"2017/08/11/工作-stm32-2017-08-12-初始化发生冲突/","link":"","permalink":"http://greedyhao.cc/2017/08/11/工作-stm32-2017-08-12-初始化发生冲突/","excerpt":"前言 我也是第一次发现这种情况。当我把我的程序烧进stm32发现stm32似乎死机了， 当我把一条条程序分别注释后才发现，忽然是指纹模块和FSMC的初始化发生了冲突， 而且冲突的很诡异，根本看不出哪里冲突了。","text":"前言 我也是第一次发现这种情况。当我把我的程序烧进stm32发现stm32似乎死机了， 当我把一条条程序分别注释后才发现，忽然是指纹模块和FSMC的初始化发生了冲突， 而且冲突的很诡异，根本看不出哪里冲突了。 问题重新定位 经过昨天晚上的测试，我以为是指纹模块和FSMC的初始化出现了冲突，今天再次测试时发现我之前错了。 发现只要调用了TFT屏的初始化程序，stm32就死机了。 我觉得问题可能不是出在初始化程序上，因为我看了很多遍初始化的程序，没有发现有冲突的地方。 重点来了 那么问题到底出在什么地方呢? 我无意间发现当我把串口初始化程序注释掉了以后stm32就工作正常了！！ 12uart_init(9600);usart2_init(usart2_baund); 就是这两句程序导致的问题。 但是我这个项目必须要使用到串口，于是我去搜索了一下串口和FSMC的冲突问题，没想到这么容易就找到了 解决方法:需要把LCD初始化放在uart初始化的前面。 (解决方法来源在第6楼) 我再用我的程序解释一下吧。 12345678910int main(void)&#123; ... LCD_Init(); //LCD初始化在uart初始化的前面 uart_init(9600); usart2_init(usart2_baund); LCD_ClearScreen(BLACK); ...&#125; 问题解决。","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"利用github page搭建博客完整版教程","slug":"工作-jekyll-2017-08-11-完整版搭建博客教学","date":"2017-08-11T00:00:00.000Z","updated":"2017-08-14T13:26:28.000Z","comments":true,"path":"2017/08/11/工作-jekyll-2017-08-11-完整版搭建博客教学/","link":"","permalink":"http://greedyhao.cc/2017/08/11/工作-jekyll-2017-08-11-完整版搭建博客教学/","excerpt":"前言 前两天为了搭建博客，踩了不少的坑，但是昨天发的简易版教程图的是简单，就没把那些复杂的东西放上来， 今天就把我踩过的坑连带着进阶的知识放上来，让你们可以有解决办法。","text":"前言 前两天为了搭建博客，踩了不少的坑，但是昨天发的简易版教程图的是简单，就没把那些复杂的东西放上来， 今天就把我踩过的坑连带着进阶的知识放上来，让你们可以有解决办法。 _config.yml ================= 这是一个重要的文件，看名字也知道，这是一个配置文件。 12345678name: Less Or Moreemail: hao_kr@163.comauthor: Greedyhaourl:resume_site:github: https://github.com/greedyhao/baseurl: &quot;&quot;... 这是我的配置文件的其中一部分。 假如我在另外一个文件中想知道现在这个使用主题的主人是谁，就只需要site.author， 就可以获得作者的名字，这样就不用每换一个使用者就要到处去更改程序，很方便，特别方便那些不是 学网页的人。 简单的修改主题框架 觉得某一个喜欢的主题在某一个地方让自己不满意而自己却不是学网页的怎么办呢？ 不用急，那就使用谷歌爸爸的利器chrome，按F12，开发者工具可以帮助你方便的修改主题。 不懂CSS也能定制博客界面! 另外提醒一下，你在开发者工具的Elements这一栏看到的这一个文件可能不止是一个文件， 可能是多个文件拼在一起的，一般应该在_includes这个文件夹中。 图片的问题 尺寸 图片的尺寸不能太大，否则显示的效果就会不好。送大家一个 缩小图片的利器 + 图片的大小 图片不能太大，太大的图片加载太慢，影响用户体验。这是 压缩图片的利器和 压缩图片的神器--完全可以压缩到你希望的大小 开源协议的使用 相信很多新人都不知道开源协议到底是怎么样的，这里 有一个介绍开源协议的教程，可以参考一下。这一个 是为一个项目添加一个开源协议的教程。 使用github的图片源的问题 之前在github上使用github的图片源时直接使用那一长串的https链接就可以了，但是在 github page搭建的博客上不可以这么用，遮掩的后果是无法显示图片。 第一种解决方法(推荐) 要想在自己博客上显示某张图片，直接将这张图片一起上传到github上就可以了，然后 使用图片的相对路径。如下是一个例子。 1![](/img/jekyll/git图片源问题.png) 第二种解决方法 将图片上传到图床，然后图床会提供一个url，然后使用这个url就可以显示图片了。 推荐的图床：七牛云，SM.MS markdown选用 pygments和redcarpet，在github page上已经不再支持，所以我们要使用替代的 rouge和kramdown，如下更改_config.yml 1234markdown: kramdownkramdown: input: GFMhighlighter: rouge 给博客绑定自己的域名 觉得github的二级域名不够酷炫，那就 绑定自己的域名 吧，我是去Ali的万网 买的，自带云解析，一年也就几十块，便宜的才9.9。 万网支持直接绑定 CNAME，所以..上个图先 如果不支持绑定 CNAME 的，就选择记录类型为A，添加github的ip地址 192.30.252.153 和 192.30.252.154 就可以了，再上个图。 参考源 利用 GitHub Pages 快速搭建个人博客 github上利用jekyll搭建自己的blog的操作顺序？ Jekyll搭建个人博客 玩转jekyll系列（二）之为GitHub Pages博客绑定自定义域名 48 个你需要知道的 Jekyll 使用技巧 Jekyll--绑定域名","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"http://greedyhao.cc/tags/jekyll/"}]},{"title":"学习独立看门狗","slug":"工作-stm32-2017-08-10-IWDG","date":"2017-08-10T12:00:00.000Z","updated":"2017-08-14T13:27:36.000Z","comments":true,"path":"2017/08/10/工作-stm32-2017-08-10-IWDG/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-stm32-2017-08-10-IWDG/","excerpt":"看门狗简述 独立看门狗这个东西比较简单，就是设置一个初值确定它复位的时间，然后在这段时间内必须给它“喂食”，否则就会导致单片机复位。 这个功能是为了防止单片机死机，如果单片机死机就无法给看门狗喂食，那么单片机就会复位。","text":"看门狗简述 独立看门狗这个东西比较简单，就是设置一个初值确定它复位的时间，然后在这段时间内必须给它“喂食”，否则就会导致单片机复位。 这个功能是为了防止单片机死机，如果单片机死机就无法给看门狗喂食，那么单片机就会复位。 操作步骤 取消寄存器写保护 设置看门狗的预分配系数和重装载值 重载计数值喂狗 启动看门狗","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"学习串口","slug":"工作-stm32-2017-08-10-GPIO-Usart","date":"2017-08-10T12:00:00.000Z","updated":"2017-08-14T13:27:30.000Z","comments":true,"path":"2017/08/10/工作-stm32-2017-08-10-GPIO-Usart/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-stm32-2017-08-10-GPIO-Usart/","excerpt":"一般步骤 串口时钟的使能，GPIO时钟使能 串口复位 GPIO端口模式设置 串口参数初始化 开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤 使能串口 编写中断处理函数","text":"一般步骤 串口时钟的使能，GPIO时钟使能 串口复位 GPIO端口模式设置 串口参数初始化 开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤 使能串口 编写中断处理函数 又遇到坑了 ~我是使用原子的库的，但是他的usart.c这个文件有点问题（可能只是我下载的那个有问题吧），重写的fputs有问题，printf根本用不了， 浪费了我好多时间查找解决方法，最后看了原子的官方示例才发现，他的usart.c改过了...~ 我又发现自己之前的想法错了，我改的地方其实无关紧要 这是改之前 1234567//重定义fputc函数int fputc(int ch, FILE *f)&#123; while((USART1-&gt;SR&amp;0X40)==0)；//循环发送,直到发送完毕 USART1-&gt;DR = (u8) ch; return ch;&#125; 这是改之后 1234567int fputc(int ch, FILE *f)&#123; while(USART_GetFlagStatus(USART1,USART_FLAG_TC)==RESET); USART_SendData(USART1,(uint8_t)ch); return ch;&#125; 我发现了我的真正的问题，原来是 uart_init() 函数名打错成 usart_init() ！！！","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"学习GPIO输出","slug":"工作-stm32-2017-08-10-GPIO-Output","date":"2017-08-10T12:00:00.000Z","updated":"2017-08-14T13:27:25.000Z","comments":true,"path":"2017/08/10/工作-stm32-2017-08-10-GPIO-Output/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-stm32-2017-08-10-GPIO-Output/","excerpt":"关键信息 1.使能I/O口时钟，调用函数RCC_APB2PeriphClockCmd() 2.初始化I/O参数,调用函数GPIO_Init() 3.操作I/O","text":"关键信息 1.使能I/O口时钟，调用函数RCC_APB2PeriphClockCmd() 2.初始化I/O参数,调用函数GPIO_Init() 3.操作I/O 初始化GPIO的实例 12345678910RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); //使能I/O时钟GPIO_InitTypeDef GPIO_InitStructure;//创建一个初始化GPIO的结构体GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1|GPIO_Pin_2;//选择初始化的引脚GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//选择引脚模式GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//选择引脚速度GPIO_Init(GPIOB,&amp;GPIO_InitStructure);//初始化I/O参数GPIO_SetBits(GPIOA,GPIO_Pin_1);//操作I/OGPIO_SetBits(GPIOA,GPIO_Pin_2);//设置GPIOA的1，2引脚输出1","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"学习PWM","slug":"工作-stm32-2017-08-10-PWM","date":"2017-08-10T12:00:00.000Z","updated":"2017-08-14T13:27:40.000Z","comments":true,"path":"2017/08/10/工作-stm32-2017-08-10-PWM/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-stm32-2017-08-10-PWM/","excerpt":"PWM简述 PWM的原理照我的理解就是，你设置一段时间一个阈值，让管脚在阈值前输出高电平在阈值后输出低电平（理论上反过来也行，不过我没试过），这样就产生了PWM。 这是一个通过数字控制模拟电路的非常有效的办法。","text":"PWM简述 PWM的原理照我的理解就是，你设置一段时间一个阈值，让管脚在阈值前输出高电平在阈值后输出低电平（理论上反过来也行，不过我没试过），这样就产生了PWM。 这是一个通过数字控制模拟电路的非常有效的办法。 基本步骤 依然的，还是要开启时钟；开启TIM3和复用功能的时钟（RCC_APB1Periph_TIM3,RCC_APB2Periph_AFIO） 设置重映射（这主要是看个人，因为我的开发板上的LED在PC口，但是TIM3_CHx默认在PA口，所以我要重映射） 初始化TIMx 设置TIMx_CHx的PWM模式，使能TIMx的CHx输出 使能TIMx 修改TIMx_CCRx来控制占空比","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"学习窗口看门狗","slug":"工作-stm32-2017-08-10-WWDG","date":"2017-08-10T12:00:00.000Z","updated":"2017-08-14T13:27:53.000Z","comments":true,"path":"2017/08/10/工作-stm32-2017-08-10-WWDG/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-stm32-2017-08-10-WWDG/","excerpt":"基本步骤 使能WWDG时钟（APB1） 设置窗口值和分频值 开启WWDG中断并分组 设置计数器初始值并使能看门狗 编写中断服务函数","text":"基本步骤 使能WWDG时钟（APB1） 设置窗口值和分频值 开启WWDG中断并分组 设置计数器初始值并使能看门狗 编写中断服务函数 说实话，我没有发现窗口看门狗与独立看门狗的区别在哪里...感觉窗口看门狗无非就是可以引起中断 我决定我决定没有区别的原因是因为没有实际的项目去使用他们。根据介绍，窗口看门狗是用来监测由外部干扰 或不可预见的逻辑条件造成的应用程序背离正常运行的序列而产生的软件故障，只能等以后实际应用的时候再去感受了。","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"学习TFT-FSMC","slug":"工作-stm32-2017-08-10-TFTLCD-FSMC","date":"2017-08-10T12:00:00.000Z","updated":"2017-08-14T13:27:44.000Z","comments":true,"path":"2017/08/10/工作-stm32-2017-08-10-TFTLCD-FSMC/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-stm32-2017-08-10-TFTLCD-FSMC/","excerpt":"TFT简述 这个实验是我认为比较麻烦的一个实验了，有一定难度。 主要是我看到书和我使用的开发板不是配套的，所以引出了很多麻烦。","text":"TFT简述 这个实验是我认为比较麻烦的一个实验了，有一定难度。 主要是我看到书和我使用的开发板不是配套的，所以引出了很多麻烦。 基本步骤 LCD初始化 刷屏 做你要做的事 出现的问题 对自己使用的LCD屏了解的不多。这是由于我使用的是普中的stm32的开发板，但我看的书的开发板是正点原子的，两个开发板的LCD是不一样的。普中的LCD是8位 的数据位，而正点原子的是16位，这就导致我使用书中例程的程序时，开发板的LCD没有反应，真的好气啊！然后我找到了普中的例程，仔细的看了一遍，发现 程序中提到普中的LCD是8位的，需要分两次传数据。 以下是对原子的例程的修改 123456789101112131415void LCD_WR_REG(u16 regval)&#123; LCD-&gt;LCD_REG=regval&lt;&lt;8;//写入要写的寄存器序号 &#125;void LCD_WR_DATA(u16 data)&#123; LCD-&gt;LCD_RAM=data&lt;&lt;8;&#125;void LCD_WriteRAM(u16 RGB_Code)&#123; LCD-&gt;LCD_RAM = RGB_Code&amp;0xFF00;//写十六位GRAM LCD-&gt;LCD_RAM = RGB_Code&lt;&lt;8;&#125; 解决完LCD的初始化问题后，还有LCD刷屏的问题。发现原子的刷屏程序也是用不了，参考普中的例程发现，普中在设置光标位置时，还设置了光标的结束位置， 就是给了2AH指令和2BH指令4个参数，问题得以解决。 在屏幕上打印文字。目前还在处理这个问题。问题解决。 一开始我打印出来的文字乱码，我把我的程序与官方的程序进行对比，检查了好几天也没有找出答案，真的好气。最后发现问题居然在字库上；我刚开始只是扫视了一眼， 觉得自己的字库和官方的好像是一样的就没有太多注意，直到最后实在没有办法复制官方的字库发现问题居然解决了..","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"学习定时器","slug":"工作-stm32-2017-08-10-TIM","date":"2017-08-10T12:00:00.000Z","updated":"2017-08-14T13:27:49.000Z","comments":true,"path":"2017/08/10/工作-stm32-2017-08-10-TIM/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-stm32-2017-08-10-TIM/","excerpt":"定时器简述 相信使用过51单片机的人对定时器都很熟悉了吧。 顾名思义，定时器就是用来定时的，固定一个时间，到了以后可以向cpu发送一个中断请求；或者就干脆只是用来等待一段时间；还可以用来产生振荡等 在stm32中，定时器变得复杂多了，但是复杂的只是操作的寄存器变多了，原理并没有改变","text":"定时器简述 相信使用过51单片机的人对定时器都很熟悉了吧。 顾名思义，定时器就是用来定时的，固定一个时间，到了以后可以向cpu发送一个中断请求；或者就干脆只是用来等待一段时间；还可以用来产生振荡等 在stm32中，定时器变得复杂多了，但是复杂的只是操作的寄存器变多了，原理并没有改变 基本步骤 很通常的一个时钟使能（APB1） 初始化定时器参数，设置自动重装值、预分频值、时钟分割、计数方式等(TIM_TimeBaseInitTypeDef) 设置TIM3_DIER允许更新（TIM_ITConfig) TIMx中断优先级设置 使能TIMx工作 编写中断服务函数(TIMx_IRQHandler) 定时的计算时间 Tout=((arr+1)*(psc+1))/Tclk - arr：自动重转载值 - psc：预分频值 - Tout：溢出时间（μs) - Tclk：输入时钟频率","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"学习外部中断","slug":"工作-stm32-2017-08-10-GPIO-EXTI","date":"2017-08-10T12:00:00.000Z","updated":"2017-08-14T13:27:17.000Z","comments":true,"path":"2017/08/10/工作-stm32-2017-08-10-GPIO-EXTI/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-stm32-2017-08-10-GPIO-EXTI/","excerpt":"基本步骤 初始化I/O口为输入 开启AFIO时钟 设置I/O口与中断线的映射关系 初始化线上中断，设置触发条件等 配置中断分组（NVIC），并使能中断 编写中断服务函数","text":"基本步骤 初始化I/O口为输入 开启AFIO时钟 设置I/O口与中断线的映射关系 初始化线上中断，设置触发条件等 配置中断分组（NVIC），并使能中断 编写中断服务函数 基本原理 STM32F103有19个外部中断： - Line 0~15：对应外部 I/O 口的输入中断 - Line 16：连接到 PVD 输出 - Line 17：连接到 RTC 闹钟事件 - Line 18：连接到 USB 唤醒事件 不过 I/O 口外部中断函数只有6个，Line 0~4每个中断线对应一个中断函数，Line 5~9共用中断函数，Line 10~15共用中断函数 对于中断线，你可能感觉很抽象的感觉，下面上一张中断线对应I/O口的图： Line 0对应的是 PA0 ~ PG0,Line 1对应的是 PA1 ~ PG1,同理其他中断线。 中断初始化 STM32有两个中断优先级一个是抢占优先级（NVIC_IRQChannelPreemptionPriority），一个是子优先级（NVIC_IRQChannelSubPriority）， 必须对这两个优先级都进行初始化才行。 遇到中断同时发生，先会判断抢占优先级，如果相同会继续判断子优先级，来确定响应那个中断。 中断函数 示例中断： 1234567void EXTI2_IRQHandler(void)&#123; if(EXTI_GetITStatus(EXTI_Line2) != RESET) &#123; ... //中断逻辑 EXTI_ClearITPendingBit(EXTI_Line2); //清除LINE2上的中断标志位 &#125;&#125; STM32也有6个中断函数 EXTIx_IRQHandler ，类似于51单片机的 interrupt x","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"利用github page搭建博客简易教程","slug":"工作-jekyll-2017-08-10-简易版搭建博客教程","date":"2017-08-10T10:00:00.000Z","updated":"2017-08-14T13:26:23.000Z","comments":true,"path":"2017/08/10/工作-jekyll-2017-08-10-简易版搭建博客教程/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-jekyll-2017-08-10-简易版搭建博客教程/","excerpt":"前言 之前写一些自己的感悟都是放在github上，可是每一个知识点放一个repo，搞到我的github首页都 不好看了，又看到可以利用github page搭建免费个人博客，就萌发了搭建博客的念头。 其中踩了不少的坑，因为jekyll有过大的更新，jekyll3对很多jekyll2的内容不支持，让我抓狂。 所以为了让大家有更好的建立博客的体验，就写了这个简易版的教程。","text":"前言 之前写一些自己的感悟都是放在github上，可是每一个知识点放一个repo，搞到我的github首页都 不好看了，又看到可以利用github page搭建免费个人博客，就萌发了搭建博客的念头。 其中踩了不少的坑，因为jekyll有过大的更新，jekyll3对很多jekyll2的内容不支持，让我抓狂。 所以为了让大家有更好的建立博客的体验，就写了这个简易版的教程。 搭建一个可以用的博客只用三步 第一步，按图中所示步骤创建github账户 第二步，去JekyllThemes找一个自己喜欢的主题，点击Homepage按钮 进入github,然后fork下来。 第三步，回到你fork到的项目的地方，点击Setting，将Repository name，改为 你的github账户名.github.io，大功告成。 测试博客 在浏览器输入 你的github账户名.github.io，查看是否是你的预想一样，快去试试吧。 可能出现的问题 没有和预想的一样，反而出现404的页面。 解决方法 出现这种情况不用紧张，因为github page后台编译你的博客是需要时间的，第一次大概在10分钟左右。 如果10分钟后还是404的页面可以浏览一下github绑定的邮箱，如果github page编译失败的话， 会把错误信息发给你的邮箱。 点击博客内的文章结果404。 解决方法 和上面一个情况一样，等等就好了，一般发生在第一次编译的时候 fork使用另外一个主题后，博客主题任然停留在先前的主题 解决方法 和第一种解决方法一样，等等先，如果是编译问题邮箱会收到错误信息，如果不是编译问题，过一会儿就好了。","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"},{"name":"jekyll","slug":"jekyll","permalink":"http://greedyhao.cc/tags/jekyll/"}]},{"title":"学习GPIO输入","slug":"工作-stm32-2017-08-10-GPIO-Input","date":"2017-08-10T10:00:00.000Z","updated":"2017-08-14T13:27:21.000Z","comments":true,"path":"2017/08/10/工作-stm32-2017-08-10-GPIO-Input/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-stm32-2017-08-10-GPIO-Input/","excerpt":"GPIO_Input 程序很简单，就是读取按键是否按下，控制LED是否点亮。","text":"GPIO_Input 程序很简单，就是读取按键是否按下，控制LED是否点亮。 按键初始化程序 1234567GPIO_InitTypeDef GPIO_InitStructure;RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA| RCC_APB2Periph_GPIOB,ENABLE);GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3| GPIO_Pin_4| GPIO_Pin_5| GPIO_Pin_6;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;GPIO_Init(GPIOB,&amp;GPIO_InitStructure); 按键扫描程序 1234567891011static u8 key_up = 1;if(mode)key_up = 1;if(key_up&amp;&amp;(KEY0 == 0||KEY1 == 0||KEY2 == 0||WK_UP == 0))&#123; delay_ms(10); key_up = 0; if(KEY0 == 0)return KEY0_PRES; else if(KEY1 == 0)return KEY1_PRES; else if(KEY2 == 0)return KEY2_PRES; else if(WK_UP == 0)return WKUP_PRES;&#125;else if(KEY0 == 1&amp;&amp;KEY1 == 1&amp;&amp;KEY2 == 1&amp;&amp;WK_UP == 1)key_up = 1; LED的程序就免了，就只是使用了PA的1，2，3引脚。 程序仿真成功，但是烧录进单片机后，无法实现，问题筛查中。 问题描述： 始终只有一个LED处于点亮状态，而且按键无法改变LED状态。 问题筛查 我使用的是stm32的最小系统板，外设在另外一块板，怀疑共地问题。但在我让stm32最小系统板与另外一块板共地后问题依然存在，所以该情况排除。 怀疑LED点亮程序有问题。单独把LED的程序提取出来实验，工作正常。 怀疑按键程序有问题。经实验验证，按键按下无反应，按键程序存在问题可能性很大。 问题解决 因为仿真时不存在问题，所以程序本身正确的可能性非常大。怀疑硬件方面存在问题，等使用stm32的开发板重新验证一次程序看看。 已解决 在另外一块stm32的开发板上程序正常运行","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"开始学习stm32","slug":"工作-stm32-2017-08-10-开始学习stm32","date":"2017-08-10T10:00:00.000Z","updated":"2017-08-14T13:27:13.000Z","comments":true,"path":"2017/08/10/工作-stm32-2017-08-10-开始学习stm32/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-stm32-2017-08-10-开始学习stm32/","excerpt":"说说我的教材吧 我使用的是原子的stm32的书， 手上暂时没有其他的书了，就只能将就着用这本了，听说口碑还是不错的。","text":"说说我的教材吧 我使用的是原子的stm32的书， 手上暂时没有其他的书了，就只能将就着用这本了，听说口碑还是不错的。 配置开发环境 这两个是必要的开发程序,网上随便一搜一大把教程。MDK5是可以安装C51的库进行51单片机的开发的，MDK5还有实时语法检测，用起来很爽。 除了这两个软件以外，还要进行stm32的配置（应该叫做 新建基于固件库的MDK5工程模板，网上也是一堆教程。 初始化MDK5 下载STM32固件库 我用的是STM32F10x_StdPeriph_Lib_V3.5.0 STM32跟51单片机其实本质上并没有什么差别，都是一样的冯罗伊曼架构，只不过就是寄存器多了一点而已； 所以要直接对STM32寄存器操作就变得不容易了，因为你可能记不完全，这时候固件库的重要性就体现出来了。 这个库给我们提供的库函数可以让我们轻松的开发STM32，而不用刻意去记忆寄存器。 建立工程并复制固件库到本地文件夹 先建立一个文件夹，新建USER文件夹，将工程文件保存在其中 再建立与USER同级文件夹CORE,OBJ,STM32F10X_FWLib 将STM32F10x_StdPeriph_Lib_V3.5.032F10x_StdPeriph_Driver下的inc, src这两个目录拷贝去STM32F10X_FWLib 将*STM32F10x_StdPeriph_Lib_V3.5.03下的core_cm3.c和core_cm3.h拷贝去CORE 在*STM32F10x_StdPeriph_Lib_V3.5.0332F10x\\startup下，有8个启动文件，选择对应的启动文件， 拷贝到CORE中。 startup_stm32f10x_cl.s适用于小容量，startup_stm32f10x_md.s适用于中等容量，startup_stm32f10x_hd.s适用于大容量。小容量：Flash≤32KB， 中等容量：64KB≤Flash≤128KB，大容量：256KB≤Flash 将STM32F10x_StdPeriph_Lib_V3.5.0332F10x下的3个文件stm32f10x.h，system_stm32f10x.c， system_stm32f10x.h拷贝到USER中 将STM32F10x_StdPeriph_Lib_V3.5.032F10x_StdPeriph_Template中的4个文件main.c，stm32f10x_conf.h，stm32f10x_it.c， stm32f10x_it.h拷贝到USER中 ### 将固件库添加进工程中 在工程目录下新建4个文件夹 USER, CORE, OBJ, FWLib 将本地文件夹中对应文件夹的.c文件添加进工程中 配置头文件目录 如图所示，添加你的头文件的目录 仿真的配置问题 如图所示 get到的新东西 stm32居然有多个时钟源，这是我之前不知道的，多个时钟源的原因是为了节省资源，时钟越快功耗越大，同时抗电磁干扰能力也会越弱，而有些外设需要的时钟并不需要太快，所以stm32通过分频，不同的5个时钟源给不同的外设。 结构体的使用。之前学习51单片机时，其实很多c语言的知识都没有用上的，一直不明白那些知识的用处。在我看stm32的固件库的时候，看见了很多函数的参数都是用结构体来传递的，这样的好处是参数的个数比较容易更改，只需要更改结构体中的参数个数就可以了。 定义自己的类型。这也是我在看stm32的固件库才了解到的，虽然我很久以前就知道要定义自己的数据类型，但一直都很少用，因为作用不大，在stm32固件库中看见了大量的使用，固件库中所有的数据类型都是使用自己的定义，我觉得这样的好处是可以增加程序的易读性和兼容性。 123456789101112131415/*stm32f10x.h*/...typedef struct&#123; __IO uint16_t CR1; uint16_t RESERVED0; __IO uint16_t CR2; uint16_t RESERVED1;...&#125; TIM_TypeDef;.../*stm32f10x_tim.h*/...void TIM_DeInit(TIM_TypeDef* TIMx);... 这是固件库中的一段对结构体的用法和定义自己的数据类型。","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"},{"name":"stm32","slug":"stm32","permalink":"http://greedyhao.cc/tags/stm32/"}]},{"title":"安装sublime可能出现问题并解决","slug":"工作-sublime-2017-08-10-在ubuntu16上安装sublime3出现的问题并解决","date":"2017-08-10T09:00:00.000Z","updated":"2017-08-14T13:28:02.000Z","comments":true,"path":"2017/08/10/工作-sublime-2017-08-10-在ubuntu16上安装sublime3出现的问题并解决/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-sublime-2017-08-10-在ubuntu16上安装sublime3出现的问题并解决/","excerpt":"安装sublime-text-3 添加sublime text 3的仓库： sudo add-apt-repository ppa:webupd8team/sublime-text-3 根据提示按ENTER 继续，建立信任数据库","text":"安装sublime-text-3 添加sublime text 3的仓库： sudo add-apt-repository ppa:webupd8team/sublime-text-3 根据提示按ENTER 继续，建立信任数据库 更新软件库 sudo apt update 安装Sublime Text 3 sudo apt install sublime-text-installer 等待软件安装成功…… 安装Packeage Control（这步开始出现问题） 第一种解决方法（在我这不成功） 在bash中输入subl后，按ctrl + `，调出命令输入窗口，然后输入以下命令。 12345678import urllib.request,os,hashlib;h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;;pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path();urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) );by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read();dh = hashlib.sha256(by).hexdigest();print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h))if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 但是我这里尝试这种方法不成功，调试信息如下： 12345678910111213141516171819File &quot;./python3.3/urllib/request.py&quot;, line 1248, in do_openFile &quot;./python3.3/http/client.py&quot;, line 1065, in requestFile &quot;./python3.3/http/client.py&quot;, line 1103, in _send_requestFile &quot;./python3.3/http/client.py&quot;, line 1061, in endheadersFile &quot;./python3.3/http/client.py&quot;, line 906, in _send_outputFile &quot;./python3.3/http/client.py&quot;, line 844, in sendFile &quot;./python3.3/http/client.py&quot;, line 822, in connectFile &quot;./python3.3/socket.py&quot;, line 435, in create_connectionFile &quot;./python3.3/socket.py&quot;, line 426, in create_connectionConnectionRefusedError: [Errno 111] Connection refusedFile &quot;/home/dlyman/.config/sublime-text-3/Packages/tern_for_sublime/tern.py&quot;, line 264, in freq = opener.open(&quot;http://&quot; + localhost + &quot;:&quot; + str(port) + &quot;/&quot;, json.dumps(doc).encode(&quot;utf-8&quot;), 1)File &quot;./python3.3/urllib/request.py&quot;, line 469, in openFile &quot;./python3.3/urllib/request.py&quot;, line 487, in _openFile &quot;./python3.3/urllib/request.py&quot;, line 447, in _call_chainFile &quot;./python3.3/urllib/request.py&quot;, line 1274, in http_openFile &quot;./python3.3/urllib/request.py&quot;, line 1251, in do_openurllib.error.URLError: &lt;urlopen error [Errno 111] Connection refused&gt; 手动进行安装 需要从git下载Package Control主文件到~/.config/sublime-text-3/Packages/ 12cd ~/.config/sublime-text-3/Packages/git clone https://github.com/wbond/package_control_channel.git Package\\ Control 然后进行下列步骤： 1. 点击Preferences &gt; Browse Packages菜单 2. 进入打开的目录的上层目录，然后再进入Installed Packages目录 3. 下载 Package Control.sublime-package，并将该文件复制到Installed Packages目录 4. 重启Sublime Text 解决无法输入中文问题 推荐的解决方法 Update and then upgrade your system to the newest 1sudo apt-get update &amp;&amp; sudo apt-get upgrade 把这个repo克隆到你的电脑 : 1git clone https://github.com/lyfeyaj/sublime-text-imfix.git 到 sublime-text-imfix 目录: 1cd sublime-text-imfix 运行下面这条命令 : 1./sublime-imfix Done! 重启sublime即可完成 解决Sublime包管理Package Control 报错 There Are No Packages Available For Installation 解决1： 网上说是因为IPV6的问题，导致无法访问sublime的官网,于是在host中添加如下对应ip 12#sublime#50.116.34.243 sublime.wbond.net 如解决1没有解决这个问题可以去 查找其他解决方法 参考源 http://blog.csdn.net/cywosp/article/details/32721011 https://github.com/lyfeyaj/sublime-text-imfix http://www.dongcoder.com/detail-488469.html http://www.jianshu.com/p/a85bb1043f69 https://www.cnblogs.com/ae6623/p/5338049.html","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"},{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"}]},{"title":"Linux介绍","slug":"工作-Linux-2017-08-10-Linux入门","date":"2017-08-10T08:50:00.000Z","updated":"2017-08-14T13:26:33.000Z","comments":true,"path":"2017/08/10/工作-Linux-2017-08-10-Linux入门/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-Linux-2017-08-10-Linux入门/","excerpt":"Linux入门 安装Linux环境 我试过了四种方式的安装 1. 直接将win系统换成ubuntu 2. 让ubuntu和win共存 3. 在另外一个硬盘上安装ubuntu 4. 在虚拟机中安装ubuntu","text":"Linux入门 安装Linux环境 我试过了四种方式的安装 1. 直接将win系统换成ubuntu 2. 让ubuntu和win共存 3. 在另外一个硬盘上安装ubuntu 4. 在虚拟机中安装ubuntu 现在我来说说我的感觉吧，对于刚开始学Linux的朋友，第一种方法不太推荐，win的很多程序在Linux中都没有， 你可能很不习惯；Linux安装软件的方法你可能也不习惯；还有很多一大堆的命令你不知道；总之你会到处碰壁。 第二种和第三种其实本质差不多，还不错吧，就是存在把win装坏的风险，提醒一下，这两种方法不要分boot分区， 不然你会后悔的。第四种我是最推荐的，在虚拟机中，你随便怎么弄都可以，反正没有什么影响；安装vmware tools 时可能会有一些错误，自己谷歌或百度吧。 常用工具 vim gedit gcc make shell make","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"},{"name":"Linux","slug":"Linux","permalink":"http://greedyhao.cc/tags/Linux/"}]},{"title":"从51最小系统开始","slug":"工作-altium-2017-08-10-绘制51最小系统板","date":"2017-08-10T08:49:00.000Z","updated":"2017-08-14T13:26:05.000Z","comments":true,"path":"2017/08/10/工作-altium-2017-08-10-绘制51最小系统板/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-altium-2017-08-10-绘制51最小系统板/","excerpt":"绘制51最小系统板 我在之前从没有完整的画过51系统最小板，现在就来尝试。","text":"绘制51最小系统板 我在之前从没有完整的画过51系统最小板，现在就来尝试。 步骤 建立project 画原理图 画stc89c52rc的元件库 画pcb 画stc89c52rc的元件库 去stc官网下载datasheet:stc89c52rc 阅读PDF的方法 先建立LibPkg,再添加一个SchLib，文件名自订。 再器件中选择添加，添加stc89c52rc如图： 放置矩形，添加管脚。双击管脚可以添加属性，属性参照datasheet。 如果想让管脚显示上划线，只需要在文字输入框中在需要加上划线的字母后面加上“”这个符号即可。 画stc89c52rc的封装 创建一个PCB封装库 选择工具-&gt;元器件向导 根据datasheet添加参数 画原理图 对照datasheet画最小系统板 画PCB 将原理图导入PCB中，布局，走线 完成任务","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Altium","slug":"Altium","permalink":"http://greedyhao.cc/tags/Altium/"}]},{"title":"Altium入门","slug":"工作-altium-2017-08-10-Altium学习","date":"2017-08-10T08:48:00.000Z","updated":"2017-08-14T13:25:21.000Z","comments":true,"path":"2017/08/10/工作-altium-2017-08-10-Altium学习/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-altium-2017-08-10-Altium学习/","excerpt":"准备开发环境 这是必要的，本着有最新的就用最新的理念，我下载使用的是Altium Dsigned16,有钱买正版，没钱就破解，破解过程就不献丑了， 无非就是给AD16添加一个license而已。","text":"准备开发环境 这是必要的，本着有最新的就用最新的理念，我下载使用的是Altium Dsigned16,有钱买正版，没钱就破解，破解过程就不献丑了， 无非就是给AD16添加一个license而已。 熟悉界面 现在市面上大部分的教程主要都是对界面的介绍，都很详细，看着都觉得烦，一本本都和说明书一样，没碰过Altium的人可以买或借一本Altium的书， 用来当说明书，使用的软件版本越新越好；视频就不考虑了吧，进度太慢，语速太慢，效率太低。 学习流程 第一阶段学习 熟悉界面，会画元件库、PCB库，会画原理图、PCB图。 下一个阶段 优化原理图界面，不同功能模块分离；PCB好的布局，走线。 第一阶段的学习 添加元件库 我选中的这两个是经常用的库，Miscellaneous Connectors.IntLib里是一些常用的连接器件，Miscellaneous Device.IntLib里是一些常用的元件。 你的元件库在你安装Altium时就给你安装上了的，安装位置如图： 绘制自己的元件库 由于电子的世界更新很快，很多元件由于比较新，所以官方元件库中可能没有，这时候就需要自己画了；具体过程自己查，我就总结一下。 - 首先是要查看该元件的datesheet - 元件库中画一个元件的形状是可以随意的，不会影响元件的电气特性，所以元器件的大小，引脚间距，怎么开心怎么画；有时候为了原理图连线的方便， 也会适当的调整引脚位置，甚至隐藏引脚。 这是我画的一个三端稳压器： - 画完后要选择引脚封装，这个很重要，这才会影响元件的电气特性。 然后弹出下面的界面，在筛选处选择自己需要的元件封装： 绘制原理图 这个刚开始学习的时候并没有什么难度，按照需要绘制就好。 绘制PCB 我在刚开始的时候真的不知道怎么下手，很多书说的都不清楚，我就总结一下。 - 首先是从原理图导入元件 - 接下来把那个红色的room移动，再删除这个room 然后手动更改布局 最后自动走线外加手动更加走线","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"Altium","slug":"Altium","permalink":"http://greedyhao.cc/tags/Altium/"},{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"}]},{"title":"doxygen简明指南","slug":"工作-doxygen-2017-08-10-Using-doxygen","date":"2017-08-10T05:33:00.000Z","updated":"2017-08-14T13:26:11.000Z","comments":true,"path":"2017/08/10/工作-doxygen-2017-08-10-Using-doxygen/","link":"","permalink":"http://greedyhao.cc/2017/08/10/工作-doxygen-2017-08-10-Using-doxygen/","excerpt":"doxygen介绍 相信学习嵌入式开发的人都知道，在官方头文件中总是有很多酷炫的注释。 我一直很疑惑，这些注释到底有什么用，直到我看到了doxygen才明白。","text":"doxygen介绍 相信学习嵌入式开发的人都知道，在官方头文件中总是有很多酷炫的注释。 我一直很疑惑，这些注释到底有什么用，直到我看到了doxygen才明白。 使用目的 doxygen会根据你代码中的注释，自动生成文档，可以是html,也可以是pdf。 这些文档可以让别人快速了解你的API，并使用它。 安装与使用 下载安装doxygen doxygen on win 使用方法 windows下使用 你需要稍微了解一下windows命令行常用命令 可以选择使用powershell 打开命令行，cd到你要生成文档的源文件的位置，在命令行输入 1doxygen -g 成功后，当前目录生成一个Doxyfile的配置文件，并显示以下信息 1234Configuration file `Doxyfile&apos; created.Now edit the configuration file and enter doxygen Doxyfileto generate the documentation for your project 接下来就可以对Doxyfile进行修改 如果不需要PDF输出就把 1GENERATE_LATEX = YES 修改为 1GENERATE_LATEX = NO 配置文件里有相关配置的描述，可以参考下 修改配置文件结束后，就可以进行文档的输出了，在命令行输入以下命令 1doxygen .\\Doxyfile 使用方法参考Doxygen 10 分钟入门教程 doxygen注释风格 命令 说明 @file 档案的批注说明 @author 作者信息 @brief 简要说明 @param 参数说明eg:参数a + ' ' + 作用 @return 描述该函数的返回值情况 @retval 描述返回值类型 @note 注解 @attention 注意 @warning 警告信息 @enum 引用了某个枚举，Doxygen会在该枚举处产生一个链接 @var 引用了某个变量，Doxygen会在该枚举处产生一个链接 @class 引用某个类 @exception 可能产生的异常描述 参考来源Doxygen注释风格 ## 可能出现的问题 1. 中文输出乱码 ![](/img/doxygen/garbled1.png) 解决方法 修改Doxyfile 1INPUT_ENCODING = GB2312 - 修改后效果图","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"},{"name":"doxygen","slug":"doxygen","permalink":"http://greedyhao.cc/tags/doxygen/"}]},{"title":"Matlab2016a安装使用","slug":"工作-matlab-2017-08-09-Matlab2016a安装使用","date":"2017-08-08T16:00:00.000Z","updated":"2017-08-14T13:26:38.000Z","comments":true,"path":"2017/08/09/工作-matlab-2017-08-09-Matlab2016a安装使用/","link":"","permalink":"http://greedyhao.cc/2017/08/09/工作-matlab-2017-08-09-Matlab2016a安装使用/","excerpt":"注意事项 有稳定收入的人员可以离开了，有钱还是购买吧，支持一下作者吧。 以下就是我参考别人文章破解安装的过程。","text":"注意事项 有稳定收入的人员可以离开了，有钱还是购买吧，支持一下作者吧。 以下就是我参考别人文章破解安装的过程。 下载安装 给大家提供一个下载地址吧，我是在这儿下载的。 破解过程参考这里 遇到的问题 Tips:如果你是按照我前面的描述操作的话是不会出现我这个问题的。 第一次按教程安装破解完软件后出现了个问题，运行matlab时提示说缺少icuuc64.dll。当场我就懵逼了， 怎么还有这种操作？？？ Google了也没发现有人有这种情况，最后实在没办法，随便下载了一个icuuc64.dll，再次运行matlab，结果 直接报错，停止运行。整个人都不好了。 接下来我再次运行安装程序，覆盖安装matlab9.0，安装后运行还是报错... 没办法，只能卸载后再次重新安装破解，但是问题并没有解决。 然后我开始怀疑是不是我的crace包有问题（因为我的crack是之前下载的，.../bin/win64下居然有4个dll文件）， 然后我下载了这个下载地址里的crack包，重新安装破解。 最后问题解决。没想到一个crack包浪费了我3个多小时，给了我一个很好的教训。","categories":[{"name":"工作","slug":"工作","permalink":"http://greedyhao.cc/categories/工作/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://greedyhao.cc/tags/入门/"},{"name":"Matlab","slug":"Matlab","permalink":"http://greedyhao.cc/tags/Matlab/"}]}]}